/**
 * @name CVE-2025-38255
 * @description Detects calls to `kcalloc` where the size argument, derived from a function parameter,
 *              is not checked for a value of zero. Passing zero to `kcalloc` returns `ZERO_SIZE_PTR`,
 *              leading to a NULL pointer dereference if this pointer is subsequently used.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/unchecked-kcalloc-size
 * @tags security
 *       correctness
 *       denial-of-service
 *       external/cwe/cwe-476
 * @patch-commit 344ef45b03336e7f74658814f66483b5417c9cf1
 * @source-file lib/group_cpus.c
 * @affected-function group_cpus_evenly
 * @kernel-config N/A (enabled by default)
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *     @@ -352,6 +352,9 @@ struct cpumask *group_cpus_evenly(unsigned int numgrps)
 *      	int ret = -ENOMEM;
 *      	struct cpumask *masks = NULL;
 *      
 *      +	if (numgrps == 0)
 *      +		return NULL;
 *      +
 *      	if (!zalloc_cpumask_var(&nmsk, GFP_KERNEL))
 *      		return NULL;
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38255
 *             https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=344ef45b03336e7f74658814f66483b5417c9cf1
 * @remediation 
 * @patch-description |
 *     lib/group_cpus: fix NULL pointer dereference from group_cpus_evenly()
 *     While testing null_blk with configfs, echo 0 > poll_queues will trigger
 *     following panic:
 *     
 *     BUG: kernel NULL pointer dereference, address: 0000000000000010
 *     Oops: Oops: 0000 [#1] SMP NOPTI
 *     CPU: 27 UID: 0 PID: 920 Comm: bash Not tainted 6.15.0-02023-gadbdb95c8696-dirty #1238 PREEMPT(undef)
 *     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.1-2.fc37 04/01/2014
 *     RIP: 0010:__bitmap_or+0x48/0x70
 *     Call Trace:
 *      <TASK>
 *      __group_cpus_evenly+0x822/0x8c0
 *      group_cpus_evenly+0x2d9/0x490
 *      blk_mq_map_queues+0x1e/0x110
 *      null_map_queues+0xc9/0x170 [null_blk]
 *      blk_mq_update_queue_map+0xdb/0x160
 *      blk_mq_update_nr_hw_queues+0x22b/0x560
 *      nullb_update_nr_hw_queues+0x71/0xf0 [null_blk]
 *      nullb_device_poll_queues_store+0xa4/0x130 [null_blk]
 *      configfs_write_iter+0x109/0x1d0
 *      vfs_write+0x26e/0x6f0
 *      ksys_write+0x79/0x180
 *      __x64_sys_write+0x1d/0x30
 *      x64_sys_call+0x45c4/0x45f0
 *      do_syscall_64+0xa5/0x240
 *      entry_SYSCALL_64_after_hwframe+0x76/0x7e
 *     
 *     Root cause is that numgrps is set to 0, and ZERO_SIZE_PTR is returned from
 *     kcalloc(), and later ZERO_SIZE_PTR will be deferenced.
 *     
 *     Fix the problem by checking numgrps first in group_cpus_evenly(), and
 *     return NULL directly if numgrps is zero.
 */


import cpp
import semmle.code.cpp.controlflow.Guards
import semmle.code.cpp.controlflow.ControlFlowGraph

/** Helper family that can return ZERO_SIZE_PTR or similar for zero-sized input. */
predicate isAllocName(string n) {
  n = "kcalloc" or
  n = "kvcalloc" or
  n = "kmalloc_array" or
  n = "kvmalloc_array" or
  n = "krealloc_array"
}

/** Macro-style allocation invocation (kcalloc macro etc.) */
class AllocMacro extends MacroInvocation {
  AllocMacro() { isAllocName(this.getMacroName()) }
}

/** Size-slot for macros (mirrors function helper signatures) */
predicate macroSizeSlot(AllocMacro m, int i) {
  m.getMacroName() = "kcalloc" and i in [0,1] or
  m.getMacroName() = "kvcalloc" and i in [0,1] or
  m.getMacroName() = "kmalloc_array" and i in [0,1] or
  m.getMacroName() = "kvmalloc_array" and i in [0,1] or
  m.getMacroName() = "krealloc_array" and (i = 1 or i = 2)
}

/** Macro expanded argument directly parameter (textual name equality). */
predicate macroArgIsDirectParam(AllocMacro m, int i, Parameter p) {
  macroSizeSlot(m, i) and m.getExpandedArgument(i) = p.getName()
}

/** Structural mention inside macro expanded argument (parameter name appears as substring). */
predicate macroArgStructMentionsParam(AllocMacro m, int i, Parameter p) {
  macroSizeSlot(m, i) and m.getExpandedArgument(i).regexpMatch(".*\\b" + p.getName() + "\\b.*") and not macroArgIsDirectParam(m,i,p)
}

predicate macroParamContributes(AllocMacro m, Parameter p) {
  exists(int i | macroSizeSlot(m, i) and (macroArgIsDirectParam(m, i, p) or macroArgStructMentionsParam(m, i, p)))
}

predicate macroHasNonZeroGuard(AllocMacro m, Parameter p) {
  exists(GuardCondition gc |
  gc.getEnclosingFunction() = p.getFunction() and
  gc.getEnclosingFunction() = m.getEnclosingFunction() and
  gc.ensuresEq(p.getAnAccess(), 0, _, false)
  )
}

predicate macroUnchecked(AllocMacro m, Parameter p) {
  p.getFunction() = m.getEnclosingFunction() and p.getType() instanceof IntegralType and macroParamContributes(m, p) and not macroHasNonZeroGuard(m, p)
}

predicate macroDirect(AllocMacro m, Parameter p) { exists(int i | macroArgIsDirectParam(m, i, p)) }

from Locatable loc, Parameter p, string allocName, string k
where
  (
    exists(AllocMacro m |
      macroUnchecked(m, p) and loc = m and allocName = m.getMacroName() and
      (k = "direct" and macroDirect(m, p) or k = "composite" and not macroDirect(m, p))
    )
  )
select loc,
  "Unchecked zero-size sensitive allocation '" + allocName + "': parameter '$@' used as " + k + " size expression without non-zero guard (param != 0).",
  p, p.getName()