import cpp
import semmle.code.cpp.controlflow.Guards

/**
 * 一个谓词，用于判断一个`kcalloc`宏调用是否被安全地保护。
 * 如果一个调用受某个保护条件的控制，并且该条件能确保大小参数`numgrps`不等于零，则该调用被认为是安全的。
 */
predicate isSafelyGuarded(MacroInvocation kcallocInvocation, Parameter numgrps) {
  exists(GuardCondition nonZeroCheck |
    // 保护条件必须确保在通往调用的路径上`numgrps`不等于0。
    // 我们检查保护条件对宏调用自身所在基本块的控制。
    nonZeroCheck.ensuresEq(numgrps.getAnAccess(), 0, kcallocInvocation.getExpr().getBasicBlock(), false)
  )
}

from
  Function group_cpus_evenly,
  Parameter numgrps,
  MacroInvocation kcallocInvocation
where
  // 1. 定义“全集”：所有可能存在问题的kcalloc宏调用。
  group_cpus_evenly.hasName("group_cpus_evenly") and
  group_cpus_evenly.getFile().getBaseName().matches("group_cpus%") and

  // 决定分配大小的参数。
  numgrps = group_cpus_evenly.getParameter(0) and

  // 宏调用在此函数内。
  kcallocInvocation.getEnclosingFunction() = group_cpus_evenly and
  // 这是关键改动：我们寻找一个名为 "kcalloc" 的宏调用。
  kcallocInvocation.getMacroName() = "kcalloc" and

  // 宏调用的第一个参数是我们的参数。
  // 我们在参数上使用`getExpr()`来获取原始表达式。
  kcallocInvocation.getExpandedArgument(0) = "numgrps" and

  // 2. 使用谓词来排除安全/已修复的情况。
  // 我们寻找那些没有被安全保护的宏调用。
  not isSafelyGuarded(kcallocInvocation, numgrps)

select kcallocInvocation, numgrps