/**
 * @name CVE-2025-38255 (generalized)
 * @description Detects zero-sizeâ€“sensitive allocation helpers whose size arguments come (directly or
 *              structurally) from a function parameter without a guarding non-zero check.
 * @kind problem
 * @problem.severity error
 * @precision medium
 * @id cpp/unchecked-zero-size-allocation
 * @tags security correctness denial-of-service external/cwe/cwe-476
 */
import cpp
import semmle.code.cpp.controlflow.Guards
import semmle.code.cpp.controlflow.ControlFlowGraph

/** Helper family that can return ZERO_SIZE_PTR or similar for zero-sized input. */
predicate isAllocName(string n) {
  n = "kcalloc" or
  n = "kvcalloc" or
  n = "kmalloc_array" or
  n = "kvmalloc_array" or
  n = "krealloc_array"
}

/** Macro-style allocation invocation (kcalloc macro etc.) */
class AllocMacro extends MacroInvocation {
  AllocMacro() { isAllocName(this.getMacroName()) }
}

/** Size-slot for macros (mirrors function helper signatures) */
predicate macroSizeSlot(AllocMacro m, int i) {
  m.getMacroName() = "kcalloc" and i in [0,1] or
  m.getMacroName() = "kvcalloc" and i in [0,1] or
  m.getMacroName() = "kmalloc_array" and i in [0,1] or
  m.getMacroName() = "kvmalloc_array" and i in [0,1] or
  m.getMacroName() = "krealloc_array" and (i = 1 or i = 2)
}

/** Macro expanded argument directly parameter (textual name equality). */
predicate macroArgIsDirectParam(AllocMacro m, int i, Parameter p) {
  macroSizeSlot(m, i) and m.getExpandedArgument(i) = p.getName()
}

/** Structural mention inside macro expanded argument (parameter name appears as substring). */
predicate macroArgStructMentionsParam(AllocMacro m, int i, Parameter p) {
  macroSizeSlot(m, i) and m.getExpandedArgument(i).regexpMatch(".*\\b" + p.getName() + "\\b.*") and not macroArgIsDirectParam(m,i,p)
}

predicate macroParamContributes(AllocMacro m, Parameter p) {
  exists(int i | macroSizeSlot(m, i) and (macroArgIsDirectParam(m, i, p) or macroArgStructMentionsParam(m, i, p)))
}

predicate macroHasNonZeroGuard(AllocMacro m, Parameter p) {
  exists(GuardCondition gc |
  gc.getEnclosingFunction() = p.getFunction() and
  gc.getEnclosingFunction() = m.getEnclosingFunction() and
  gc.ensuresEq(p.getAnAccess(), 0, _, false)
  )
}

predicate macroUnchecked(AllocMacro m, Parameter p) {
  p.getFunction() = m.getEnclosingFunction() and p.getType() instanceof IntegralType and macroParamContributes(m, p) and not macroHasNonZeroGuard(m, p)
}

predicate macroDirect(AllocMacro m, Parameter p) { exists(int i | macroArgIsDirectParam(m, i, p)) }

from Locatable loc, Parameter p, string allocName, string k
where
  (
    exists(AllocMacro m |
      macroUnchecked(m, p) and loc = m and allocName = m.getMacroName() and
      (k = "direct" and macroDirect(m, p) or k = "composite" and not macroDirect(m, p))
    )
  )
select loc,
  "Unchecked zero-size sensitive allocation '" + allocName + "': parameter '$@' used as " + k + " size expression without non-zero guard (param != 0).",
  p, p.getName()