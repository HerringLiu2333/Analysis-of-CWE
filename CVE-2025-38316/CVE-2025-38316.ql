/**
 * @name CVE-2025-38316
 * @description Detects a NULL pointer dereference vulnerability in the mt7996_set_monitor function.
 *              The function dereferences the 'phy' pointer before checking if it is NULL.
 *              This can be triggered by passing a NULL pointer, leading to a kernel panic and denial of service.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/null-dereference-before-check
 * @tags security
 *       correctness
 *       vulnerability
 *       denial-of-service
 *       external/cwe/cwe-476
 * @patch-commit cb423ddad0f6e6f55b1700422ab777b25597cc83
 * @source-file drivers/net/wireless/mediatek/mt76/mt7996/main.c
 * @affected-function mt7996_set_monitor
 * @kernel-config CONFIG_MT7996E
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *      @@ -414,11 +414,13 @@ static void mt7996_phy_set_rxfilter(struct mt7996_phy *phy)
 *       
 *       static void mt7996_set_monitor(struct mt7996_phy *phy, bool enabled)
 *       {
 *      -	struct mt7996_dev *dev = phy->dev;
 *      +	struct mt7996_dev *dev;
 *       
 *       	if (!phy)
 *       		return;
 *       
 *      +	dev = phy->dev;
 *      +
 *       	if (enabled == !(phy->rxfilter & MT_WF_RFCR_DROP_OTHER_UC))
 *       		return;
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38316
 */

import cpp

/**
 * 查找函数参数的空指针检查
 */
predicate isNullCheck(Expr check, Parameter param) {
  exists(EqualityOperation eq |
    eq = check and
    (
      // 检查 !param 模式
      (eq.getAnOperand().(NotExpr).getOperand() = param.getAnAccess() and
       eq.getAnOperand().(Literal).getValue() = "0") or
      // 检查 param == NULL 模式  
      (eq.getAnOperand() = param.getAnAccess() and
       eq.getAnOperand().(Literal).getValue() = "0") or
      // 检查 param != NULL 模式
      (eq.getAnOperand() = param.getAnAccess() and
       eq.getAnOperand().(Literal).getValue() = "0")
    )
  ) or
  exists(NotExpr notExpr |
    notExpr = check and
    notExpr.getOperand() = param.getAnAccess()
  )
}

/**
 * 查找对参数的解引用操作
 */
predicate isParameterDereference(Expr deref, Parameter param) {
  exists(PointerFieldAccess fieldAccess |
    fieldAccess = deref and
    fieldAccess.getQualifier() = param.getAnAccess()
  ) or
  exists(PointerDereferenceExpr ptrDeref |
    ptrDeref = deref and
    ptrDeref.getOperand() = param.getAnAccess()
  ) or
  exists(ArrayExpr arrayAccess |
    arrayAccess = deref and
    arrayAccess.getArrayBase() = param.getAnAccess()
  )
}

/**
 * 检查表达式是否在控制流中位于另一个表达式之前
 */
predicate comesBefore(Expr first, Expr second) {
  exists(Function f |
    first.getEnclosingFunction() = f and
    second.getEnclosingFunction() = f and
    first.getLocation().getStartLine() < second.getLocation().getStartLine()
  )
}

from Function f, Parameter param, Expr dereference, Expr nullCheck
where
  // 参数必须是指针类型
  param.getType() instanceof PointerType and
  param.getFunction() = f and
  f.getName() = "mt7996_set_monitor" and
  
  // 找到对该参数的解引用操作
  isParameterDereference(dereference, param) and
  dereference.getEnclosingFunction() = f and
  
  // 找到对该参数的空指针检查
  isNullCheck(nullCheck, param) and
  nullCheck.getEnclosingFunction() = f and
  
  // 解引用操作发生在空指针检查之前
  comesBefore(dereference, nullCheck) and
  
  // 过滤掉一些误报：确保空指针检查在一个条件语句中
  exists(IfStmt ifStmt |
    ifStmt.getCondition().getAChild*() = nullCheck
  )

select dereference, 
       "在第" + dereference.getLocation().getStartLine() + "行对参数 '" + param.getName() + 
       "' 进行解引用，但空指针检查在第" + nullCheck.getLocation().getStartLine() + "行才进行。" +
       "这可能导致空指针解引用漏洞。"