/**
 * @name CVE-2025-38286
 * @description The function `of_alias_get_id` can return a negative value on error. This value is then
 *              used as an index into the `gpio_chips` array without being checked, leading to a
 *              potential out-of-bounds access.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/unchecked-return-value-as-array-index
 * @tags security
 *       correctness
 *       external/cwe/cwe-252
 *       external/cwe/cwe-129
 * @patch-commit 762ef7d1e6eefad9896560bfcb9bcf7f1b6df9c1
 * @source-file drivers/pinctrl/pinctrl-at91.c
 * @affected-function at91_gpio_probe
 * @kernel-config CONFIG_PINCTRL_AT91
 * @vulnerability-type out-of-bounds-access
 * @patch-diff |
 *     @@ -1822,12 +1822,16 @@ static int at91_gpio_probe(struct platform_device *pdev)
 *      	struct gpio_chip *chip;
 *      	struct pinctrl_gpio_range *range;
 *     +	int alias_idx;
 *      	int ret = 0;
 *      	int irq, i;
 *     -	int alias_idx = of_alias_get_id(np, "gpio");
 *      	uint32_t ngpio;
 *      	char **names;
 *      
 *     +	alias_idx = of_alias_get_id(np, "gpio");
 *     +	if (alias_idx < 0)
 *     +		return alias_idx;
 *     +
 *      	BUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips));
 *      	if (gpio_chips[alias_idx])
 *      		return dev_err_probe(dev, -EBUSY, "%d slot is occupied.\n", alias_idx);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38286
 * @remediation 
 */

import cpp
import semmle.code.cpp.dataflow.new.TaintTracking
import semmle.code.cpp.controlflow.Guards

/** 
 * 定义配置以跟踪 of_alias_get_id 返回值到 BUG_ON 的数据流
 */
module ArrayIndexConfig implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    exists(FunctionCall fc |
      fc.getTarget().getName() = "of_alias_get_id" and
      source.asExpr() = fc
    )
  }

  predicate isSink(DataFlow::Node sink) {
    exists(FunctionCall fc |
      fc.getTarget().getName() = "BUG_ON" and
      // BUG_ON的参数是一个小于表达式
      fc.getArgument(0).(GEExpr).getGreaterOperand() = sink.asExpr()
    )
  }

  predicate isBarrier(DataFlow::Node node) {
    // 识别对 alias_idx < 0 的检查作为有效的屏障
    exists(IfStmt ifStmt, LTExpr ltExpr |
      ifStmt.getCondition() = ltExpr and
      ltExpr.getLeftOperand().(VariableAccess).getTarget().getName() = "alias_idx" and
      ltExpr.getRightOperand().(Literal).getValue() = "0"
    )
  }
}

module ArrayIndexFlow = TaintTracking::Global<ArrayIndexConfig>;

from ArrayIndexFlow::PathNode source, ArrayIndexFlow::PathNode sink, Function f
where 
  // 限制在 at91_gpio_probe 函数内
  f.getName() = "at91_gpio_probe" and
  ArrayIndexFlow::flowPath(source, sink) and
  // 确保 source 和 sink 都在目标函数内
  source.getNode().asExpr().getEnclosingFunction() = f and
  sink.getNode().asExpr().getEnclosingFunction() = f
select source, sink,
  source.getNode(), "of_alias_get_id"