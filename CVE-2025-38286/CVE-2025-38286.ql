import cpp
import semmle.code.cpp.dataflow.new.TaintTracking
import semmle.code.cpp.controlflow.Guards

/** 
 * 定义配置以跟踪 of_alias_get_id 返回值到 BUG_ON 的数据流
 */
module ArrayIndexConfig implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    exists(FunctionCall fc |
      fc.getTarget().getName() = "of_alias_get_id" and
      source.asExpr() = fc
    )
  }

  predicate isSink(DataFlow::Node sink) {
    exists(FunctionCall fc |
      fc.getTarget().getName() = "BUG_ON" and
      // BUG_ON的参数是一个小于表达式
      fc.getArgument(0).(GEExpr).getGreaterOperand() = sink.asExpr()
    )
  }

  predicate isBarrier(DataFlow::Node node) {
    // 识别对 alias_idx < 0 的检查作为有效的屏障
    exists(IfStmt ifStmt, LTExpr ltExpr |
      ifStmt.getCondition() = ltExpr and
      ltExpr.getLeftOperand().(VariableAccess).getTarget().getName() = "alias_idx" and
      ltExpr.getRightOperand().(Literal).getValue() = "0"
    )
  }
}

module ArrayIndexFlow = TaintTracking::Global<ArrayIndexConfig>;

from ArrayIndexFlow::PathNode source, ArrayIndexFlow::PathNode sink, Function f
where 
  // 限制在 at91_gpio_probe 函数内
  f.getName() = "at91_gpio_probe" and
  ArrayIndexFlow::flowPath(source, sink) and
  // 确保 source 和 sink 都在目标函数内
  source.getNode().asExpr().getEnclosingFunction() = f and
  sink.getNode().asExpr().getEnclosingFunction() = f
select source, sink,
  source.getNode(), "of_alias_get_id"