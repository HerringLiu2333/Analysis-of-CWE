/**
 * @name CVE-2025-38281: mt7996: Missing NULL check for devm_kasprintf return value
 * @description The devm_kasprintf() function can return a NULL pointer on memory allocation failure.
 *              The returned pointer is subsequently used by thermal_cooling_device_register() without a NULL check.
 *              This can lead to a kernel NULL pointer dereference, causing a system crash and denial of service.
 * @kind path-problem
 * @problem.severity error
 * @precision high
 * @id cpp/cve-2025-38281-missing-null-check
 * @tags security
 *       correctness
 *       kernel
 *       external/cwe/cwe-476
 * @patch-commit caf4b347c5dc40fdd125793b5e82ba9fc4de5275
 * @source-file drivers/net/wireless/mediatek/mt76/mt7996/init.c
 * @affected-function mt7996_thermal_init
 * @kernel-config CONFIG_MT7996_WIFI
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *     @@ -217,6 +217,9 @@ static int mt7996_thermal_init(struct mt7996_phy *phy)
 *      
 *      	name = devm_kasprintf(&wiphy->dev, GFP_KERNEL, "mt7996_%s.%d",
 *      			      wiphy_name(wiphy), phy->mt76->band_idx);
 *     +	if (!name)
 *     +		return -ENOMEM;
 *     +
 *      	snprintf(cname, sizeof(cname), "cooling_device%d", phy->mt76->band_idx);
 *      
 *      	cdev = thermal_cooling_device_register(name, phy, &mt7996_thermal_ops);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38281
 * @remediation 
 * @patch-description |
 *     wifi: mt76: mt7996: Add NULL check in mt7996_thermal_init
 *     devm_kasprintf() can return a NULL pointer on failure,but this
 *     returned value in mt7996_thermal_init() is not checked.
 *     Add NULL check in mt7996_thermal_init(), to handle kernel NULL
 *     pointer dereference error.
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow
import semmle.code.cpp.dataflow.new.TaintTracking

/**
 * 定义 CVE-2025-38281 的数据流分析配置
 */
module Mt7996ThermalInitConfig implements DataFlow::ConfigSig {
  /**
   * 定义污点源：`devm_kasprintf` 函数的返回值，因为它在失败时可能为 NULL。
   * 我们将范围限制在漏洞所在的特定函数和文件中。
   */
  predicate isSource(DataFlow::Node source) {
    exists(FunctionCall call, Function f |
      // 源头是一个函数调用的结果
      source.asExpr() = call and
      // 该调用是对 `devm_kasprintf` 的调用
      call.getTarget().getName() = "devm_kasprintf" and
      // 该调用必须位于 `mt7996_thermal_init` 函数内部
      f = call.getEnclosingFunction() and
      f.getName() = "mt7996_thermal_init" and
      // 该函数必须位于目标文件中
      f.getFile().getRelativePath().matches("init.c")
    )
  }

  /**
   * 定义污点汇：即潜在的空指针被解引用的位置。
   * 在此漏洞中，是 `thermal_cooling_device_register` 函数的第一个参数。
   */
  predicate isSink(DataFlow::Node sink) {
    exists(FunctionCall call, Function f |
      // 汇是函数调用的第一个参数
      sink.asExpr() = call.getArgument(0) and
      // 该调用是对 `thermal_cooling_device_register` 的调用
      call.getTarget().getName() = "thermal_cooling_device_register" and
      // 该调用必须位于 `mt7996_thermal_init` 函数内部
      f = call.getEnclosingFunction() and
      f.getName() = "mt7996_thermal_init" and
      // 该函数必须位于目标文件中
      f.getFile().getRelativePath().matches("init.c")
    )
  }

  /**
   * 定义屏障 (Barrier)：即阻止污点流动的代码点，通常是安全检查。
   * 补丁中增加了 `if (!name)` 检查。这个谓词可以识别这种检查模式，
   * 从而在已修复的代码上停止数据流路径的报告。
   */
  predicate isBarrier(DataFlow::Node barrier) {
    exists(IfStmt ifstmt, NotExpr notExpr |
      // 屏障是一个 `if` 语句的条件
      ifstmt.getCondition() = notExpr and
      // 该条件的形式是 `!variable`
      barrier.asExpr() = notExpr.getOperand()
    )
  }
}

// 实例化上面定义的配置模块，用于全局污点跟踪
module Mt7996Flow = TaintTracking::Global<Mt7996ThermalInitConfig>;

// 导入专用的 PathGraph，用于后续的路径查询
import Mt7996Flow::PathGraph

// from 子句定义查询的起点和终点
from Mt7996Flow::PathNode source, Mt7996Flow::PathNode sink
// where 子句查找从源到汇的完整数据流路径
where Mt7996Flow::flowPath(source, sink)
// select 子句定义查询结果的展示格式
select sink.getNode(), source, sink,
  "The return value of 'devm_kasprintf' at " + source.getNode().getLocation().toString() +
    " may be NULL, but it is passed to " + sink.getNode().toString() + " without a check."