/**
 * @name CVE-2025-38340
 * @description An out-of-bounds read vulnerability exists in the `cs_dsp_mock_bin_add_name_or_info` KUnit test function.
 *              The code rounds up a length variable (`info_len`) for memory allocation to ensure 4-byte alignment,
 *              but then incorrectly uses this new, larger length in the subsequent `memcpy` operation. This causes
 *              `memcpy` to read past the end of the source buffer (`info`), leading to a kernel memory read error.
 *              The fix involves using the original length for the `memcpy` while still allocating the larger, rounded-up size.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/oob-read-on-rounded-up-size
 * @tags security
 *       correctness
 *       external/cwe/cwe-125
 *       external/cwe/cwe-131
 * @patch-commit fe6446215bfad11cf3b446f38b28dc7708973c25
 * @source-file drivers/firmware/cirrus/test/cs_dsp_mock_bin.c
 * @affected-function cs_dsp_mock_bin_add_name_or_info
 * @kernel-config CONFIG_FIRMWARE_CS_DSP_TEST
 * @vulnerability-type out-of-bounds-read
 * @patch-diff |
 *     @@ -96,10 +96,11 @@ static void cs_dsp_mock_bin_add_name_or_info(struct cs_dsp_mock_bin_builder *bui
 *      
 *      	if (info_len % 4) {
 *      		/* Create a padded string with length a multiple of 4 *&#47;
 *     +		size_t copy_len = info_len;
 *      		info_len = round_up(info_len, 4);
 *      		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
 *      		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
 *     -		memcpy(tmp, info, info_len);
 *     +		memcpy(tmp, info, copy_len);
 *      		info = tmp;
 *      	}
 * @references https://github.com/torvalds/linux/commit/fe6446215bfad11cf3b446f38b28dc7708973c25
 * @remediation
 */

import cpp

/**
 * 表示memcpy函数调用
 */
class MemcpyCall extends FunctionCall {
  MemcpyCall() {
    this.getTarget().getName() = "memcpy"
  }
}

from MemcpyCall memcpy, Variable lengthVar, Assignment assign
where
  // memcpy的第三个参数（长度参数）使用了某个变量
  memcpy.getArgument(2).(VariableAccess).getTarget() = lengthVar and
  
  // 这个长度变量在memcpy调用之前被赋值修改过
  assign.getLValue().(VariableAccess).getTarget() = lengthVar and
  dominates(assign.getBasicBlock(), memcpy.getBasicBlock()) and
  
  // 赋值的右边是一个函数调用或表达式（表明长度被修改了）
  (assign.getRValue() instanceof FunctionCall or
   assign.getRValue() instanceof BinaryOperation) and
  
  // 确保在同一个函数中
  assign.getEnclosingFunction() = memcpy.getEnclosingFunction()

select memcpy, "memcpy的长度参数使用了被修改的变量 '" + lengthVar.getName() + 
              "'，请检查是否应该使用原始长度以避免越界读取"