/**
 * @name CVE-2024-58010
 * @description binfmt_flat on 32-bit systems failed to validate the 'relocs' count when
 *              computing full_data = data_len + relocs * sizeof(unsigned long). Without
 *              including 'relocs' in the top-bits sanity check, the arithmetic could
 *              overflow and produce an incorrect full_data size, risking malformed parsing
 *              and potential memory-safety issues. The fix adds 'relocs' to the 28-bit
 *              cap check alongside other lengths.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/binfmt-flat-relocs-overflow-32bit
 * @tags
 *   binfmt_flat
 *   exec
 *   integer-overflow
 *   32-bit
 *   header-validation
 *   robustness
 * @patch-commit d17ca8f2dfcf423c439859995910a20e38b86f00
 * @source-file fs/binfmt_flat.c
 * @affected-function load_flat_file
 * @vulnerability-type integer-overflow
 * @patch-diff
 *   diff --git a/fs/binfmt_flat.c b/fs/binfmt_flat.c
 *   index cd6d5bbb4b9df5..3f740d8abb4fe2 100644
 *   --- a/fs/binfmt_flat.c
 *   +++ b/fs/binfmt_flat.c
 *   @@ -478,7 +478,7 @@ static int load_flat_file(struct linux_binprm *bprm,
 *           /*
 *            * 28 bits (256 MB) is way more than reasonable in this case.
 *            * If some top bits are set we have probable binary corruption.
 *           &#47;
 *   -       if ((text_len | data_len | bss_len | stack_len | full_data) >> 28) {
 *   +       if ((text_len | data_len | bss_len | stack_len | relocs | full_data) >> 28) {
 *                   pr_err("bad header\n");
 *                   ret = -ENOEXEC;
 *                   goto err;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d17ca8f2dfcf423c439859995910a20e38b86f00
 * @remediation Include 'relocs' in header sanity checks to prevent overflow when deriving
 *              full_data. Prefer using checked size helpers (e.g., size_mul/size_add) or
 *              64-bit intermediates when combining lengths and counts, and reject binaries
 *              with unreasonable top bits set (>= 28) on 32-bit systems.
 * @patch-description |
 *  binfmt_flat: Fix integer overflow bug on 32 bit systems
 *  commit 55cf2f4b945f6a6416cc2524ba740b83cc9af25a upstream.
 *  
 *  Most of these sizes and counts are capped at 256MB so the math doesn't
 *  result in an integer overflow.  The "relocs" count needs to be checked
 *  as well.  Otherwise on 32bit systems the calculation of "full_data"
 *  could be wrong.
 *
 * 	full_data = data_len + relocs * sizeof(unsigned long);
 *
 *  Fixes: c995ee28d29d ("binfmt_flat: prevent kernel dammage from corrupted executable headers")
 */



import cpp

from BinaryOperation bitwiseOr, Variable relocsVar
where
  // 查找位或操作（如 text_len | data_len | ...）
  bitwiseOr.getOperator() = "|" and
  // 检查位或操作用于边界检查（通常与移位操作一起使用）
  exists(BinaryOperation shiftOp |
    (shiftOp.getOperator() = ">>" or shiftOp.getOperator() = "<<") and
    shiftOp.getAnOperand() = bitwiseOr and
    shiftOp.toString().matches("%>> 28%") or
    shiftOp.toString().matches("%>> 32%")
  ) and
  // 查找relocs变量（在二进制文件处理中常见）
  relocsVar.getName() = "relocs" and
  // 检查relocs变量没有包含在位或操作中
  not bitwiseOr.toString().matches("%relocs%") and
  // 检查在同一函数中使用了relocs变量
  exists(Expr relocsUsage |
    relocsUsage.toString().matches("%relocs%") and
    relocsUsage.getEnclosingFunction() = bitwiseOr.getEnclosingFunction()
  )
select bitwiseOr, "Potential integer overflow vulnerability: missing 'relocs' in boundary check"