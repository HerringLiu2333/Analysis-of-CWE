/**
 * @name CVE-2025-38310
 * @description Detects improper validation of nexthop address lengths in SRv6 Netlink attributes.
 *              The kernel previously checked if the provided length was less than or equal to the expected size,
 *              allowing shorter inputs. This could lead to an out-of-bounds read from uninitialized stack memory
 *              when the kernel processes the address, potentially causing an information leak.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/improper-nexthop-validation
 * @tags security
 *       correctness
 *       net
 *       external/cwe/cwe-20
 *       external/cwe/cwe-125
 *       external/cwe/cwe-200
 * @patch-commit 7632fedb266d93ed0ed9f487133e6c6314a9b2d1
 * @source-file net/ipv6/seg6_local.c
 * @affected-function seg6_local_input
 * @kernel-config CONFIG_IPV6_SEG6_LWTUNNEL
 * @vulnerability-type improper-input-validation
 * @patch-diff |
 *     @@ -1644,10 +1644,8 @@ static const struct nla_policy seg6_local_policy[SEG6_LOCAL_MAX + 1] = {
 *      	[SEG6_LOCAL_SRH]	= { .type = NLA_BINARY },
 *      	[SEG6_LOCAL_TABLE]	= { .type = NLA_U32 },
 *      	[SEG6_LOCAL_VRFTABLE]	= { .type = NLA_U32 },
 *     -	[SEG6_LOCAL_NH4]	= { .type = NLA_BINARY,
 *     -				    .len = sizeof(struct in_addr) },
 *     -	[SEG6_LOCAL_NH6]	= { .type = NLA_BINARY,
 *     -				    .len = sizeof(struct in6_addr) },
 *     +	[SEG6_LOCAL_NH4]	= NLA_POLICY_EXACT_LEN(sizeof(struct in_addr)),
 *     +	[SEG6_LOCAL_NH6]	= NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),
 *      	[SEG6_LOCAL_IIF]	= { .type = NLA_U32 },
 *      	[SEG6_LOCAL_OIF]	= { .type = NLA_U32 },
 *      	[SEG6_LOCAL_BPF]	= { .type = NLA_NESTED },
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38310
 * @remediation
 */

import cpp

from GlobalVariable gv, Expr elem, ClassAggregateLiteral aggr, Field field, Expr value
where gv.getFile().getBaseName() = "seg6_local.c" and
      // 暂时定位在对应文件内

      gv.getName() = "seg6_local_policy" and
      (elem = gv.getInitializer().getExpr().(ArrayAggregateLiteral).getAnElementExpr(4) or
        elem = gv.getInitializer().getExpr().(ArrayAggregateLiteral).getAnElementExpr(5)) and
      // 定位到SEG6_LOCAL_NH4、SEG6_LOCAL_NH6

      aggr = elem.(ClassAggregateLiteral) and
      aggr.getAFieldExpr(field) = value and
      field.getName() = "len" and
      value instanceof SizeofTypeOperator
      // 判断len字段的值是否为sizeof类型操作符
select gv, elem, field.getName(), value