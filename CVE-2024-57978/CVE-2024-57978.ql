/**
 * @name CVE-2024-57978
 * @description media: imx-jpeg: mxc_jpeg_detach_pm_domains() could pass an ERR_PTR()
 *              to pm_runtime_suspended(), leading to an Oops. The cleanup path mixed
 *              NULL and ERR_PTR checks inconsistently. The fix uses IS_ERR_OR_NULL()
 *              for jpeg->pd_dev[i] and jpeg->pd_link[i] before invoking PM/core APIs,
 *              preventing potential error-pointer dereferences.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/imx-jpeg-detach-pm-domains-err-ptr-check
 * @tags
 *       media
 *       imx-jpeg
 *       power-management
 *       error-pointer
 *       null-dereference
 *       cleanup-path
 *       robustness
 *       external/cwe/cwe-476
 * @patch-commit fde89fe11b44500bfcb2d405825b69a5df805d19
 * @source-file drivers/media/platform/nxp/imx-jpeg/mxc-jpeg.c
 * @affected-function mxc_jpeg_detach_pm_domains
 * @vulnerability-type null-pointer-dereference / ERR_PTR dereference
 * @patch-diff |
 *     diff --git a/drivers/media/platform/nxp/imx-jpeg/mxc-jpeg.c b/drivers/media/platform/nxp/imx-jpeg/mxc-jpeg.c
 *     index 26e010f8518464..f2ecd3322d1e3d 100644
 *     --- a/drivers/media/platform/nxp/imx-jpeg/mxc-jpeg.c
 *     +++ b/drivers/media/platform/nxp/imx-jpeg/mxc-jpeg.c
 *     @@ -2097,11 +2097,12 @@ static void mxc_jpeg_detach_pm_domains(struct mxc_jpeg_dev *jpeg)
 *      	int i;
 *      
 *      	for (i = 0; i < jpeg->num_domains; i++) {
 *     -		if (jpeg->pd_dev[i] && !pm_runtime_suspended(jpeg->pd_dev[i]))
 *     +		if (!IS_ERR_OR_NULL(jpeg->pd_dev[i]) &&
 *     +		    !pm_runtime_suspended(jpeg->pd_dev[i]))
 *      			pm_runtime_force_suspend(jpeg->pd_dev[i]);
 *     -		if (jpeg->pd_link[i] && !IS_ERR(jpeg->pd_link[i]))
 *     +		if (!IS_ERR_OR_NULL(jpeg->pd_link[i]))
 *      			device_link_del(jpeg->pd_link[i]);
 *     -		if (jpeg->pd_dev[i] && !IS_ERR(jpeg->pd_dev[i]))
 *     +		if (!IS_ERR_OR_NULL(jpeg->pd_dev[i]))
 *      			dev_pm_domain_detach(jpeg->pd_dev[i], true);
 *      		jpeg->pd_dev[i] = NULL;
 *      		jpeg->pd_link[i] = NULL;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fde89fe11b44500bfcb2d405825b69a5df805d19  
 * @remediation In cleanup paths, consistently guard pointers obtained from helpers that may
 *              encode failures as ERR_PTR(). Use IS_ERR_OR_NULL() before passing such pointers
 *              to PM/device link APIs. Apply the same validation when deleting device links
 *              or detaching PM domains, and reset pointers to NULL after teardown.
 * @patch-description |
 *  media: imx-jpeg: Fix potential error pointer dereference in detach_pm()
 *  commit 1378ffec30367233152b7dbf4fa6a25ee98585d1 upstream.
 *  
 *  The proble is on the first line:
 *  
 *  	if (jpeg->pd_dev[i] && !pm_runtime_suspended(jpeg->pd_dev[i]))
 *  
 *  If jpeg->pd_dev[i] is an error pointer, then passing it to
 *  pm_runtime_suspended() will lead to an Oops.  The other conditions
 *  check for both error pointers and NULL, but it would be more clear to
 *  use the IS_ERR_OR_NULL() check for that.
 *
 *  Fixes: fd0af4cd35da ("media: imx-jpeg: Ensure power suppliers be suspended before detach them")
 */


import cpp

// 检测未修复的漏洞模式
predicate isVulnerablePattern(FunctionCall pmCall) {
  // 只检测这两个PM函数
  (pmCall.getTarget().getName() = "pm_runtime_suspended" or
   pmCall.getTarget().getName() = "pm_runtime_force_suspend") and
  
  // 参数必须是 jpeg->pd_dev[i] 模式
  exists(VariableAccess va |
    va = pmCall.getArgument(0) and
    va.toString().matches("%jpeg->pd_dev%")
  ) and
  
  // 关键：检查调用前是否有条件检查，但缺少IS_ERR_OR_NULL
  exists(Expr condition |
    // 条件中包含相同的变量
    condition.toString().matches("%jpeg->pd_dev%") and
    // 条件在函数调用之前
    condition.getLocation().getStartLine() < pmCall.getLocation().getStartLine() and
    // 在同一代码块或相近位置
    condition.getEnclosingBlock() = pmCall.getEnclosingBlock() and
    // 关键：条件中只有变量检查，没有错误检查
    not condition.toString().matches("%IS_ERR_OR_NULL%") and
    not condition.toString().matches("%IS_ERR%")
  ) and
  
  // 确保在同一范围内没有正确的错误检查
  not exists(Expr safeCheck |
    safeCheck.toString().matches("%IS_ERR_OR_NULL%") and
    safeCheck.toString().matches("%jpeg->pd_dev%") and
    safeCheck.getLocation().getStartLine() < pmCall.getLocation().getStartLine() and
    safeCheck.getEnclosingFunction() = pmCall.getEnclosingFunction()
  )
}

// 主查询
from FunctionCall pmCall
where 
  isVulnerablePattern(pmCall) and
  // 确保在mxc_jpeg_detach_pm_domains函数中
  pmCall.getEnclosingFunction().getName() = "mxc_jpeg_detach_pm_domains"
select 
  pmCall,
  "Vulnerability: " + pmCall.getTarget().getName() + 
  " called on jpeg->pd_dev[i] without IS_ERR_OR_NULL check at line " +
  pmCall.getLocation().getStartLine().toString()