/**
 * @name CVE-2025-39778
 * @description Detects an out-of-bounds read in `nvmet_ctrl_state_show` where a hardcoded loop iterates one time too many,
 *              exceeding the bounds of the `csts_state_names` array. This results in reading from an invalid stack address,
 *              potentially leading to an information leak or kernel crash.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/out-of-bounds-loop-iteration
 * @tags security
 *       correctness
 *       memory-safety
 *       external/cwe/cwe-125
 * @patch-commit 107a23185d990e3df6638d9a84c835f963fe30a6
 * @source-file drivers/nvme/target/debugfs.c
 * @affected-function nvmet_ctrl_state_show
 * @kernel-config CONFIG_NVME_TARGET CONFIG_DEBUG_FS
 * @vulnerability-type out-of-bounds-read
 * @patch-diff |
 *     @@ -78,7 +78,7 @@ static int nvmet_ctrl_state_show(struct seq_file *m, void *p)
 *      	bool sep = false;
 *      	int i;
 *      
 *     -	for (i = 0; i < 7; i++) {
 *     +	for (i = 0; i < ARRAY_SIZE(csts_state_names); i++) {
 *      		int state = BIT(i);
 *      
 *      		if (!(ctrl->csts & state))
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-39778
 * @remediation 
 * @patch-description |
 *     objtool, nvmet: Fix out-of-bounds stack access in nvmet_ctrl_state_show()
 *     The csts_state_names[] array only has six sparse entries, but the
 *     iteration code in nvmet_ctrl_state_show() iterates seven, resulting in a
 *     potential out-of-bounds stack read.  Fix that.
 *     
 *     Fixes the following warning with an UBSAN kernel:
 *     
 *       vmlinux.o: warning: objtool: .text.nvmet_ctrl_state_show: unexpected end of section
 */

import cpp

// 判断表达式是否是数组访问
predicate isArrayAccess(ArrayExpr arrayAccess, Variable array, Expr index) {
  arrayAccess.getArrayBase() = array.getAnAccess() and
  arrayAccess.getArrayOffset() = index
}

// 判断for循环是否使用硬编码常量作为边界
predicate hasHardcodedBoundary(ForStmt forLoop, int boundaryValue) {
  exists(RelationalOperation relOp, Literal boundaryLiteral |
    forLoop.getCondition() = relOp and
    relOp.getAnOperand() = boundaryLiteral and
    boundaryLiteral.getValue().toInt() = boundaryValue and
    boundaryValue > 0
  )
}

// 检查变量是否是数组类型
predicate isArrayVariable(Variable v) {
  v.getType() instanceof ArrayType
}

// 判断表达式是否使用了ARRAY_SIZE宏或类似的安全计算
predicate usesSafeArraySizeMacro(Expr expr) {
  exists(MacroInvocation macro |
    macro.getMacroName().matches("%ARRAY_SIZE%") and
    expr = macro.getExpr()
  )
  or
  exists(SizeofExprOperator sizeofExpr, DivExpr divExpr |
    divExpr.getLeftOperand() = sizeofExpr and
    expr = divExpr
  )
}

from ForStmt forLoop, ArrayExpr arrayAccess, Variable arrayVar, Variable loopVar, int hardcodedBound
where
  // 在for循环体内存在数组访问
  arrayAccess.getEnclosingStmt().getParent*() = forLoop.getStmt() and
  
  // 数组访问使用循环变量作为索引
  isArrayAccess(arrayAccess, arrayVar, loopVar.getAnAccess()) and
  
  // 确保被访问的是数组类型变量
  isArrayVariable(arrayVar) and
  
  // for循环使用硬编码边界
  hasHardcodedBoundary(forLoop, hardcodedBound) and
  
  // 循环变量在for循环的条件中被使用
  exists(VariableAccess va |
    va = loopVar.getAnAccess() and
    va.getParent*() = forLoop.getCondition()
  ) and
  
  // 排除已经使用安全宏的情况
  not exists(Expr child |
    child = forLoop.getCondition().getAChild*() and
    usesSafeArraySizeMacro(child)
  )

select forLoop, 
  "在循环中使用硬编码边界值 " + hardcodedBound + " 访问数组 '" + arrayVar.getName() + 
  "'，这可能导致数组越界读取。建议使用 ARRAY_SIZE(" + arrayVar.getName() + ") 替代硬编码常量。"