/**
 * @name CVE-2025-38257
 * @description Detects an integer overflow vulnerability when calculating buffer size for copying data from userspace. A user-controlled size value is used in a multiplication, which can wrap around, leading to the allocation of a small buffer. Subsequent access to this buffer can cause a kernel heap overflow.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/linux/kernel/integer-overflow-in-memdup-user
 * @tags security
 *       correctness
 *       integer-overflow
 *       heap-overflow
 *       external/cwe/cwe-190
 *       external/cwe/cwe-122
 * @patch-commit e04c78d86a9699d136910cfc0bdcf01087e3267e
 * @source-file drivers/s390/crypto/pkey_api.c
 * @affected-function _copy_apqns_from_user
 * @kernel-config CONFIG_ZCRYPT
 * @vulnerability-type integer-overflow
 * @patch-diff |
 *     @@ -86,7 +86,7 @@ static void *_copy_apqns_from_user(void __user *uapqns, size_t nr_apqns)
 *      	if (!uapqns || nr_apqns == 0)
 *      		return NULL;
 *      
 *     -	return memdup_user(uapqns, nr_apqns * sizeof(struct pkey_apqn));
 *     +	return memdup_array_user(uapqns, nr_apqns, sizeof(struct pkey_apqn));
 *      }
 *      
 *      static int pkey_ioctl_genseck(struct pkey_genseck __user *ugs)
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38257
 * @patch-description |
 *     s390/pkey: Prevent overflow in size calculation for memdup_user()
 *     Number of apqn target list entries contained in 'nr_apqns' variable is
 *     determined by userspace via an ioctl call so the result of the product in
 *     calculation of size passed to memdup_user() may overflow.
 *     
 *     In this case the actual size of the allocated area and the value
 *     describing it won't be in sync leading to various types of unpredictable
 *     behaviour later.
 *     
 *     Use a proper memdup_array_user() helper which returns an error if an
 *     overflow is detected. Note that it is different from when nr_apqns is
 *     initially zero - that case is considered valid and should be handled in
 *     subsequent pkey_handler implementations.
 *     
 *     Found by Linux Verification Center (linuxtesting.org).
 *     
 *     Fixes: f2bbc96e7cfa ("s390/pkey: add CCA AES cipher key support")
 */
import cpp

from FunctionCall call
where
  // 找到所有函数调用，其目标函数的名称是 "memdup_user"
  call.getTarget().getName() = "memdup_user"
select call, "Replace memdup_user with memdup_array_user"