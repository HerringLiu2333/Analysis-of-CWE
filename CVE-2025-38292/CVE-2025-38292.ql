/**
 * @name CVE-2025-38292
 * @description Detects a use-after-free vulnerability in the ath12k_dp_rx_msdu_coalesce function.
 *              The code accesses the `rxcb->is_continuation` field after the corresponding `skb`
 *              has been deallocated, which can lead to memory corruption or a system crash.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/use-after-free-in-ath12k
 * @tags security
 *       correctness
 *       memory-safety
 *       use-after-free
 *       external/cwe/cwe-416
 * @patch-commit 9f17747fbda6fca934854463873c4abf8061491d
 * @source-file drivers/net/wireless/ath/ath12k/dp_rx.c
 * @affected-function ath12k_dp_rx_msdu_coalesce
 * @kernel-config CONFIG_ATH12K
 * @vulnerability-type use-after-free
 * @patch-diff |
 *     @@ -1841,6 +1841,7 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
 *      	struct hal_rx_desc *ldesc;
 *      	int space_extra, rem_len, buf_len;
 *      	u32 hal_rx_desc_sz = ar->ab->hal.hal_desc_sz;
 *     +	bool is_continuation;
 *      
 *      	/* As the msdu is spread across multiple rx buffers,
 *      	 * find the offset to the start of msdu for computing
 *     @@ -1889,7 +1890,8 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
 *      	rem_len = msdu_len - buf_first_len;
 *      	while ((skb = __skb_dequeue(msdu_list)) != NULL && rem_len > 0) {
 *      		rxcb = ATH12K_SKB_RXCB(skb);
 *     -		if (rxcb->is_continuation)
 *     +		is_continuation = rxcb->is_continuation;
 *     +		if (is_continuation)
 *      			buf_len = DP_RX_BUFFER_SIZE - hal_rx_desc_sz;
 *      		else
 *      			buf_len = rem_len;
 *     @@ -1907,7 +1909,7 @@ static int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,
 *      		dev_kfree_skb_any(skb);
 *      
 *      		rem_len -= buf_len;
 *     -		if (!rxcb->is_continuation)
 *     +		if (!is_continuation)
 *      			break;
 *      	}
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38292
 * @remediation
 * @patch-description |
 *     wifi: ath12k: fix invalid access to memory
 *     In ath12k_dp_rx_msdu_coalesce(), rxcb is fetched from skb and boolean
 *     is_continuation is part of rxcb.
 *     Currently, after freeing the skb, the rxcb->is_continuation accessed
 *     again which is wrong since the memory is already freed.
 *     This might lead use-after-free error.
 *     
 *     Hence, fix by locally defining bool is_continuation from rxcb,
 *     so that after freeing skb, is_continuation can be used.
 *     
 *     Compile tested only.
 */

import cpp
import semmle.code.cpp.controlflow.Guards

// 释放 skb 的常见函数（可扩展）
class SkbFreeFunction extends Function {
  SkbFreeFunction() { this.getName() = "dev_kfree_skb_any" or this.getName() = "dev_kfree_skb" }
}

class SkbFreeCall extends FunctionCall { SkbFreeCall() { this.getTarget() instanceof SkbFreeFunction } }

// 访问 rxcb->is_continuation 的字段访问（rxcb 可能来源于宏展开）
class IsContinuationAccess extends PointerFieldAccess {
  IsContinuationAccess() { this.getTarget().getName() = "is_continuation" }
}

// 简单关联：rxcb 标识符包含在访问前面的文本中（避免硬编码宏）
predicate qualifierLooksLikeRxcb(Expr q) { q.toString().matches("%rxcb%") }

// 控制流：free 之后仍能到达该字段访问
predicate afterFree(SkbFreeCall free, IsContinuationAccess acc) {
  free.getBasicBlock().getASuccessor*() = acc.getBasicBlock()
}

// 同一函数内且函数为目标函数
predicate sameFunction(SkbFreeCall free, IsContinuationAccess acc, Function f) {
  free.getEnclosingFunction() = f and acc.getEnclosingFunction() = f
}

// 访问结构与被释放对象相关联（轻量启发式：都引用同一变量名 skb 作为 free 参数）
predicate relatesToFreedSkb(SkbFreeCall free, IsContinuationAccess acc) {
  exists(Variable v |
    free.getArgument(0) = v.getAnAccess() and
    acc.getEnclosingFunction() = free.getEnclosingFunction() and
    qualifierLooksLikeRxcb(acc.getQualifier())
  )
}

// 补丁后：增加局部变量 is_continuation 并只在拷贝后使用；我们筛掉这种安全模式
predicate safeCopiedPattern(IsContinuationAccess acc) {
  // 若后续使用的是赋值到一个局部变量 is_continuation 之后的分支逻辑则不报
  exists(LocalVariable lv, AssignExpr asg |
    lv.getName() = "is_continuation" and
    asg.getAnOperand() = acc and
    asg.getEnclosingFunction() = acc.getEnclosingFunction()
  )
}

from SkbFreeCall free, IsContinuationAccess acc, Function f
where
  sameFunction(free, acc, f) and
  afterFree(free, acc) and
  relatesToFreedSkb(free, acc) and
  not safeCopiedPattern(acc)
select acc, "Potential use-after-free: access to rxcb->is_continuation after skb free (pre-patch pattern)"