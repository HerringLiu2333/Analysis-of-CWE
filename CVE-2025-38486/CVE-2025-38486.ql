/**
 * @name CVE-2025-38486
 * @description Detects an out-of-bounds write in the `qcom_swrm_set_channel_map` function. The function iterates based on the user-provided `tx_num` value, which can exceed the bounds of the destination `pconfig` array. This buffer overflow leads to memory corruption and can cause a kernel panic.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/buffer-overflow
 * @tags security
 *       correctness
 *       memory-corruption
 *       external/cwe/cwe-120
 *       external/cwe/cwe-787
 * @patch-commit 834bce6a715ae9a9c4dce7892454a19adf22b013
 * @source-file drivers/soundwire/qcom.c
 * @affected-function qcom_swrm_set_channel_map
 * @kernel-config CONFIG_SOUNDWIRE_QCOM
 * @vulnerability-type buffer-overflow
 * @patch-diff |
 *     @@ -1275,26 +1270,6 @@ static void *qcom_swrm_get_sdw_stream(struct snd_soc_dai *dai, int direction)
 *      	return ctrl->sruntime[dai->id];
 *      }
 *      
 *     -static int qcom_swrm_set_channel_map(struct snd_soc_dai *dai,
 *     -				     unsigned int tx_num, const unsigned int *tx_slot,
 *     -				     unsigned int rx_num, const unsigned int *rx_slot)
 *     -{
 *     -	struct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);
 *     -	int i;
 *     -
 *     -	if (tx_slot) {
 *     -		for (i = 0; i < tx_num; i++)
 *     -			ctrl->pconfig[i].ch_mask = tx_slot[i];
 *     -	}
 *     -
 *     -	if (rx_slot) {
 *     -		for (i = 0; i < rx_num; i++)
 *     -			ctrl->pconfig[i].ch_mask = rx_slot[i];
 *     -	}
 *     -
 *     -	return 0;
 *     -}
 *     -
 *      static int qcom_swrm_startup(struct snd_pcm_substream *substream,
 *      			     struct snd_soc_dai *dai)
 *      {
 *     @@ -1331,7 +1306,6 @@ static const struct snd_soc_dai_ops qcom_swrm_pdm_dai_ops = {
 *      	.shutdown = qcom_swrm_shutdown,
 *      	.set_stream = qcom_swrm_set_sdw_stream,
 *      	.get_stream = qcom_swrm_get_sdw_stream,
 *     -	.set_channel_map = qcom_swrm_set_channel_map,
 *      };
 *      
 *      static const struct snd_soc_component_driver qcom_swrm_dai_component = {
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38486
 * @references https://lore.kernel.org/all/33fe8fe7-719a-405a-9ed2-d9f816ce1d57@sabinyo.mountain/
 * @remediation 
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow

/**
 * 表示循环中使用参数作为边界的数组访问
 */
class ParameterBoundedArrayAccess extends ArrayExpr {
  Parameter boundParam;
  ForStmt forLoop;
  Variable loopVar;
  
  ParameterBoundedArrayAccess() {
    // 在for循环内部
    forLoop.getStmt().getAChild*() = this.getEnclosingStmt() and
    
    // 循环条件中使用参数作为边界
    exists(RelationalOperation rel, VariableAccess paramAccess |
      rel = forLoop.getCondition().getAChild*() and
      paramAccess = rel.getAChild() and
      paramAccess.getTarget() = boundParam
    ) and
    
    // 循环变量用作数组索引
    exists(VariableAccess loopVarAccess |
      loopVarAccess.getTarget() = loopVar and
      this.getArrayOffset() = loopVarAccess and
      // 确保循环变量在for循环中定义或使用
      (
        forLoop.getInitialization().getAChild*().(VariableAccess).getTarget() = loopVar or
        forLoop.getCondition().getAChild*().(VariableAccess).getTarget() = loopVar
      )
    )
  }
  
  /**
   * 获取用作边界的参数
   */
  Parameter getBoundParameter() {
    result = boundParam
  }
  
  /**
   * 获取包含的for循环
   */
  ForStmt getForLoop() {
    result = forLoop
  }
}

/**
 * 检查是否存在有效的边界检查
 */
predicate lacksProperBoundsCheck(ParameterBoundedArrayAccess access) {
  // 检查循环条件是否缺乏对数组大小的检查
  not exists(RelationalOperation rel, Literal limit |
    rel = access.getForLoop().getCondition() and
    limit = rel.getAChild() and
    // 边界值应该是一个合理的数组大小常量（通常小于50）
    limit.getValue().toInt() < 50 and
    limit.getValue().toInt() > 0
  ) and
  
  // 没有在函数内进行运行时边界检查
  not exists(IfStmt ifStmt, RelationalOperation guard |
    ifStmt.getEnclosingFunction() = access.getEnclosingFunction() and
    ifStmt.getLocation().getStartLine() < access.getLocation().getStartLine() and
    guard = ifStmt.getCondition().getAChild*() and
    guard.getAChild().(VariableAccess).getTarget() = access.getBoundParameter()
  )
}

from ParameterBoundedArrayAccess access, Function f
where 
  f = access.getEnclosingFunction() and
  lacksProperBoundsCheck(access) and
  
  // 关注soundwire相关的驱动函数，特别是channel_map相关函数
  (
    f.getName().regexpMatch(".*channel.*map.*") or
    f.getName().regexpMatch(".*swrm.*") or
    f.getFile().getBaseName().regexpMatch(".*(soundwire|qcom).*")
  ) and
  
  // 数组访问使用结构体字段（如ctrl->pconfig[i]）
  exists(FieldAccess fieldAccess |
    fieldAccess = access.getArrayBase()
  )

select access, 
  "潜在的缓冲区溢出：在函数 " + f.getName() + " 中，循环使用参数 '" + 
  access.getBoundParameter().getName() + "' 作为边界访问数组，但缺乏对数组大小的边界检查。" +
  "当参数值超过数组实际大小时可能导致内存越界访问。"