/**
 * @name 数组边界检查不当导致的缓冲区溢出漏洞
 * @description 检测循环中使用外部输入作为数组索引时，缺乏边界检查可能导致缓冲区溢出的情况
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/array-bounds-check-insufficient
 * @tags security
 *       reliability
 *       external/cwe/cwe-119
 *       external/cwe/cwe-120
 *       external/cwe/cwe-787
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow

/**
 * 表示循环中使用参数作为边界的数组访问
 */
class ParameterBoundedArrayAccess extends ArrayExpr {
  Parameter boundParam;
  ForStmt forLoop;
  Variable loopVar;
  
  ParameterBoundedArrayAccess() {
    // 在for循环内部
    forLoop.getStmt().getAChild*() = this.getEnclosingStmt() and
    
    // 循环条件中使用参数作为边界
    exists(RelationalOperation rel, VariableAccess paramAccess |
      rel = forLoop.getCondition().getAChild*() and
      paramAccess = rel.getAChild() and
      paramAccess.getTarget() = boundParam
    ) and
    
    // 循环变量用作数组索引
    exists(VariableAccess loopVarAccess |
      loopVarAccess.getTarget() = loopVar and
      this.getArrayOffset() = loopVarAccess and
      // 确保循环变量在for循环中定义或使用
      (
        forLoop.getInitialization().getAChild*().(VariableAccess).getTarget() = loopVar or
        forLoop.getCondition().getAChild*().(VariableAccess).getTarget() = loopVar
      )
    )
  }
  
  /**
   * 获取用作边界的参数
   */
  Parameter getBoundParameter() {
    result = boundParam
  }
  
  /**
   * 获取包含的for循环
   */
  ForStmt getForLoop() {
    result = forLoop
  }
}

/**
 * 检查是否存在有效的边界检查
 */
predicate lacksProperBoundsCheck(ParameterBoundedArrayAccess access) {
  // 检查循环条件是否缺乏对数组大小的检查
  not exists(RelationalOperation rel, Literal limit |
    rel = access.getForLoop().getCondition() and
    limit = rel.getAChild() and
    // 边界值应该是一个合理的数组大小常量（通常小于50）
    limit.getValue().toInt() < 50 and
    limit.getValue().toInt() > 0
  ) and
  
  // 没有在函数内进行运行时边界检查
  not exists(IfStmt ifStmt, RelationalOperation guard |
    ifStmt.getEnclosingFunction() = access.getEnclosingFunction() and
    ifStmt.getLocation().getStartLine() < access.getLocation().getStartLine() and
    guard = ifStmt.getCondition().getAChild*() and
    guard.getAChild().(VariableAccess).getTarget() = access.getBoundParameter()
  )
}

from ParameterBoundedArrayAccess access, Function f
where 
  f = access.getEnclosingFunction() and
  lacksProperBoundsCheck(access) and
  
  // 关注soundwire相关的驱动函数，特别是channel_map相关函数
  (
    f.getName().regexpMatch(".*channel.*map.*") or
    f.getName().regexpMatch(".*swrm.*") or
    f.getFile().getBaseName().regexpMatch(".*(soundwire|qcom).*")
  ) and
  
  // 数组访问使用结构体字段（如ctrl->pconfig[i]）
  exists(FieldAccess fieldAccess |
    fieldAccess = access.getArrayBase()
  )

select access, 
  "潜在的缓冲区溢出：在函数 " + f.getName() + " 中，循环使用参数 '" + 
  access.getBoundParameter().getName() + "' 作为边界访问数组，但缺乏对数组大小的边界检查。" +
  "当参数值超过数组实际大小时可能导致内存越界访问。"