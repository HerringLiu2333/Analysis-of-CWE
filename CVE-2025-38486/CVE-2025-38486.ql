/**
 * @name CVE-2025-38486
 * @description Detects an out-of-bounds write in the `qcom_swrm_set_channel_map` function. The function iterates based on the user-provided `tx_num` value, which can exceed the bounds of the destination `pconfig` array. This buffer overflow leads to memory corruption and can cause a kernel panic.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/buffer-overflow
 * @tags security
 *       correctness
 *       memory-corruption
 *       external/cwe/cwe-120
 *       external/cwe/cwe-787
 * @patch-commit 834bce6a715ae9a9c4dce7892454a19adf22b013
 * @source-file drivers/soundwire/qcom.c
 * @affected-function qcom_swrm_set_channel_map
 * @kernel-config CONFIG_SOUNDWIRE_QCOM
 * @vulnerability-type buffer-overflow
 * @patch-diff |
 *     @@ -1275,26 +1270,6 @@ static void *qcom_swrm_get_sdw_stream(struct snd_soc_dai *dai, int direction)
 *      	return ctrl->sruntime[dai->id];
 *      }
 *      
 *     -static int qcom_swrm_set_channel_map(struct snd_soc_dai *dai,
 *     -				     unsigned int tx_num, const unsigned int *tx_slot,
 *     -				     unsigned int rx_num, const unsigned int *rx_slot)
 *     -{
 *     -	struct qcom_swrm_ctrl *ctrl = dev_get_drvdata(dai->dev);
 *     -	int i;
 *     -
 *     -	if (tx_slot) {
 *     -		for (i = 0; i < tx_num; i++)
 *     -			ctrl->pconfig[i].ch_mask = tx_slot[i];
 *     -	}
 *     -
 *     -	if (rx_slot) {
 *     -		for (i = 0; i < rx_num; i++)
 *     -			ctrl->pconfig[i].ch_mask = rx_slot[i];
 *     -	}
 *     -
 *     -	return 0;
 *     -}
 *     -
 *      static int qcom_swrm_startup(struct snd_pcm_substream *substream,
 *      			     struct snd_soc_dai *dai)
 *      {
 *     @@ -1331,7 +1306,6 @@ static const struct snd_soc_dai_ops qcom_swrm_pdm_dai_ops = {
 *      	.shutdown = qcom_swrm_shutdown,
 *      	.set_stream = qcom_swrm_set_sdw_stream,
 *      	.get_stream = qcom_swrm_get_sdw_stream,
 *     -	.set_channel_map = qcom_swrm_set_channel_map,
 *      };
 *      
 *      static const struct snd_soc_component_driver qcom_swrm_dai_component = {
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38486
 * @references https://lore.kernel.org/all/33fe8fe7-719a-405a-9ed2-d9f816ce1d57@sabinyo.mountain/
 * @remediation 
 * @patch-description |
 *     soundwire: Revert "soundwire: qcom: Add set_channel_map api support"
 *     This reverts commit 7796c97df6b1b2206681a07f3c80f6023a6593d5.
 *     
 *     This patch broke Dragonboard 845c (sdm845). I see:
 *     
 *         Unexpected kernel BRK exception at EL1
 *         Internal error: BRK handler: 00000000f20003e8 [#1]  SMP
 *         pc : qcom_swrm_set_channel_map+0x7c/0x80 [soundwire_qcom]
 *         lr : snd_soc_dai_set_channel_map+0x34/0x78
 *         Call trace:
 *          qcom_swrm_set_channel_map+0x7c/0x80 [soundwire_qcom] (P)
 *          sdm845_dai_init+0x18c/0x2e0 [snd_soc_sdm845]
 *          snd_soc_link_init+0x28/0x6c
 *          snd_soc_bind_card+0x5f4/0xb0c
 *          snd_soc_register_card+0x148/0x1a4
 *          devm_snd_soc_register_card+0x50/0xb0
 *          sdm845_snd_platform_probe+0x124/0x148 [snd_soc_sdm845]
 *          platform_probe+0x6c/0xd0
 *          really_probe+0xc0/0x2a4
 *          __driver_probe_device+0x7c/0x130
 *          driver_probe_device+0x40/0x118
 *          __device_attach_driver+0xc4/0x108
 *          bus_for_each_drv+0x8c/0xf0
 *          __device_attach+0xa4/0x198
 *          device_initial_probe+0x18/0x28
 *          bus_probe_device+0xb8/0xbc
 *          deferred_probe_work_func+0xac/0xfc
 *          process_one_work+0x244/0x658
 *          worker_thread+0x1b4/0x360
 *          kthread+0x148/0x228
 *          ret_from_fork+0x10/0x20
 *         Kernel panic - not syncing: BRK handler: Fatal exception
 *     
 *     Dan has also reported following issues with the original patch
 *     https://lore.kernel.org/all/33fe8fe7-719a-405a-9ed2-d9f816ce1d57@sabinyo.mountain/
 *     
 *     Bug #1:
 *     The zeroeth element of ctrl->pconfig[] is supposed to be unused.  We
 *     start counting at 1.  However this code sets ctrl->pconfig[0].ch_mask = 128.
 *     
 *     Bug #2:
 *     There are SLIM_MAX_TX_PORTS (16) elements in tx_ch[] array but only
 *     QCOM_SDW_MAX_PORTS + 1 (15) in the ctrl->pconfig[] array so it corrupts
 *     memory like Yongqin Liu pointed out.
 *     
 *     Bug 3:
 *     Like Jie Gan pointed out, it erases all the tx information with the rx
 *     information.
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow

/**
 * 表示循环中使用参数作为边界的数组访问
 */
class ParameterBoundedArrayAccess extends ArrayExpr {
  Parameter boundParam;
  ForStmt forLoop;
  Variable loopVar;
  
  ParameterBoundedArrayAccess() {
    // 在for循环内部
    forLoop.getStmt().getAChild*() = this.getEnclosingStmt() and
    
    // 循环条件中使用参数作为边界
    exists(RelationalOperation rel, VariableAccess paramAccess |
      rel = forLoop.getCondition().getAChild*() and
      paramAccess = rel.getAChild() and
      paramAccess.getTarget() = boundParam
    ) and
    
    // 循环变量用作数组索引
    exists(VariableAccess loopVarAccess |
      loopVarAccess.getTarget() = loopVar and
      this.getArrayOffset() = loopVarAccess and
      // 确保循环变量在for循环中定义或使用
      (
        forLoop.getInitialization().getAChild*().(VariableAccess).getTarget() = loopVar or
        forLoop.getCondition().getAChild*().(VariableAccess).getTarget() = loopVar
      )
    )
  }
  
  /**
   * 获取用作边界的参数
   */
  Parameter getBoundParameter() {
    result = boundParam
  }
  
  /**
   * 获取包含的for循环
   */
  ForStmt getForLoop() {
    result = forLoop
  }
}

/**
 * 检查是否存在有效的边界检查
 */
predicate lacksProperBoundsCheck(ParameterBoundedArrayAccess access) {
  // 检查循环条件是否缺乏对数组大小的检查
  not exists(RelationalOperation rel, Literal limit |
    rel = access.getForLoop().getCondition() and
    limit = rel.getAChild() and
    // 边界值应该是一个合理的数组大小常量（通常小于50）
    limit.getValue().toInt() < 50 and
    limit.getValue().toInt() > 0
  ) and
  
  // 没有在函数内进行运行时边界检查
  not exists(IfStmt ifStmt, RelationalOperation guard |
    ifStmt.getEnclosingFunction() = access.getEnclosingFunction() and
    ifStmt.getLocation().getStartLine() < access.getLocation().getStartLine() and
    guard = ifStmt.getCondition().getAChild*() and
    guard.getAChild().(VariableAccess).getTarget() = access.getBoundParameter()
  )
}

from ParameterBoundedArrayAccess access, Function f
where 
  f = access.getEnclosingFunction() and
  lacksProperBoundsCheck(access) and
  
  // 关注soundwire相关的驱动函数，特别是channel_map相关函数
  (
    f.getName().regexpMatch(".*channel.*map.*") or
    f.getName().regexpMatch(".*swrm.*") or
    f.getFile().getBaseName().regexpMatch(".*(soundwire|qcom).*")
  ) and
  
  // 数组访问使用结构体字段（如ctrl->pconfig[i]）
  exists(FieldAccess fieldAccess |
    fieldAccess = access.getArrayBase()
  )

select access, 
  "潜在的缓冲区溢出：在函数 " + f.getName() + " 中，循环使用参数 '" + 
  access.getBoundParameter().getName() + "' 作为边界访问数组，但缺乏对数组大小的边界检查。" +
  "当参数值超过数组实际大小时可能导致内存越界访问。"