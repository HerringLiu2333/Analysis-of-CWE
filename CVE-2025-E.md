# CVE-2025

## CVE-2025-38350

### Description

In the Linux kernel, the following vulnerability has been resolved: net/sched: Always pass notifications when child class becomes empty Certain classful qdiscs may invoke their classes' dequeue handler on an enqueue operation. This may unexpectedly empty the child qdisc and thus make an in-flight class passive via qlen_notify(). Most qdiscs do not expect such behaviour at this point in time and may re-activate the class eventually anyways which will lead to a use-after-free. The referenced fix commit attempted to fix this behavior for the HFSC case by moving the backlog accounting around, though this turned out to be incomplete since the parent's parent may run into the issue too. The following reproducer demonstrates this use-after-free: tc qdisc add dev lo root handle 1: drr tc filter add dev lo parent 1: basic classid 1:1 tc class add dev lo parent 1: classid 1:1 drr tc qdisc add dev lo parent 1:1 handle 2: hfsc def 1 tc class add dev lo parent 2: classid 2:1 hfsc rt m1 8 d 1 m2 0 tc qdisc add dev lo parent 2:1 handle 3: netem tc qdisc add dev lo parent 3:1 handle 4: blackhole echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888 tc class delete dev lo classid 1:1 echo 1 | socat -u STDIN UDP4-DATAGRAM:127.0.0.1:8888 Since backlog accounting issues leading to a use-after-frees on stale class pointers is a recurring pattern at this point, this patch takes a different approach. Instead of trying to fix the accounting, the patch ensures that qdisc_tree_reduce_backlog always calls qlen_notify when the child qdisc is empty. This solves the problem because deletion of qdiscs always involves a call to qdisc_reset() and / or qdisc_purge_queue() which ultimately resets its qlen to 0 thus causing the following qdisc_tree_reduce_backlog() to report to the parent. Note that this may call qlen_notify on passive classes multiple times. This is not a problem after the recent patch series that made all the classful qdiscs qlen_notify() handlers idempotent.

**释放后使用 (Use-After-Free, UAF)**

该漏洞存在于Linux内核的网络调度子系统 (net/sched) 中，特别是在处理复杂的队列规则（qdiscs）时。

漏洞的触发逻辑如下：

1. 系统配置了嵌套的队列规则（qdisc），比如一个drr队列下有一个hfsc队列。
2. 当一个数据包进入父队列时（enqueue操作），这个操作会意外地触发其子队列的清空（dequeue操作）。
3. 子队列被清空后，其对应的“类”（class）会因为没有待处理的数据包而被标记为“被动”（passive），并可能被系统释放其占用的内存。
4. 然而，父队列的内部状态（称为“backlog accounting”）没有被正确或及时地更新，它仍然持有一个指向那个已经被释放的子类内存的指针（即“stale class pointer”）。
5. 当后续有网络操作尝试再次激活或使用这个子类时，父队列就会通过这个悬垂指针去访问一块已经被释放、甚至可能被重新分配用于其他目的的内存。这就构成了“释放后使用”。

简单来说，这是一个**状态同步问题**导致的内存生命周期管理错误。父级组件没有意识到其子级组件已经被释放，从而导致了对无效内存的访问。

## CVE-2025-38349

### Description

In the Linux kernel, the following vulnerability has been resolved: eventpoll: don't decrement ep refcount while still holding the ep mutex Jann Horn points out that epoll is decrementing the ep refcount and then doing a mutex_unlock(&ep->mtx); afterwards. That's very wrong, because it can lead to a use-after-free. That pattern is actually fine for the very last reference, because the code in question will delay the actual call to "ep_free(ep)" until after it has unlocked the mutex. But it's wrong for the much subtler "next to last" case when somebody *else* may also be dropping their reference and free the ep while we're still using the mutex. Note that this is true even if that other user is also using the same ep mutex: mutexes, unlike spinlocks, can not be used for object ownership, even if they guarantee mutual exclusion. A mutex "unlock" operation is not atomic, and as one user is still accessing the mutex as part of unlocking it, another user can come in and get the now released mutex and free the data structure while the first user is still cleaning up. See our mutex documentation in Documentation/locking/mutex-design.rst, in particular the section [1] about semantics: "mutex_unlock() may access the mutex structure even after it has internally released the lock already - so it's not safe for another context to acquire the mutex and assume that the mutex_unlock() context is not using the structure anymore" So if we drop our ep ref before the mutex unlock, but we weren't the last one, we may then unlock the mutex, another user comes in, drops _their_ reference and releases the 'ep' as it now has no users - all while the mutex_unlock() is still accessing it. Fix this by simply moving the ep refcount dropping to outside the mutex: the refcount itself is atomic, and doesn't need mutex protection (that's the whole _point_ of refcounts: unlike mutexes, they are inherently about object lifetimes).

**释放后使用 (Use-After-Free, UAF)**，由**竞态条件 (Race Condition)** 引发。

1. **线程A**持有锁，完成工作，然后将ep的引用计数从2减到1。
2. **线程A**开始执行mutex_unlock()。如描述中所述，mutex_unlock()本身不是一个原子操作，它可能在内部释放了锁之后，仍然需要访问锁结构本身来完成清理。
3. 就在这个极小的时间窗口内，**线程B**可以立即获取到刚刚被内部释放的锁。
4. **线程B**完成自己的工作，然后将ep的引用计数从1减到0。
5. 因为引用计数为0，**线程B**会立即释放整个ep对象占用的内存，包括那个互斥锁ep->mtx。
6. 此时，**线程A**的mutex_unlock()函数可能还未执行完毕，它会继续访问已经被线程B释放掉的ep->mtx内存。这就构成了**释放后使用 (Use-After-Free)**。

## CVE-2025-38346

### Description

In the Linux kernel, the following vulnerability has been resolved: ftrace: Fix UAF when lookup kallsym after ftrace disabled The following issue happens with a buggy module: BUG: unable to handle page fault for address: ffffffffc05d0218 PGD 1bd66f067 P4D 1bd66f067 PUD 1bd671067 PMD 101808067 PTE 0 Oops: Oops: 0000 [#1] SMP KASAN PTI Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS RIP: 0010:sized_strscpy+0x81/0x2f0 RSP: 0018:ffff88812d76fa08 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffffffffc0601010 RCX: dffffc0000000000 RDX: 0000000000000038 RSI: dffffc0000000000 RDI: ffff88812608da2d RBP: 8080808080808080 R08: ffff88812608da2d R09: ffff88812608da68 R10: ffff88812608d82d R11: ffff88812608d810 R12: 0000000000000038 R13: ffff88812608da2d R14: ffffffffc05d0218 R15: fefefefefefefeff FS: 00007fef552de740(0000) GS:ffff8884251c7000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffffffc05d0218 CR3: 00000001146f0000 CR4: 00000000000006f0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Call Trace: <TASK> ftrace_mod_get_kallsym+0x1ac/0x590 update_iter_mod+0x239/0x5b0 s_next+0x5b/0xa0 seq_read_iter+0x8c9/0x1070 seq_read+0x249/0x3b0 proc_reg_read+0x1b0/0x280 vfs_read+0x17f/0x920 ksys_read+0xf3/0x1c0 do_syscall_64+0x5f/0x2e0 entry_SYSCALL_64_after_hwframe+0x76/0x7e The above issue may happen as follows: (1) Add kprobe tracepoint; (2) insmod test.ko; (3) Module triggers ftrace disabled; (4) rmmod test.ko; (5) cat /proc/kallsyms; --> Will trigger UAF as test.ko already removed; ftrace_mod_get_kallsym() ... strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN); ... The problem is when a module triggers an issue with ftrace and sets ftrace_disable. The ftrace_disable is set when an anomaly is discovered and to prevent any more damage, ftrace stops all text modification. The issue that happened was that the ftrace_disable stops more than just the text modification. When a module is loaded, its init functions can also be traced. Because kallsyms deletes the init functions after a module has loaded, ftrace saves them when the module is loaded and function tracing is enabled. This allows the output of the function trace to show the init function names instead of just their raw memory addresses. When a module is removed, ftrace_release_mod() is called, and if ftrace_disable is set, it just returns without doing anything more. The problem here is that it leaves the mod_list still around and if kallsyms is called, it will call into this code and access the module memory that has already been freed as it will return: strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN); Where the "mod" no longer exists and triggers a UAF bug.

**Use-After-Free（释放后使用）**

漏洞根本原因在于 ftrace 未能在模块卸载时正确移除引用，导致内核在 `/proc/kallsyms` 中访问已经释放的模块结构体。触发路径明确，堆栈中也清晰显示了 `strscpy()` 读取已失效指针的数据，完全符合 UAF 模式。

## CVE-2025-38342

### Description

In the Linux kernel, the following vulnerability has been resolved: software node: Correct a OOB check in software_node_get_reference_args() software_node_get_reference_args() wants to get @index-th element, so the property value requires at least '(index + 1) * sizeof(*ref)' bytes but that can not be guaranteed by current OOB check, and may cause OOB for malformed property. Fix by using as OOB check '((index + 1) * sizeof(*ref) > prop->length)'.

**Out-of-Bound（越界访问）**

该漏洞是典型的越界访问，并且是越界读取（Out-of-Bounds Read）。

- **明确的证据**：漏洞描述中多次使用了缩写 "**OOB**"，即"Out-of-Bound"（越界）。
- **问题分析**：函数 software_node_get_reference_args() 试图访问一个数据属性（property）中的第 index 个元素。为了安全地做到这一点，它必须首先检查该属性的缓冲区（由 prop->length 定义大小）是否足够大，能够容纳到第 index 个元素为止的所有数据。
- **漏洞所在**：原有的边界检查（OOB check）逻辑是错误的。它不能保证在访问 index 处的数据时，不会超出缓冲区的实际边界。
- **后果**：一个恶意的、构造好的（"malformed"）属性，即使其缓冲区很小，也可能通过这个有缺陷的检查，导致代码尝试从缓冲区末端之外的内存地址读取数据。这正是**越界访问**的定义。它属于更广义的 Out-of-Bound，而不是特指写入的 Buffer-Overflow。

## CVE-2025-38341

### Description

In the Linux kernel, the following vulnerability has been resolved: eth: fbnic: avoid double free when failing to DMA-map FW msg The semantics are that caller of fbnic_mbx_map_msg() retains the ownership of the message on error. All existing callers dutifully free the page.

**双重释放 (Double Free)**

该漏洞存在于Linux内核的fbnic以太网驱动程序中。问题的核心在于对内存所有权和错误处理路径的误解。

在C语言等手动管理内存的编程中，一个常见的约定（或“语义”）是，当一个函数失败时，由**调用方（caller）**负责释放它之前分配并传入的内存。而被调用的函数（callee）不应该在出错时去释放它不拥有的内存。

漏洞的触发流程如下：

1. 一个调用方函数分配了一块内存（一个页面）用于固件消息。
2. 它将这块内存传递给fbnic_mbx_map_msg()函数，试图将其映射到DMA（直接内存访问）区域。
3. **DMA映射操作失败**，fbnic_mbx_map_msg()进入其错误处理路径。
4. **漏洞所在**：在错误处理路径中，fbnic_mbx_map_msg()函数**错误地释放了它接收到的内存页面**。这是第一次释放。
5. fbnic_mbx_map_msg()向上层调用方返回一个错误码。
6. 调用方函数接收到错误码后，按照既定的规则（“retains the ownership of the message on error”），也去**释放它最初分配的那个内存页面**。这是第二次释放。

## CVE-2025-38340

### Description

In the Linux kernel, the following vulnerability has been resolved: firmware: cs_dsp: Fix OOB memory read access in KUnit test KASAN reported out of bounds access - cs_dsp_mock_bin_add_name_or_info(), because the source string length was rounded up to the allocation size.

**越界读取 (Out-of-Bounds Read)**

该漏洞存在于Linux内核的cs_dsp（Cirrus Logic DSP）固件加载器组件中，但它有一个非常重要的前提：漏洞代码位于**KUnit测试框架**内，具体在cs_dsp_mock_bin_add_name_or_info()函数中。

漏洞的根本原因是**不正确的长度计算**：

1. 测试代码在处理一个字符串时，为了分配内存，会将字符串的实际长度**向上取整**到一个更大的值（例如，对齐到4或8字节）。
2. 然而，在后续从源字符串进行读取/拷贝操作时，代码错误地使用了这个**被放大的、向上取整后的长度**，而不是源字符串的**实际长度**。
3. 这导致代码试图读取超出源字符串缓冲区边界的内存，从而触发了由KASAN（内核地址消毒器）检测到的越界读取。

## CVE-2025-38339

### Description

In the Linux kernel, the following vulnerability has been resolved: powerpc/bpf: fix JIT code size calculation of bpf trampoline arch_bpf_trampoline_size() provides JIT size of the BPF trampoline before the buffer for JIT'ing it is allocated. The total number of instructions emitted for BPF trampoline JIT code depends on where the final image is located. So, the size arrived at with the dummy pass in arch_bpf_trampoline_size() can vary from the actual size needed in arch_prepare_bpf_trampoline(). When the instructions accounted in arch_bpf_trampoline_size() is less than the number of instructions emitted during the actual JIT compile of the trampoline, the below warning is produced: WARNING: CPU: 8 PID: 204190 at arch/powerpc/net/bpf_jit_comp.c:981 __arch_prepare_bpf_trampoline.isra.0+0xd2c/0xdcc which is: /* Make sure the trampoline generation logic doesn't overflow */ if (image && WARN_ON_ONCE(&image[ctx->idx] > (u32 *)rw_image_end - BPF_INSN_SAFETY)) { So, during the dummy pass, instead of providing some arbitrary image location, account for maximum possible instructions if and when there is a dependency with image location for JIT'ing.

**Buffer-Overflow（缓冲区溢出）**

这是一个典型的因计算错误导致的缓冲区溢出风险。

- **问题流程**:
  1. 一个函数 (arch_bpf_trampoline_size) 预先计算生成一段JIT代码所需要的缓冲区大小。
  2. 这个计算逻辑存在缺陷，导致计算出的大小可能比实际需要的小。
  3. 系统根据这个偏小的尺寸分配了一个缓冲区。
  4. 随后的JIT编译过程 (arch_prepare_bpf_trampoline) 开始向这个缓冲区写入编译好的机器码。
- **漏洞体现**: 由于缓冲区大小不足，写入操作最终会超出缓冲区的边界。描述中引用的警告代码 if (image && WARN_ON_ONCE(&image[ctx->idx] > (u32 *)rw_image_end ...)) 和注释 /* Make sure the trampoline generation logic doesn't overflow */ 都明确地表明，这是一个为了防止**缓冲区溢出**而设置的检查。当写入指针 &image[ctx->idx] 越过了缓冲区的末端 rw_image_end 时，这个警告就会被触发。

## CVE-2025-38337

### Description

In the Linux kernel, the following vulnerability has been resolved: jbd2: fix data-race and null-ptr-deref in jbd2_journal_dirty_metadata() Since handle->h_transaction may be a NULL pointer, so we should change it to call is_handle_aborted(handle) first before dereferencing it. And the following data-race was reported in my fuzzer: ================================================================== BUG: KCSAN: data-race in jbd2_journal_dirty_metadata / jbd2_journal_dirty_metadata write to 0xffff888011024104 of 4 bytes by task 10881 on cpu 1: jbd2_journal_dirty_metadata+0x2a5/0x770 fs/jbd2/transaction.c:1556 __ext4_handle_dirty_metadata+0xe7/0x4b0 fs/ext4/ext4_jbd2.c:358 ext4_do_update_inode fs/ext4/inode.c:5220 [inline] ext4_mark_iloc_dirty+0x32c/0xd50 fs/ext4/inode.c:5869 __ext4_mark_inode_dirty+0xe1/0x450 fs/ext4/inode.c:6074 ext4_dirty_inode+0x98/0xc0 fs/ext4/inode.c:6103 .... read to 0xffff888011024104 of 4 bytes by task 10880 on cpu 0: jbd2_journal_dirty_metadata+0xf2/0x770 fs/jbd2/transaction.c:1512 __ext4_handle_dirty_metadata+0xe7/0x4b0 fs/ext4/ext4_jbd2.c:358 ext4_do_update_inode fs/ext4/inode.c:5220 [inline] ext4_mark_iloc_dirty+0x32c/0xd50 fs/ext4/inode.c:5869 __ext4_mark_inode_dirty+0xe1/0x450 fs/ext4/inode.c:6074 ext4_dirty_inode+0x98/0xc0 fs/ext4/inode.c:6103 .... value changed: 0x00000000 -> 0x00000001 ================================================================== This issue is caused by missing data-race annotation for jh->b_modified. Therefore, the missing annotation needs to be added.

**空指针解引用 (NULL Pointer Dereference)**

在jbd2_journal_dirty_metadata()函数中，代码会访问一个句柄（handle）中的事务指针（handle->h_transaction）。然而，在某些情况下，这个h_transaction指针可能是NULL。代码在访问它之前没有进行必要的检查，如果直接解引用一个NULL指针，内核会立即崩溃。

KCSAN（内核并发消毒器）的模糊测试报告显示，jbd2_journal_dirty_metadata()函数中存在数据竞争。具体来说，两个不同的CPU核心上的任务（线程）在**没有适当加锁**的情况下，同时对同一个内存地址（jh->b_modified）进行访问，其中一个在读，另一个在写。

jh->b_modified很可能是一个标志位，用于标记某个日志缓冲区是否被修改过。由于没有使用原子操作或锁来保护这次访问，操作的顺序和结果是不可预测的。这可能导致：

- 一个线程读取到过时的数据（例如，它读取到“未修改”，而另一个线程刚刚把它标记为“已修改”）。
- 一个线程的写入操作被另一个线程的写入覆盖。

## CVE-2025-38330

### Description

In the Linux kernel, the following vulnerability has been resolved: firmware: cs_dsp: Fix OOB memory read access in KUnit test (ctl cache) KASAN reported out of bounds access - cs_dsp_ctl_cache_init_multiple_offsets(). The code uses mock_coeff_template.length_bytes (4 bytes) for register value allocations. But later, this length is set to 8 bytes which causes test code failures. As fix, just remove the lenght override, keeping the original value 4 for all operations.

**越界读取 (Out-of-Bounds Read)**

该漏洞存在于Linux内核的cs_dsp（Cirrus Logic DSP）固件加载器组件中，并且和前一个案例一样，它**仅存在于KUnit测试代码**中，具体位于cs_dsp_ctl_cache_init_multiple_offsets()函数。

漏洞的根本原因是**变量状态的不当修改**，导致长度不匹配：

1. **初始分配**：测试代码首先根据一个初始长度（mock_coeff_template.length_bytes，值为4字节）分配了内存缓冲区，用于存储寄存器值。
2. **错误的状态变更**：在后续的代码中，这个用于记录长度的变量被错误地**覆盖并修改为了一个更大的值（8字节）**。
3. **越界访问**：当测试代码稍后使用这个被修改过的、不正确的长度（8字节）来从那个实际上只有4字节大小的缓冲区中读取数据时，就发生了越界读取。代码读完缓冲区内的4个字节后，会继续读取其后相邻的4个字节的未知内存。

## CVE-2025-38329

### Description

In the Linux kernel, the following vulnerability has been resolved: firmware: cs_dsp: Fix OOB memory read access in KUnit test (wmfw info) KASAN reported out of bounds access - cs_dsp_mock_wmfw_add_info(), because the source string length was rounded up to the allocation size.

**越界读取 (Out-of-Bounds Read)**

该漏洞存在于Linux内核的cs_dsp（Cirrus Logic DSP）固件加载器组件中，并且与前两个案例一样，它**仅存在于KUnit测试代码**中，具体位于cs_dsp_mock_wmfw_add_info()函数。

漏洞的根本原因是**不正确的长度计算**，这与我们之前分析的CVE-2025-38340几乎是同一个模式：

1. **分配与源不匹配**：测试代码在处理一个源字符串时，为其分配内存。
2. **错误地使用分配大小**：在后续从源字符串进行读取/拷贝操作时，代码错误地使用了根据分配大小**向上取整后**的长度，而不是源字符串的**实际长度**。
3. **越界访问**：这导致代码在读取完源字符串的有效内容和其结尾的空字符后，继续读取超出其缓冲区边界的相邻内存，从而触发了由KASAN（内核地址消毒器）检测到的越界读取。

## CVE-2025-38323

### Description

In the Linux kernel, the following vulnerability has been resolved: net: atm: add lec_mutex syzbot found its way in net/atm/lec.c, and found an error path in lecd_attach() could leave a dangling pointer in dev_lec[]. Add a mutex to protect dev_lecp[] uses from lecd_attach(), lec_vcc_attach() and lec_mcast_attach(). Following patch will use this mutex for /proc/net/atm/lec. BUG: KASAN: slab-use-after-free in lecd_attach net/atm/lec.c:751 [inline] BUG: KASAN: slab-use-after-free in lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008 Read of size 8 at addr ffff88807c7b8e68 by task syz.1.17/6142 CPU: 1 UID: 0 PID: 6142 Comm: syz.1.17 Not tainted 6.16.0-rc1-syzkaller-00239-g08215f5486ec #0 PREEMPT(full) Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025 Call Trace: <TASK> __dump_stack lib/dump_stack.c:94 [inline] dump_stack_lvl+0x116/0x1f0 lib/dump_stack.c:120 print_address_description mm/kasan/report.c:408 [inline] print_report+0xcd/0x680 mm/kasan/report.c:521 kasan_report+0xe0/0x110 mm/kasan/report.c:634 lecd_attach net/atm/lec.c:751 [inline] lane_ioctl+0x2224/0x23e0 net/atm/lec.c:1008 do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159 sock_do_ioctl+0x118/0x280 net/socket.c:1190 sock_ioctl+0x227/0x6b0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f </TASK> Allocated by task 6132: kasan_save_stack+0x33/0x60 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 poison_kmalloc_redzone mm/kasan/common.c:377 [inline] __kasan_kmalloc+0xaa/0xb0 mm/kasan/common.c:394 kasan_kmalloc include/linux/kasan.h:260 [inline] __do_kmalloc_node mm/slub.c:4328 [inline] __kvmalloc_node_noprof+0x27b/0x620 mm/slub.c:5015 alloc_netdev_mqs+0xd2/0x1570 net/core/dev.c:11711 lecd_attach net/atm/lec.c:737 [inline] lane_ioctl+0x17db/0x23e0 net/atm/lec.c:1008 do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159 sock_do_ioctl+0x118/0x280 net/socket.c:1190 sock_ioctl+0x227/0x6b0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893 do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline] do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94 entry_SYSCALL_64_after_hwframe+0x77/0x7f Freed by task 6132: kasan_save_stack+0x33/0x60 mm/kasan/common.c:47 kasan_save_track+0x14/0x30 mm/kasan/common.c:68 kasan_save_free_info+0x3b/0x60 mm/kasan/generic.c:576 poison_slab_object mm/kasan/common.c:247 [inline] __kasan_slab_free+0x51/0x70 mm/kasan/common.c:264 kasan_slab_free include/linux/kasan.h:233 [inline] slab_free_hook mm/slub.c:2381 [inline] slab_free mm/slub.c:4643 [inline] kfree+0x2b4/0x4d0 mm/slub.c:4842 free_netdev+0x6c5/0x910 net/core/dev.c:11892 lecd_attach net/atm/lec.c:744 [inline] lane_ioctl+0x1ce8/0x23e0 net/atm/lec.c:1008 do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159 sock_do_ioctl+0x118/0x280 net/socket.c:1190 sock_ioctl+0x227/0x6b0 net/socket.c:1311 vfs_ioctl fs/ioctl.c:51 [inline] __do_sys_ioctl fs/ioctl.c:907 [inline] __se_sys_ioctl fs/ioctl.c:893 [inline] __x64_sys_ioctl+0x18e/0x210 fs/ioctl.c:893

**释放后使用 (Use-After-Free, UAF)**

该漏洞存在于Linux内核的ATM（Asynchronous Transfer Mode）子系统的LANE（LAN Emulation）驱动中 (net/atm/lec.c)。它的核心问题是，多个代码路径在没有适当加锁的情况下，并发地访问和修改一个共享的全局设备指针数组（dev_lec[]）。

漏洞的触发流程如下：

1. **共享资源**：驱动程序使用一个全局数组 dev_lec[] 来存储指向已分配的LANE客户端设备结构的指针。
2. **缺少同步**：多个函数（如 lecd_attach, lec_vcc_attach 等）可以读取或修改这个数组，但它们在操作时没有使用互斥锁（mutex）来保护，这就为竞态条件创造了机会。
3. **UAF场景**：一个典型的利用场景如下：
   a. 一个进程（或线程）调用 lecd_attach() 来创建一个新的LANE设备。函数成功分配了一个设备结构（alloc_netdev_mqs），并将其指针存入了 dev_lec[] 数组。
   b. 在该函数后续的执行中，发生了一个错误，代码进入了错误处理路径。
   c. 在错误处理路径中，代码正确地释放了刚刚分配的设备结构（free_netdev）。**然而，它忘记了将 dev_lec[] 数组中对应的指针槽位清空（置为NULL）**。
   d. 此时，dev_lec[] 数组中就留下了一个指向已被释放内存的**“悬垂指针”（dangling pointer）**。
4. **触发点**：几乎在同一时间，另一个进程（或同一个进程的另一个操作）访问了这个dev_lec[]数组，读取到了那个悬垂指针，并试图解引用它来访问设备结构的成员。
5. **结果**：这次操作访问了一块已经被释放、并可能被内核重新用于其他目的的内存，从而触发了由KASAN（内核地址消毒器）捕获的“slab-use-after-free”错误，导致内核崩溃。

## CVE-2025-38319

### Description

In the Linux kernel, the following vulnerability has been resolved: drm/amd/pp: Fix potential NULL pointer dereference in atomctrl_initialize_mc_reg_table The function atomctrl_initialize_mc_reg_table() and atomctrl_initialize_mc_reg_table_v2_2() does not check the return value of smu_atom_get_data_table(). If smu_atom_get_data_table() fails to retrieve vram_info, it returns NULL which is later dereferenced.

**空指针解引用 (NULL Pointer Dereference)**

该漏洞存在于Linux内核的AMD GPU驱动程序中（drm/amd/pp），具体位于atomctrl_initialize_mc_reg_table()和atomctrl_initialize_mc_reg_table_v2_2()这两个函数内。

漏洞的根本原因是**对一个可能失败的函数缺少了必要的错误检查**。

1. **功能与可能失败点**：这些函数在初始化时，需要从GPU的系统管理单元（SMU）获取关于显存（VRAM）的信息。为此，它们会调用smu_atom_get_data_table()函数。在某些情况下，例如硬件处于特定状态或无法提供所需数据时，这个函数调用**可能会失败**。
2. **失败信号**：当smu_atom_get_data_table()函数失败时，它会返回一个NULL指针来向上层调用者发出错误信号。
3. **软件缺陷**：在存在漏洞的旧代码中，调用方（atomctrl_initialize_mc_reg_table等）在收到返回值后，**没有检查它是否为NULL**。代码盲目地、乐观地假设函数调用总是成功的，并且返回的是一个有效的指针。
4. **触发点**：后续的代码逻辑在没有进行任何检查的情况下，直接使用这个NULL指针去访问其内部成员（解引用）。
5. **结果**：对NULL指针的解引用是一个非法的内存访问，这会立即触发CPU异常，导致内核产生一个致命错误（Oops/Panic）并崩溃。

## CVE-2025-38318

### Description

In the Linux kernel, the following vulnerability has been resolved: perf: arm-ni: Fix missing platform_set_drvdata() Add missing platform_set_drvdata in arm_ni_probe(), otherwise calling platform_get_drvdata() in remove returns NULL.

**空指针解引用 (NULL Pointer Dereference)** 

该漏洞存在于Linux内核的arm-ni（ARM Neoverse N1/N2/V1 PMU）性能监控驱动中。这是一个非常典型的驱动程序初始化和清理逻辑不匹配的问题。

漏洞的根本原因是**在初始化阶段缺少了一个关键步骤**。

1. **驱动程序模型**：Linux的平台驱动模型通常遵循一个模式：
   - 在**probe（探测/初始化）**函数中，驱动为设备分配私有数据结构，并通过platform_set_drvdata()将其与设备关联起来。
   - 在**remove（移除/清理）**函数中，驱动通过platform_get_drvdata()来取回这个私有数据，以便进行正确的清理和资源释放。
2. **软件缺陷**：在存在漏洞的旧代码中，arm_ni_probe()函数**忘记了调用platform_set_drvdata()**。
3. **触发点**：当这个驱动模块被卸载时，remove函数被调用。它尝试通过platform_get_drvdata()获取私有数据，但由于在probe阶段从未设置过，这个函数调用**返回了NULL**。
4. **结果**：后续的清理代码在没有检查返回值的情况下，直接使用了这个NULL指针，导致了**空指针解引用**和内核崩溃。即使代码有检查，由于未能获取到需要清理的数据结构，也可能导致**资源泄漏（Resource Leak）**。

## CVE-2025-38317

### Description

In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: Fix buffer overflow in debugfs If the user tries to write more than 32 bytes then it results in memory corruption. Fortunately, this is debugfs so it's limited to root users.

**缓冲区溢出 (Buffer Overflow)**

该漏洞存在于Linux内核的ath12k（Qualcomm Wi-Fi 7）驱动程序中，具体发生在其**debugfs**接口的代码中。Debugfs是内核提供给开发者的一种调试文件系统。

漏洞的根本原因是**没有对用户的输入进行长度检查**。

1. **功能背景**：驱动通过debugfs暴露了一些接口，允许开发者或管理员向内核写入数据来进行调试。
2. **软件缺陷**：处理写操作的代码为用户输入准备了一个固定大小的缓冲区（32字节）。然而，它在执行拷贝操作（如memcpy或strcpy）时，没有检查用户实际写入的数据长度。
3. **触发点**：当一个用户（必须是root权限）向这个debugfs文件写入超过32字节的数据时，拷贝操作会超出预定缓冲区的边界。
4. **结果**：这会导致**内存损坏**，写入的数据会覆盖缓冲区之后在内存中相邻的其他内核数据。

## CVE-2025-38316

### Description

In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7996: avoid NULL pointer dereference in mt7996_set_monitor() The function mt7996_set_monitor() dereferences phy before the NULL sanity check. Fix this to avoid NULL pointer dereference by moving the dereference after the check.

**空指针解引用 (NULL Pointer Dereference)**

该漏洞存在于Linux内核的mt76 Wi-Fi驱动程序中，具体涉及mt7996芯片的实现，位于mt7996_set_monitor()函数内。

漏洞的根本原因是**错误的操作顺序**。

1. **功能背景**：mt7996_set_monitor()函数负责设置或修改Wi-Fi物理层（phy）的监控模式。
2. **软件缺陷**：在存在漏洞的旧代码中，程序员的意图是检查传入的phy指针是否为NULL，以防止后续操作出错。然而，在**执行这个NULL检查之前**，代码已经对phy指针进行了**解引用**（即访问了phy所指向的内存）。
3. **触发点**：当任何调用路径向这个函数传递了一个NULL的phy指针时，漏洞就会被触发。
4. **结果**：对NULL指针的解引用是一个非法的内存访问，会立即导致CPU异常和内核恐慌（Kernel Panic），使整个系统崩溃。

## CVE-2025-38315

### Description

In the Linux kernel, the following vulnerability has been resolved: Bluetooth: btintel: Check dsbr size from EFI variable Since the size of struct btintel_dsbr is already known, we can just start there instead of querying the EFI variable size. If the final result doesn't match what we expect also fail. This fixes a stack buffer overflow when the EFI variable is larger than struct btintel_dsbr.

**栈缓冲区溢出 (Stack-based Buffer Overflow)**

该漏洞存在于Linux内核的btintel蓝牙驱动程序中。它的根本原因是**过度信任来自外部的数据源（EFI变量）**。

漏洞的触发流程如下：

1. **功能背景**：驱动程序需要从系统的EFI固件变量中读取一个名为“dsbr”（Intel Bluetooth Device Sideband Radio）的数据结构。
2. **软件缺陷**：在存在漏洞的旧代码中，驱动首先向EFI查询该变量的大小，然后根据查询到的这个大小，在**内核栈上分配一个相应大小的缓冲区**。接着，它将EFI变量的实际内容读入这个缓冲区。
3. **问题所在**：驱动程序没有对从EFI查询到的“大小”进行任何验证。它盲目地相信这个值是正确的。
4. **触发点**：一个恶意的或被篡改的EFI固件可以提供一个**巨大的、伪造的大小值**。当驱动程序试图在栈上分配这么大的一个缓冲区时，就会远远超出当前函数的栈帧边界。即使分配没有立刻失败，后续读取EFI变量内容的操作也会将大量数据写入这个过大的缓冲区，覆盖掉栈上其他重要的数据。
5. **解决方案**：补丁修复了这个问题，不再信任EFI提供的大小。它直接在栈上分配一个**已知且固定大小**的缓冲区（sizeof(struct btintel_dsbr))，然后将EFI变量的数据读入。如果实际读取到的数据大小与预期不符，则报错退出。

## CVE-2025-38314

### Description

In the Linux kernel, the following vulnerability has been resolved: virtio-pci: Fix result size returned for the admin command completion The result size returned by virtio_pci_admin_dev_parts_get() is 8 bytes larger than the actual result data size. This occurs because the result_sg_size field of the command is filled with the result length from virtqueue_get_buf(), which includes both the data size and an additional 8 bytes of status. This oversized result size causes two issues: 1. The state transferred to the destination includes 8 bytes of extra data at the end. 2. The allocated buffer in the kernel may be smaller than the returned size, leading to failures when reading beyond the allocated size. The commit fixes this by subtracting the status size from the result of virtqueue_get_buf(). This fix has been tested through live migrations with virtio-net, virtio-net-transitional, and virtio-blk devices.

**越界读取 (Out-of-Bounds Read)**

该漏洞存在于Linux内核的virtio-pci驱动中，具体发生在处理一个管理命令（admin command）的完成结果时。

漏洞的根本原因是**对返回数据长度的错误计算**。

1. **功能背景**：当驱动向virtio设备发送一个管理命令后，它会从一个virtqueue中取回命令的执行结果。这个结果包含两部分：**实际的数据** 和 一个**8字节的状态码**。
2. **软件缺陷**：在存在漏洞的旧代码中，virtio_pci_admin_dev_parts_get()函数调用virtqueue_get_buf()来获取结果的长度。然而，virtqueue_get_buf()返回的是**数据和状态码的总长度**。代码错误地将这个总长度当作是纯数据的长度。
3. **问题后果**：这个错误的长度值导致了两个问题：
   - **问题一 (数据污染)**：在进行状态迁移（如虚拟机实时迁移）时，系统会拷贝它认为的“结果数据”，由于长度计算错误，它会多拷贝8个字节（即那个状态码），污染了目标端的数据。
   - **问题二 (越界读取)**：更严重的是，当上层代码根据这个错误的、被放大了的长度去读取结果时，它可能会尝试**读取超出实际数据缓冲区边界的内存**。如果分配给数据的缓冲区恰好紧凑，这次读取就会访问到缓冲区外的未知内存，造成越界读取。

## CVE-2025-38313

### Description

In the Linux kernel, the following vulnerability has been resolved: bus: fsl-mc: fix double-free on mc_dev The blamed commit tried to simplify how the deallocations are done but, in the process, introduced a double-free on the mc_dev variable. In case the MC device is a DPRC, a new mc_bus is allocated and the mc_dev variable is just a reference to one of its fields. In this circumstance, on the error path only the mc_bus should be freed. This commit introduces back the following checkpatch warning which is a false-positive. WARNING: kfree(NULL) is safe and this check is probably not required + if (mc_bus) + kfree(mc_bus);

**双重释放 (Double Free)**

该漏洞存在于Linux内核的Freescale-MC（FSL-MC）总线驱动中。它的根本原因是一个**错误的简化**导致了对内存所有权和生命周期管理的误判。

漏洞的触发流程如下：

1. **背景**：在驱动的初始化过程中，代码会处理不同类型的MC设备。对于一个DPRC类型的设备，代码会分配一个mc_bus结构体。而另一个变量mc_dev实际上并不是一个独立分配的内存，它只是一个指向mc_bus结构体**内部某个字段的指针**。此时，mc_bus是“所有者”，mc_dev只是一个“引用”。
2. **软件缺陷（回归bug）**：一个之前的代码提交，为了简化清理逻辑，移除了对mc_bus和mc_dev之间关系的区分。在新的、有问题的错误处理路径中，代码会**同时尝试释放mc_bus和mc_dev**。
3. **双重释放发生**：
   a. kfree(mc_bus)被调用，这会正确地释放整个mc_bus结构体占用的内存。
   b. 由于mc_dev指向的是mc_bus内部的内存，这块内存此时也已经被释放了。
   c. 接着，kfree(mc_dev)被调用，这实际上是在**尝试再次释放同一块内存（或者说，是其中的一部分）**。
4. **结果**：对同一块内存执行了两次释放操作，造成了**双重释放**漏洞。

## CVE-2025-38312

### Description

In the Linux kernel, the following vulnerability has been resolved: fbdev: core: fbcvt: avoid division by 0 in fb_cvt_hperiod() In fb_find_mode_cvt(), iff mode->refresh somehow happens to be 0x80000000, cvt.f_refresh will become 0 when multiplying it by 2 due to overflow. It's then passed to fb_cvt_hperiod(), where it's used as a divider -- division by 0 will result in kernel oops. Add a sanity check for cvt.f_refresh to avoid such overflow... Found by Linux Verification Center (linuxtesting.org) with the Svace static analysis tool.

**除以零 (Division by Zero)**

该漏洞存在于Linux内核的Framebuffer设备核心代码中（fbdev: core: fbcvt），具体涉及显示模式时序的计算。

漏洞的根本原因是**在进行除法运算前，没有充分检查除数是否可能为零**，而这个零值是由一个上游的**整数溢出 (Integer Overflow)** 造成的。

1. **输入与计算**：在fb_find_mode_cvt()函数中，代码会根据一个mode->refresh值（刷新率）来计算一个新的刷新率cvt.f_refresh。计算过程涉及一次乘以2的操作。
2. **整数溢出**：如果输入的mode->refresh恰好是一个特定的、巨大的值（0x80000000），那么乘以2的操作会导致一个32位整数的**算术溢出**，结果**环绕（wrap around）变成了0**。
3. **软件缺陷**：代码没有检查这次乘法是否会导致溢出，也没有检查计算出的cvt.f_refresh是否为零。
4. **触发点**：这个为零的cvt.f_refresh值被传递给了fb_cvt_hperiod()函数。
5. **结果**：在fb_cvt_hperiod()函数中，cvt.f_refresh被用作一个**除数**。执行除以零的操作会立即触发CPU异常，导致内核产生一个致命错误（Oops/Panic）并崩溃。

## CVE-2025-38310

### Description

In the Linux kernel, the following vulnerability has been resolved: seg6: Fix validation of nexthop addresses The kernel currently validates that the length of the provided nexthop address does not exceed the specified length. This can lead to the kernel reading uninitialized memory if user space provided a shorter length than the specified one. Fix by validating that the provided length exactly matches the specified one.

**越界读取 (Out-of-Bounds Read)** 

该漏洞存在于Linux内核的seg6（Segment Routing over IPv6）实现中，具体发生在对用户提供的“下一跳”（nexthop）地址进行验证时。

漏洞的根本原因是**不完整或不充分的输入验证**。

1. **功能背景**：用户空间可以通过接口向内核提供seg6的路由信息，其中包括下一跳地址和该地址的预期长度。
2. **软件缺陷**：在存在漏洞的旧代码中，内核的验证逻辑只检查了“用户提供的地址长度**是否超过**了预期的长度”。它没有检查**是否等于**预期的长度。
   - **正确**：len == expected_len
   - **错误**：len <= expected_len
3. **触发点**：一个用户空间程序可以利用这个缺陷，提供一个比预期**更短**的地址长度。例如，预期一个16字节的IPv6地址，但用户只提供了4个字节。这个输入会通过错误的验证检查。
4. **结果**：当内核后续的代码按照**预期的长度**（例如16字节）去读取这个实际上只有4字节的地址时，它会读完这4个字节后，继续**读取其后12个字节的未初始化栈内存**。
5. **影响**：内核会基于这些包含垃圾数据的、被破坏的地址来进行路由决策，这可能导致网络包被发送到错误的目的地。同时，读取未初始化的内存也可能泄露内核栈上的敏感信息。

## CVE-2025-38309

### Description

In the Linux kernel, the following vulnerability has been resolved: drm/xe/vm: move xe_svm_init() earlier In xe_vm_close_and_put() we need to be able to call xe_svm_fini(), however during vm creation we can call this on the error path, before having actually initialised the svm state, leading to various splats followed by a fatal NPD. (cherry picked from commit 4f296d77cf49fcb5f90b4674123ad7f3a0676165)

**空指针解引用 (NULL Pointer Dereference)** 

该漏洞存在于Linux内核的XE（下一代Intel GPU）图形驱动中，具体涉及虚拟机（VM）和共享虚拟内存（SVM）的创建与销毁流程。

漏洞的根本原因是**在错误处理路径中，尝试清理一个尚未初始化的资源**。

1. **功能背景**：当驱动创建一个新的VM时，它会执行一系列的初始化步骤，其中包括调用xe_svm_init()来初始化SVM相关的状态。
2. **错误路径**：如果在VM创建的过程中，某个步骤失败了，代码会跳转到一个集中的错误处理路径。这个错误处理路径会调用xe_vm_close_and_put()函数来清理所有已经分配的资源，以防止泄漏。xe_vm_close_and_put()内部会调用xe_svm_fini()来销毁SVM状态。
3. **软件缺陷**：在存在漏洞的旧代码中，xe_svm_init()的调用被放在了初始化流程的**较后位置**。
4. **触发点**：如果VM创建在xe_svm_init()被调用**之前**的某个步骤就失败了，那么当代码跳转到错误处理路径并调用xe_vm_close_and_put()时，它会尝试调用xe_svm_fini()来清理一个**完全没有被初始化过**的SVM状态。
5. **结果**：xe_svm_fini()在执行时，会尝试访问和操作一个未初始化（很可能是NULL）的指针，导致**空指针解引用**、打印一堆警告（splats），并最终引发致命的内核崩溃。

## CVE-2025-38308

### Description

In the Linux kernel, the following vulnerability has been resolved: ASoC: Intel: avs: Fix possible null-ptr-deref when initing hw Search result of avs_dai_find_path_template() shall be verified before being used. As 'template' is already known when avs_hw_constraints_init() is fired, drop the search entirely.

**空指针解引用 (NULL Pointer Dereference)**

该漏洞存在于Linux内核的声音子系统（ASoC）中，具体涉及Intel AVS（Audio Video Speech）驱动程序的硬件初始化部分。

漏洞的根本原因是**对一个可能失败的查找函数缺少了必要的错误检查**。

1. **功能与可能失败点**：在硬件初始化函数avs_hw_constraints_init()中，代码需要获取一个DAI（Digital Audio Interface）路径的模板。为此，它调用了avs_dai_find_path_template()函数。在某些情况下，例如没有找到匹配的模板时，这个查找函数**可能会失败**。
2. **失败信号**：当avs_dai_find_path_template()函数失败时，它会返回一个NULL指针来向上层调用者发出错误信号。
3. **软件缺陷**：在存在漏洞的旧代码中，调用方在收到返回值后，**没有检查它是否为NULL**。代码盲目地、乐观地假设查找总是成功的，并且返回的是一个有效的指针。
4. **触发点**：后续的代码逻辑在没有进行任何检查的情况下，直接使用这个NULL指针去访问其内部成员（解引用）。
5. **结果**：对NULL指针的解引用是一个非法的内存访问，会立即触发CPU异常，导致内核产生一个致命错误（Oops/Panic）并崩溃。

## CVE-2025-38307

### Description

In the Linux kernel, the following vulnerability has been resolved: ASoC: Intel: avs: Verify content returned by parse_int_array() The first element of the returned array stores its length. If it is 0, any manipulation beyond the element at index 0 ends with null-ptr-deref.

**空指针解引用 (NULL Pointer Dereference)** 

该漏洞存在于Linux内核的声音子系统（ASoC）中，具体涉及Intel AVS（Audio Video Speech）驱动程序。

漏洞的根本原因是**对一个函数返回的数据内容没有进行充分的验证**。

1. **功能背景**：代码调用parse_int_array()函数来解析一段数据并返回一个整数数组。这个返回的数组有一个特殊的约定：**数组的第一个元素（索引为0）存储了该数组的有效长度**。
2. **软件缺陷**：在存在漏洞的旧代码中，调用方在拿到这个返回的数组后，**没有检查第一个元素的值**。它盲目地假设这个长度值总是大于0的。
3. **触发点**：如果parse_int_array()因为某些原因（例如，输入数据为空或格式错误）返回了一个数组，但其第一个元素的值为**0**，表示这是一个空数组。
4. **结果**：后续的代码逻辑在不知道数组为空的情况下，尝试访问数组中**索引为1或更大的元素**。这会导致两种可能的结果：
   - 如果分配的数组内存恰好只够存放那个长度为0的元素，那么访问索引1就会直接导致**越界读取 (Out-of-Bounds Read)**。
   - 更常见的情况是，代码可能会基于这个错误的长度进行指针运算，如果运算结果恰好为NULL，或者在越界读取后尝试解引用一个无效地址，就会导致**空指针解引用 (NULL Pointer Dereference)** 和内核崩溃。描述中明确指出了这一点。

## CVE-2025-38304

### Description

In the Linux kernel, the following vulnerability has been resolved: Bluetooth: Fix NULL pointer deference on eir_get_service_data The len parameter is considered optional so it can be NULL so it cannot be used for skipping to next entry of EIR_SERVICE_DATA.

**空指针解引用 (NULL Pointer Dereference)**

该漏洞存在于Linux内核的蓝牙子系统中，具体发生在eir_get_service_data()函数内。此函数用于从蓝牙设备的扩展查询响应（EIR）数据中提取服务数据。

漏洞的根本原因是**错误地假设一个可选参数总是有效的**。

1. **功能背景**：eir_get_service_data()函数接受一个名为len的指针作为参数。根据函数的设计和API约定，这个len参数是**可选的**，意味着调用者可以合法地传入一个NULL值。
2. **软件缺陷**：在存在漏洞的旧代码中，函数内部在处理完一个EIR条目后，需要计算下一个条目的位置。在计算这个偏移量时，它**没有检查len指针是否为NULL**，就直接对其进行了**解引用**（即写入*len = ...或读取*len的值）。
3. **触发点**：当任何调用路径向这个函数传入一个NULL的len指针时，漏洞就会被触发。
4. **结果**：对NULL指针的解引用是一个非法的内存访问，会立即导致CPU异常和内核恐慌（Kernel Panic），使整个系统崩溃。

## CVE-2025-38301

### Description

In the Linux kernel, the following vulnerability has been resolved: nvmem: zynqmp_nvmem: unbreak driver after cleanup Commit 29be47fcd6a0 ("nvmem: zynqmp_nvmem: zynqmp_nvmem_probe cleanup") changed the driver to expect the device pointer to be passed as the "context", but in nvmem the context parameter comes from nvmem_config.priv which is never set - Leading to null pointer exceptions when the device is accessed.

**空指针解引用 (NULL Pointer Dereference)**

该漏洞存在于Linux内核的zynqmp_nvmem（Xilinx Zynq MPSoC NVMEM）驱动程序中。这是一个典型的由于代码重构（cleanup）引入的回归bug。

漏洞的根本原因是**驱动程序对NVMEM子系统API的假设与API的实际行为不符**。

1. **代码变更（回归源）**：一个之前的代码提交（29be47fcd6a0）为了“清理”代码，修改了zynqmp_nvmem驱动，使其期望通过一个名为“context”的参数来接收设备指针（device pointer）。
2. **API行为**：然而，它所依赖的NVMEM核心子系统，其“context”参数来源于nvmem_config.priv这个字段。
3. **软件缺陷**：驱动程序在配置NVMEM时，**从未设置过nvmem_config.priv这个字段**。
4. **触发点**：当NVMEM核心子系统调用该驱动的回调函数时，它会传递一个从nvmem_config.priv中取出的值作为“context”参数。由于该字段从未被设置，所以传递过来的值是**NULL**。
5. **结果**：驱动程序的回调函数接收到这个NULL的“context”参数，并错误地将其当作一个有效的设备指针来使用。当它尝试解引用这个NULL指针去访问设备成员时，就会立即触发**空指针解引用**，导致内核恐慌（Kernel Panic）和系统崩溃。

## CVE-2025-38299

### Description

In the Linux kernel, the following vulnerability has been resolved: ASoC: mediatek: mt8195: Set ETDM1/2 IN/OUT to COMP_DUMMY() ETDM2_IN_BE and ETDM1_OUT_BE are defined as COMP_EMPTY(), in the case the codec dai_name will be null. Avoid a crash if the device tree is not assigning a codec to these links. [ 1.179936] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 [ 1.181065] Mem abort info: [ 1.181420] ESR = 0x0000000096000004 [ 1.181892] EC = 0x25: DABT (current EL), IL = 32 bits [ 1.182576] SET = 0, FnV = 0 [ 1.182964] EA = 0, S1PTW = 0 [ 1.183367] FSC = 0x04: level 0 translation fault [ 1.183983] Data abort info: [ 1.184406] ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000 [ 1.185097] CM = 0, WnR = 0, TnD = 0, TagAccess = 0 [ 1.185766] GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0 [ 1.186439] [0000000000000000] user address but active_mm is swapper [ 1.187239] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP [ 1.188029] Modules linked in: [ 1.188420] CPU: 7 UID: 0 PID: 70 Comm: kworker/u32:1 Not tainted 6.14.0-rc4-next-20250226+ #85 [ 1.189515] Hardware name: Radxa NIO 12L (DT) [ 1.190065] Workqueue: events_unbound deferred_probe_work_func [ 1.190808] pstate: 40400009 (nZcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--) [ 1.191683] pc : __pi_strcmp+0x24/0x140 [ 1.192170] lr : mt8195_mt6359_soc_card_probe+0x224/0x7b0 [ 1.192854] sp : ffff800083473970 [ 1.193271] x29: ffff800083473a10 x28: 0000000000001008 x27: 0000000000000002 [ 1.194168] x26: ffff800082408960 x25: ffff800082417db0 x24: ffff800082417d88 [ 1.195065] x23: 000000000000001e x22: ffff800082dbf480 x21: ffff800082dc07b8 [ 1.195961] x20: 0000000000000000 x19: 0000000000000013 x18: 00000000ffffffff [ 1.196858] x17: 000000040044ffff x16: 005000f2b5503510 x15: 0000000000000006 [ 1.197755] x14: ffff800082407af0 x13: 6e6f69737265766e x12: 692d6b636f6c6374 [ 1.198651] x11: 0000000000000002 x10: ffff80008240b920 x9 : 0000000000000018 [ 1.199547] x8 : 0101010101010101 x7 : 0000000000000000 x6 : 0000000000000000 [ 1.200443] x5 : 0000000000000000 x4 : 8080808080000000 x3 : 303933383978616d [ 1.201339] x2 : 0000000000000000 x1 : ffff80008240b920 x0 : 0000000000000000 [ 1.202236] Call trace: [ 1.202545] __pi_strcmp+0x24/0x140 (P) [ 1.203029] mtk_soundcard_common_probe+0x3bc/0x5b8 [ 1.203644] platform_probe+0x70/0xe8 [ 1.204106] really_probe+0xc8/0x3a0 [ 1.204556] __driver_probe_device+0x84/0x160 [ 1.205104] driver_probe_device+0x44/0x130 [ 1.205630] __device_attach_driver+0xc4/0x170 [ 1.206189] bus_for_each_drv+0x8c/0xf8 [ 1.206672] __device_attach+0xa8/0x1c8 [ 1.207155] device_initial_probe+0x1c/0x30 [ 1.207681] bus_probe_device+0xb0/0xc0 [ 1.208165] deferred_probe_work_func+0xa4/0x100 [ 1.208747] process_one_work+0x158/0x3e0 [ 1.209254] worker_thread+0x2c4/0x3e8 [ 1.209727] kthread+0x134/0x1f0 [ 1.210136] ret_from_fork+0x10/0x20 [ 1.210589] Code: 54000401 b50002c6 d503201f f86a6803 (f8408402) [ 1.211355] ---[ end trace 0000000000000000 ]---

**空指针解引用 (NULL Pointer Dereference)**

该漏洞存在于Linux内核的声音子系统（ASoC）中，具体涉及联发科（MediaTek）MT8195芯片的声卡驱动。

漏洞的根本原因是**在对一个字符串指针进行操作前，没有检查其是否为NULL**。

1. **功能背景**：在声卡驱动的探测（probe）函数mt8195_mt6359_soc_card_probe()中，代码需要处理不同的音频链接（links）。
2. **软件缺陷**：对于两个特定的链接（ETDM2_IN_BE 和 ETDM1_OUT_BE），它们的定义是COMP_EMPTY()。这个宏展开后，会导致这些链接的codec_dai_name字段（编解码器DAI的名称）被设置为NULL。
3. **触发条件**：当设备树（device tree）中没有为这些特定的音频链接分配一个实际的编解码器时，这个codec_dai_name字段就保持为NULL。
4. **触发点**：后续的代码逻辑（如调用栈中的__pi_strcmp）会接收这个NULL指针，并尝试将其作为一个有效的C字符串来进行比较（strcmp）或其他操作。
5. **结果**：对NULL指针的解引用（即尝试读取地址0x0000000000000000的内容）是一个非法的内存访问，会立即触发CPU的内存管理单元异常（Data Abort），导致内核产生一个致命错误（Oops）并崩溃。

## CVE-2025-38298

### Description

In the Linux kernel, the following vulnerability has been resolved: EDAC/skx_common: Fix general protection fault After loading i10nm_edac (which automatically loads skx_edac_common), if unload only i10nm_edac, then reload it and perform error injection testing, a general protection fault may occur: mce: [Hardware Error]: Machine check events logged Oops: general protection fault ... ... Workqueue: events mce_gen_pool_process RIP: 0010:string+0x53/0xe0 ... Call Trace: <TASK> ? die_addr+0x37/0x90 ? exc_general_protection+0x1e7/0x3f0 ? asm_exc_general_protection+0x26/0x30 ? string+0x53/0xe0 vsnprintf+0x23e/0x4c0 snprintf+0x4d/0x70 skx_adxl_decode+0x16a/0x330 [skx_edac_common] skx_mce_check_error.part.0+0xf8/0x220 [skx_edac_common] skx_mce_check_error+0x17/0x20 [skx_edac_common] ... The issue arose was because the variable 'adxl_component_count' (inside skx_edac_common), which counts the ADXL components, was not reset. During the reloading of i10nm_edac, the count was incremented by the actual number of ADXL components again, resulting in a count that was double the real number of ADXL components. This led to an out-of-bounds reference to the ADXL component array, causing the general protection fault above. Fix this issue by resetting the 'adxl_component_count' in adxl_put(), which is called during the unloading of {skx,i10nm}_edac.

**越界读取 (Out-of-Bounds Read)**

该漏洞存在于Linux内核的EDAC（Error Detection and Correction）子系统中，具体涉及skx_edac_common模块。

漏洞的根本原因是**在驱动卸载时，未能正确重置全局状态变量**，导致驱动重载后状态不一致。

1. **功能背景**：skx_edac_common模块维护着一个全局计数器adxl_component_count，用于记录ADXL（Address Decoder Cross-Link）组件的数量。它还有一个与之对应的组件数组。
2. **正常加载**：第一次加载i10nm_edac驱动时（它会依赖并加载skx_edac_common），adxl_component_count被正确地设置为实际的组件数量。
3. **卸载与缺陷**：当i10nm_edac被卸载时，skx_edac_common中的清理函数adxl_put()被调用。然而，这个函数**忘记了将全局计数器adxl_component_count重置为0**。
4. **重载与状态错误**：当i10nm_edac被**重新加载**时，skx_edac_common的初始化代码再次运行。它会在**未被重置的旧计数值**的基础上，**再次增加**实际的组件数量。这导致adxl_component_count的值变成了实际数量的**两倍**。
5. **触发点**：当后续的代码（例如，错误注入测试触发的skx_adxl_decode）使用这个被放大了的、错误的计数值作为循环边界来遍历ADXL组件数组时，它会尝试访问超出数组实际边界的元素。
6. **结果**：对数组的**越界读取**访问到了无效或非预期的内存区域，导致了**通用保护故障（General Protection Fault）**和内核崩溃。

## CVE-2025-38297

### Description

In the Linux kernel, the following vulnerability has been resolved: PM: EM: Fix potential division-by-zero error in em_compute_costs() When the device is of a non-CPU type, table[i].performance won't be initialized in the previous em_init_performance(), resulting in division by zero when calculating costs in em_compute_costs(). Since the 'cost' algorithm is only used for EAS energy efficiency calculations and is currently not utilized by other device drivers, we should add the _is_cpu_device(dev) check to prevent this division-by-zero issue.

**UBI (Use-Before-Initialization) - 使用未初始化的变量**

这是一个典型的使用未初始化变量的漏洞。

- **问题陈述**：描述中明确指出，对于非CPU类型的设备，变量 table[i].performance **“不会被初始化”**（won't be initialized）。
- **后果**：这个未初始化的变量（其默认值很可能是0）稍后在 em_compute_costs() 函数中被用作一个除数。
- **结果**：这直接导致了一个“**除零错误**”（division-by-zero），引发程序崩溃。

## CVE-2025-38294

### Description

In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix NULL access in assign channel context handler Currently, when ath12k_mac_assign_vif_to_vdev() fails, the radio handle (ar) gets accessed from the link VIF handle (arvif) for debug logging, This is incorrect. In the fail scenario, radio handle is NULL. Fix the NULL access, avoid radio handle access by moving to the hardware debug logging helper function (ath12k_hw_warn). Tested-on: QCN9274 hw2.0 PCI WLAN.WBE.1.3.1-00173-QCAHKSWPL_SILICONZ-1 Tested-on: WCN7850 hw2.0 PCI WLAN.HMT.1.0.c5-00481-QCAHMTSWPL_V1.0_V2.0_SILICONZ-3

**NPD (Null-Pointer-Dereference) - 空指针解引用**

这是一个明确的空指针解引用漏洞。

- **直接证据**：漏洞的标题和描述都反复使用了关键字 “**NULL access**”（NULL访问）。
- **问题流程**：
  1. 在一个特定的错误处理路径中（当 ath12k_mac_assign_vif_to_vdev() 失败时），一个名为 radio handle 的指针被设置为 NULL。
  2. 紧接着，代码在没有进行空指针检查的情况下，尝试通过这个 NULL 指针去访问数据以进行日志记录（"gets accessed ... for debug logging"）。

## CVE-2025-38292

### Description

In the Linux kernel, the following vulnerability has been resolved: wifi: ath12k: fix invalid access to memory In ath12k_dp_rx_msdu_coalesce(), rxcb is fetched from skb and boolean is_continuation is part of rxcb. Currently, after freeing the skb, the rxcb->is_continuation accessed again which is wrong since the memory is already freed. This might lead use-after-free error. Hence, fix by locally defining bool is_continuation from rxcb, so that after freeing skb, is_continuation can be used. Compile tested only.

**释放后使用 (Use-After-Free, UAF)**

该漏洞存在于Linux内核的ath12k（Qualcomm Wi-Fi 7）驱动程序中，具体发生在数据路径（DP）的接收函数ath12k_dp_rx_msdu_coalesce()内。

漏洞的根本原因是**在释放了一块内存后，仍然尝试访问该内存中的数据**。

1. **功能背景**：这个函数负责处理接收到的网络数据包（skb），并进行合并操作。它需要从skb中获取一个控制块（rxcb），并根据rxcb中的一个标志位is_continuation来决定后续的操作。
2. **软件缺陷**：在存在漏洞的旧代码中，操作的顺序是错误的：
   a. 代码首先从skb中获取了指向rxcb的指针。
   b. 接着，在某些逻辑分支中，代码会调用函数来**释放（free）整个skb**。由于rxcb是skb的一部分或与之紧密关联，释放skb也意味着rxcb所指向的内存被释放了。
   c. 在释放了skb**之后**，代码仍然尝试通过rxcb指针去访问is_continuation标志位（rxcb->is_continuation）。
3. **触发点**：当代码执行到这个逻辑分支时，就会发生释放后使用。
4. **结果**：这次操作访问了一块已经被释放、可能已被内核重新分配用于其他目的的内存。这会导致多种可能的问题：
   - 如果内存未被重用，可能会读取到无效数据，导致程序逻辑错误。
   - 如果内存已被重用，可能会读取到其他模块的数据，导致更严重的逻辑错误或信息泄露。
   - 如果访问的地址恰好触发了页面错误，会导致内核恐慌（Kernel Panic）和系统崩溃。

## CVE-2025-38289

### Description

In the Linux kernel, the following vulnerability has been resolved: scsi: lpfc: Avoid potential ndlp use-after-free in dev_loss_tmo_callbk Smatch detected a potential use-after-free of an ndlp oject in dev_loss_tmo_callbk during driver unload or fatal error handling. Fix by reordering code to avoid potential use-after-free if initial nodelist reference has been previously removed.

**释放后使用 (Use-After-Free, UAF)**

漏洞的根本原因是**错误的操作顺序**，导致在检查一个对象是否有效之前就先使用了它。

1. **功能背景**：当驱动检测到一个设备丢失时，会启动一个定时器。如果超时后设备仍未恢复，dev_loss_tmo_callbk回调函数就会被调用来处理这个事件。这个函数需要操作一个代表远程节点的ndlp对象。
2. **软件缺陷**：在存在漏洞的旧代码中，函数的操作顺序是这样的：
   a. 代码首先**使用（解引用）ndlp指针**来访问其内部成员，以执行某些操作（例如，记录日志或修改状态）。
   b. 然后，在函数的**稍后位置**，它才去检查这个ndlp对象是否仍然有效（例如，检查它的引用计数或是否已经从一个全局列表中移除）。
3. **竞态条件/触发点**：在定时器超时并触发回调的这段时间内，系统的其他部分（例如，驱动卸载流程或另一个错误处理路径）可能已经**释放了（freed）这个ndlp对象**并将其从节点列表中移除了。
4. **结果**：当dev_loss_tmo_callbk回调函数执行时，它一开始就解引用了一个**悬垂指针**（指向已被释放的ndlp内存）。这就构成了**释放后使用（Use-After-Free）**，极有可能导致内核恐慌（Kernel Panic）和系统崩溃。

## CVE-2025-38286

### Description

In the Linux kernel, the following vulnerability has been resolved: pinctrl: at91: Fix possible out-of-boundary access at91_gpio_probe() doesn't check that given OF alias is not available or something went wrong when trying to get it. This might have consequences when accessing gpio_chips array with that value as an index. Note, that BUG() can be compiled out and hence won't actually perform the required checks.

**越界访问 (Out-of-Bounds Access)**

该漏洞存在于Linux内核的pinctrl子系统中，具体涉及Atmel AT91系列SoC的GPIO驱动程序 (pinctrl: at91)。

漏洞的根本原因是**在使用一个从外部获取的值作为数组索引之前，没有进行充分的有效性检查**。

1. **功能背景**：在驱动的探测函数at91_gpio_probe()中，代码需要从设备树（OF, Open Firmware）中获取一个“别名ID”（alias ID）。这个ID被用作一个全局数组gpio_chips的索引，以定位到该GPIO控制器对应的数据结构。
2. **软件缺陷**：在存在漏洞的旧代码中，当从设备树获取别名ID的操作失败时（例如，设备树中没有定义别名，或查找出错），代码**没有检查这个失败**。
3. **触发点**：如果获取别名ID失败，返回的索引值可能是**负数**（一个错误码）或一个**无效的正数**。
4. **结果**：后续的代码在没有进行任何验证的情况下，直接使用这个无效的、可能为负数的索引值去访问gpio_chips数组。
   - 如果索引是一个巨大的正数，会造成**越界读取/写入 (Out-of-Bounds Read/Write)**。
   - 如果索引是负数，这在C语言中同样是未定义行为，通常也会导致访问到数组边界之外的内存。
   - 这两种情况都会破坏内核内存，极有可能导致内核恐慌（Kernel Panic）和系统崩溃。
5. **关于BUG()的说明**：描述中提到，旧代码中可能有一个BUG()宏。但BUG()宏在某些内核配置下（例如，生产环境）可能会被编译成空操作，因此它并不能作为一个可靠的检查机制。

## CVE-2025-38284

### Description

In the Linux kernel, the following vulnerability has been resolved: wifi: rtw89: pci: configure manual DAC mode via PCI config API only To support 36-bit DMA, configure chip proprietary bit via PCI config API or chip DBI interface. However, the PCI device mmap isn't set yet and the DBI is also inaccessible via mmap, so only if the bit can be accessible via PCI config API, chip can support 36-bit DMA. Otherwise, fallback to 32-bit DMA. With NULL mmap address, kernel throws trace: BUG: unable to handle page fault for address: 0000000000001090 #PF: supervisor write access in kernel mode #PF: error_code(0x0002) - not-present page PGD 0 P4D 0 Oops: Oops: 0002 [#1] PREEMPT SMP PTI CPU: 1 UID: 0 PID: 71 Comm: irq/26-pciehp Tainted: G OE 6.14.2-061402-generic #202504101348 Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE RIP: 0010:rtw89_pci_ops_write16+0x12/0x30 [rtw89_pci] RSP: 0018:ffffb0ffc0acf9d8 EFLAGS: 00010206 RAX: ffffffffc158f9c0 RBX: ffff94865e702020 RCX: 0000000000000000 RDX: 0000000000000718 RSI: 0000000000001090 RDI: ffff94865e702020 RBP: ffffb0ffc0acf9d8 R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000015 R13: 0000000000000719 R14: ffffb0ffc0acfa1f R15: ffffffffc1813060 FS: 0000000000000000(0000) GS:ffff9486f3480000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 0000000000001090 CR3: 0000000090440001 CR4: 00000000000626f0 Call Trace: <TASK> rtw89_pci_read_config_byte+0x6d/0x120 [rtw89_pci] rtw89_pci_cfg_dac+0x5b/0xb0 [rtw89_pci] rtw89_pci_probe+0xa96/0xbd0 [rtw89_pci] ? __pfx___device_attach_driver+0x10/0x10 ? __pfx___device_attach_driver+0x10/0x10 local_pci_probe+0x47/0xa0 pci_call_probe+0x5d/0x190 pci_device_probe+0xa7/0x160 really_probe+0xf9/0x370 ? pm_runtime_barrier+0x55/0xa0 __driver_probe_device+0x8c/0x140 driver_probe_device+0x24/0xd0 __device_attach_driver+0xcd/0x170 bus_for_each_drv+0x99/0x100 __device_attach+0xb4/0x1d0 device_attach+0x10/0x20 pci_bus_add_device+0x59/0x90 pci_bus_add_devices+0x31/0x80 pciehp_configure_device+0xaa/0x170 pciehp_enable_slot+0xd6/0x240 pciehp_handle_presence_or_link_change+0xf1/0x180 pciehp_ist+0x162/0x1c0 irq_thread_fn+0x24/0x70 irq_thread+0xef/0x1c0 ? __pfx_irq_thread_fn+0x10/0x10 ? __pfx_irq_thread_dtor+0x10/0x10 ? __pfx_irq_thread+0x10/0x10 kthread+0xfc/0x230 ? __pfx_kthread+0x10/0x10 ret_from_fork+0x47/0x70 ? __pfx_kthread+0x10/0x10 ret_from_fork_asm+0x1a/0x30 </TASK>

**空指针解引用 (NULL Pointer Dereference)**

该漏洞存在于Linux内核的rtw89（Realtek Wi-Fi）驱动程序的PCI接口部分。

漏洞的根本原因是**在驱动初始化流程的一个非常早期的阶段，尝试使用一个尚未被初始化的资源**。

1. **功能背景**：为了支持36位的DMA地址，驱动需要配置芯片的一个专有寄存器位。这个配置可以通过两种方式完成：PCI配置空间API，或者芯片的DBI接口（通过内存映射IO）。
2. **初始化顺序问题**：在驱动的probe函数执行时，特别是当设备被热插拔（pciehp）时，**PCI设备的内存映射IO（mmap）区域还没有被设置好**。这意味着，任何试图通过内存映射来访问硬件寄存器的操作都会失败。
3. **软件缺陷**：在存在漏洞的旧代码中，驱动尝试配置这个寄存器时，没有考虑到内存映射可能尚未准备好的情况。它会去调用rtw89_pci_ops_write16()，这个函数内部会尝试通过一个**NULL的内存映射基地址**（mmap address）来计算要写入的物理地址。
4. **触发点**：当代码对这个NULL的基地址进行指针运算，并尝试解引用得到的结果时，就触发了空指针解引用。
5. **结果**：如日志所示，内核尝试写入一个基于NULL计算出的非法地址（0000000000001090），这立即导致了一个页面错误（Page Fault）和内核Oops，最终使系统崩溃。

## CVE-2025-38283

### Description

In the Linux kernel, the following vulnerability has been resolved: hisi_acc_vfio_pci: bugfix live migration function without VF device driver If the VF device driver is not loaded in the Guest OS and we attempt to perform device data migration, the address of the migrated data will be NULL. The live migration recovery operation on the destination side will access a null address value, which will cause access errors. Therefore, live migration of VMs without added VF device drivers does not require device data migration. In addition, when the queue address data obtained by the destination is empty, device queue recovery processing will not be performed.

**空指针解引用 (NULL Pointer Dereference)**

该漏洞存在于Linux内核的hisi_acc_vfio_pci驱动中，该驱动用于支持海思（HiSilicon）加速器的PCIe VF（虚拟功能）直通。漏洞在**虚拟机实时迁移（Live Migration）**的特定场景下被触发。

漏洞的根本原因是**在迁移过程中，错误地假设了一个可选的组件（VF驱动）总是存在的**。

1. **功能背景**：当一个包含VF直通设备的虚拟机进行实时迁移时，宿主机（Host）需要保存和恢复该设备的状态，这其中就包括了设备队列（queue）的状态数据。
2. **触发条件**：一个特殊的场景——在虚拟机（Guest OS）内部，**没有加载对应的VF设备驱动程序**。这意味着，从Guest的角度看，这个VF设备是存在的但未被使用的。
3. **软件缺陷**：当宿主机尝试为这个未被使用的VF设备保存迁移数据时，由于Guest内部没有驱动来提供队列信息，导致获取到的**队列地址数据为NULL**。
4. **触发点**：当虚拟机迁移到**目标宿主机（destination side）**后，目标端的hisi_acc_vfio_pci驱动开始执行恢复操作。它会接收到这个NULL的队列地址数据。
5. **结果**：在恢复流程中，代码没有检查这个地址是否为NULL，就直接尝试访问它，以恢复设备队列。这立即导致了**空指针解引用**和访问错误，很可能引发宿主机内核崩溃。

## CVE-2025-38281

### Description

In the Linux kernel, the following vulnerability has been resolved: wifi: mt76: mt7996: Add NULL check in mt7996_thermal_init devm_kasprintf() can return a NULL pointer on failure,but this returned value in mt7996_thermal_init() is not checked. Add NULL check in mt7996_thermal_init(), to handle kernel NULL pointer dereference error.

**空指针解引用 (NULL Pointer Dereference)**

该漏洞存在于Linux内核的mt76 Wi-Fi驱动程序中，具体涉及mt7996芯片的温控（thermal）初始化部分。

漏洞的根本原因是**对一个可能失败的内存分配函数缺少了必要的错误检查**。

1. **功能与可能失败点**：在温控初始化函数mt7996_thermal_init()中，代码需要创建一个带格式的字符串，并为其分配内存。为此，它调用了devm_kasprintf()函数。在系统内存不足的情况下，这个内存分配操作**可能会失败**。
2. **失败信号**：当devm_kasprintf()函数失败时，它会返回一个NULL指针来向上层调用者发出错误信号。
3. **软件缺陷**：在存在漏洞的旧代码中，调用方在收到返回值后，**没有检查它是否为NULL**。代码盲目地、乐观地假设内存分配总是成功的，并且返回的是一个有效的指针。
4. **触发点**：后续的代码逻辑在没有进行任何检查的情况下，直接使用这个NULL指针去执行字符串操作（例如strcpy, strlen等）或将其传递给其他需要有效指针的函数。
5. **结果**：对NULL指针的解引用是一个非法的内存访问，会立即触发CPU异常，导致内核产生一个致命错误（Oops/Panic）并崩溃。

## CVE-2025-38277

### Description

In the Linux kernel, the following vulnerability has been resolved: mtd: nand: ecc-mxic: Fix use of uninitialized variable ret If ctx->steps is zero, the loop processing ECC steps is skipped, and the variable ret remains uninitialized. It is later checked and returned, which leads to undefined behavior and may cause unpredictable results in user space or kernel crashes. This scenario can be triggered in edge cases such as misconfigured geometry, ECC engine misuse, or if ctx->steps is not validated after initialization. Initialize ret to zero before the loop to ensure correct and safe behavior regardless of the ctx->steps value. Found by Linux Verification Center (linuxtesting.org) with SVACE.

**使用未初始化的变量 (Use of Uninitialized Variable)**

该漏洞存在于Linux内核的MTD（Memory Technology Device）子系统中，具体涉及旺宏（Macronix）NAND闪存的ECC（错误纠正码）处理驱动 (ecc-mxic)。

漏洞的根本原因是**一个局部变量在某些合法的代码路径下，没有被初始化就被使用**。

1. **功能背景**：驱动程序在处理NAND闪存的读写操作时，需要按步骤（steps）计算或校验ECC。
2. **变量声明**：函数中声明了一个名为ret的局部变量，用于存储循环操作的返回值。它**没有被赋予一个初始值**。
3. **软件缺陷**：代码中有一个循环，用于遍历所有的ECC步骤。ret变量只在**这个循环内部被赋值**。
4. **触发点**：如果输入的上下文ctx->steps的值为**零**，那么这个处理ECC步骤的**循环将一次也不会执行**。
5. **结果**：当循环被跳过后，代码会继续执行到函数的末尾。在末尾，它会**检查并返回ret变量的值**。由于ret从未被赋值，它包含的是栈上的一个**随机垃圾值**。
6. **影响**：
   - 返回一个不可预测的垃圾值给上层调用者，可能会被误解为成功或某种特定的错误码，导致后续的程序逻辑混乱和未定义行为。
   - 在某些情况下，如果这个垃圾值恰好被用作指针或数组索引，可能会直接导致内核崩溃。

## CVE-2025-40114

#### Description

In the Linux kernel, the following vulnerability has been resolved: iio: light: Add check for array bounds in `veml6075_read_int_time_ms`.
 The array contains only 5 elements, but the index calculated by `veml6075_read_int_time_index` can range from 0 to 7, which could lead to out-of-bounds access. The check prevents this issue.
 Coverity Issue CID 1574309: (#1 of 1): Out-of-bounds read (OVERRUN) overrun-local: Overrunning array `veml6075_it_ms` of 5 4-byte elements at element index 7 (byte offset 31) using index `int_index` (which evaluates to 7).
 This is hardening against potentially broken hardware. Good to have but not necessary to backport.

**Out-of-Bounds（越界访问）**

该漏洞为典型的 **数组越界读取** 问题。`veml6075_read_int_time_index()` 可能返回 0–7 的值，而目标数组 `veml6075_it_ms` 只有 5 个元素（索引 0–4）。当返回值超出范围（如 7）时，访问该数组会导致未定义行为或读取非法内存，构成严重的越界读取漏洞。Coverity 工具也将其标记为 `out-of-bounds read`，符合越界访问漏洞定义。该补丁通过添加边界检查来避免这一问题。

## CVE-2025-39930

**Use-After-Free**

该漏洞是典型的释放后使用问题。在 graph_util_parse_dai() 函数中，一个提交错误地为 device_node 资源添加了 __free 自动释放属性。这导致当函数执行完毕后，该 device_node 所占用的内存会被立即释放。然而，根据漏洞描述 we need to keep it while driver is in use，驱动程序的后续流程仍然需要使用这个 device_node。因此，当驱动后续部分尝试通过仍然持有的指针访问已被释放的内存时，便构成了释放后使用，可能导致系统崩溃或不可预知的行为。补丁通过移除该 __free 属性来修正这个不当的提前释放问题。

## CVE-2025-39778

**Out-of-Bound**

该漏洞属于典型的数组越界读取问题。在函数 nvmet_ctrl_state_show() 中，代码对 csts_state_names[] 数组进行遍历。根据描述，该数组仅有六个元素，但循环却被设计为执行七次。这导致在第七次迭代时，程序会尝试访问一个超出数组合法边界的索引，从而引发对栈上内存的越界读取。CVE的标题 “Fix out-of-bounds stack access” 也直接指明了此漏洞的性质，符合越界访问的定义。

## CVE-2025-39755

**NPD (Null-Pointer-Dereference)**

该漏洞是典型的空指针解引用问题。由于 pcmcia_driver 结构体中的 name 字段没有被正确初始化，其值默认为 NULL。当 pcmcia_register_driver 函数后续调用 strcmp 来处理这个 name 字段时，实际上是向 strcmp 传递了一个空指针。尝试读取空指针指向的地址内容导致了空指针解引用，并引发了内核Oops。漏洞描述中的 “led to a NULL pointer deref Oops” 直接证实了这一点。

## CVE-2025-39735

**Out-of-Bound**

该漏洞是一个由整数溢出导致的越界读取问题。其根源在于 ea_get 函数中，一个来自扩展属性的巨大尺寸值 EALIST_SIZE(ea_buf->xattr) 在 clamp_t 函数中被当作有符号整数处理，引发了整数溢出，从而产生了一个负数的长度值。这个错误的负数长度值随后被传递给 print_hex_dump 函数，在函数内部被转换为一个极大的无符号数。最终，这个被严重破坏的长度值被用作循环的边界条件，导致循环远超缓冲区的实际大小，在访问 ptr[j] 时读取了边界之外的内存，构成了越界读取。

## CVE-2025-39728

**Out-of-Bound**

该漏洞是典型的数组越界访问问题。在 samsung_clk_init 函数中，代码在初始化用于记录数组大小的字段 ctx->clk_data.num 之前，就尝试解引用数组 ctx->clk_data.hws。由于 ctx->clk_data.num 未被赋值，其默认值（通常为0）使得任何对数组 hws 的访问都被视为越界。漏洞描述中 UBSAN 工具的报错信息 “array index out of bounds” 直接指明了此问题的性质。修复方案通过调整代码顺序，确保在访问数组前先设置其大小，从而解决了此越界访问问题。

## CVE-2025-38497

**Out-of-Bound**

该漏洞是典型的数组越界读取问题。当向 qw_sign 或 landingPage 这两个 sysfs 属性写入一个空字符串时，代码获取到的长度 l 为零。随后，程序在没有检查 l 是否大于零的情况下，尝试访问 page[l - 1]，即 page[-1]。使用负数作为数组索引访问内存，构成了对缓冲区起始边界之前的越界读取。漏洞描述中的 "OOB read on empty string write" 和修复方案中增加对零长度输入的检查，都明确证实了这是一个越界访问漏洞。

## CVE-2025-38495

**Buffer-Overflow**

该漏洞是典型的缓冲区溢出问题。其根源在于 hid-core 分配报告缓冲区时，未能正确计算所需大小。具体来说，当不使用报告ID时，协议要求缓冲区的第一个字节必须为0，但当前代码在分配内存时没有为这个额外的字节预留空间。这导致实际分配的缓冲区比底层驱动程序预期要写入的数据小了一个字节。因此，当驱动程序尝试写入完整的报告数据时，会超出缓冲区的边界，向相邻内存写入一个字节，构成了缓冲区溢出。

## CVE-2025-38493

**Buffer-Overflow**

该漏洞是典型的缓冲区溢出问题。其根源在于 __timerlat_dump_stack 函数中的逻辑顺序错误。代码在对 struct stack_entry 结构体中的 size 字段进行赋值之前，就调用了 memcpy 来填充同一结构体内的 caller 字段。由于 caller 字段被编译器注解标记为由 size 字段指定其大小，memcpy 的安全检查机制会读取 size 字段来确定目标缓冲区的边界。此时 size 字段尚未初始化，含有一个垃圾值（在崩溃场景中为0）。因此，当 memcpy 尝试向一个被认为是0字节大小的缓冲区写入数据时，便构成了缓冲区溢出，并被内核的FORTIFY机制检测到而引发崩溃。

## CVE-2025-38489

**NPD (Null-Pointer-Dereference)**

该漏洞是典型的空指针解引用问题。漏洞描述指出，一个修复 bpf_arch_text_poke() 函数在 new_addr == NULL 情况下的问题的提交被意外移除了，导致内核崩溃问题复现。这表明当 new_addr 参数为 NULL 时，函数内部没有进行正确的检查就尝试使用这个指针。对一个空指针进行解引用操作，试图访问其指向的内存，最终导致了内核恐慌，这完全符合空指针解引用的定义。

## CVE-2025-38488

**Use-After-Free**

该漏洞是典型的释放后使用问题。问题发生在 crypt_message 函数中处理异步加密操作时。该函数分配一个加密请求缓冲区 creq 并启动一个可能在后台硬件中运行的异步加密任务。然而，代码在没有等待后台任务完成的情况下，就立即调用 kvfree_sensitive 释放了 creq 缓冲区。当硬件加密驱动稍后完成任务并尝试访问这个已被释放的缓冲区时，便构成了释放后使用，最终导致内核崩溃。漏洞的标题和描述都明确指出了这是一个 use-after-free 问题。

## CVE-2025-38487

**NPD (Null-Pointer-Dereference)**

该漏洞是典型的空指针解引用问题。漏洞发生在驱动的移除函数 aspeed_lpc_snoop_remove 中。该函数在没有检查LPC snoop通道是否已启用的情况下，就尝试去禁用它们。如果一个通道从未被启用，那么其关联的资源结构体指针就为NULL。代码随后将这个NULL指针传递给 misc_deregister 等函数，这些函数在尝试访问其成员时，便解引用了空指针，从而引发内核恐慌。内核崩溃日志中 “Unable to handle kernel NULL pointer dereference” 的信息直接证实了这一点。

## CVE-2025-38486

**Buffer-Overflow**

该漏洞的根本原因是一个典型的缓冲区溢出。尽管最终表现为内核崩溃，但其根源在于被回退的补丁中引入的多项逻辑错误，其中最严重的是一个内存损坏问题。根据漏洞描述中的“Bug #2”，代码在处理通道映射时，会根据一个包含16个元素的源数组进行迭代，但写入的目标数组 ctrl->pconfig[] 却只有15个元素。这种大小不匹配导致循环在最后一次迭代时，会尝试写入目标数组边界之外的内存，从而引发缓冲区溢出并破坏相邻的内存数据。这种内存损坏是导致后续内核发生“BRK exception”和恐慌的直接原因。

## CVE-2025-38485

**Use-After-Free**

该漏洞是典型的释放后使用问题。其根源在于 fxls8962af_fifo_flush 函数（在中断上下文中运行）和禁用设备缓冲区的代码之间存在竞态条件。当设备退出缓冲区模式时，相关的资源，如 active_scan_mask，会被释放。然而，由于缺少同步机制，fxls8962af_fifo_flush 中断处理程序可能在这些资源被释放后仍然尝试访问它们。这种在内存被释放后继续引用的行为构成了释放后使用，并最终导致内核因访问无效内存而崩溃。CVE的标题 “Fix use after free” 也直接指明了此漏洞的性质。