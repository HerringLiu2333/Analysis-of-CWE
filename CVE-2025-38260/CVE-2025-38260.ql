/**
 * @name CVE-2025-38260
 * @description 在 Btrfs 文件系统挂载过程中，检测一处有缺陷的错误处理逻辑。
 *              当处理一个损坏的 csum tree 时，一个本应执行的错误处理被不恰当的嵌套条件所包裹，
 *              导致错误状态被忽略，最终在后续操作中引发空指针解引用，造成内核崩溃。
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/cve-2025-38260-conditional-error-handling
 * @tags security
 *       correctness
 *       error-handling
 *       btrfs
 *       external/cwe/cwe-703
 *       external/cwe/cwe-476
 * @patch-commit 547e836661554dcfa15c212a3821664e85b4191a
 * @source-file fs/btrfs/disk-io.c
 * @affected-function load_global_roots_objectid
 * @kernel-config CONFIG_BTRFS_FS
 * @vulnerability-type Improper Error Handling
 * @patch-diff |
 *     diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
 *     index f48f9d924a6216..0d6ad7512f217c 100644
 *     --- a/fs/btrfs/disk-io.c
 *     +++ b/fs/btrfs/disk-io.c
 *     @@ -2158,8 +2158,7 @@ static int load_global_roots_objectid(struct btrfs_root *tree_root,
 *      		found = true;
 *      		root = read_tree_root_path(tree_root, path, &key);
 *      		if (IS_ERR(root)) {
 *     -			if (!btrfs_test_opt(fs_info, IGNOREBADROOTS))
 *     -				ret = PTR_ERR(root);
 *     +			ret = PTR_ERR(root);
 *      			break;
 *      		}
 *      		set_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38260
 */
import cpp

from
  Function f,
  FunctionCall errorCall,
  IfStmt outerIf,
  IfStmt innerIf,
  Assignment criticalAssignment,
  VariableAccess root,
  AssignExpr ae
where
  // 步骤1: 将查询范围限定在目标函数和文件中
  f.hasGlobalName("load_global_roots_objectid") and
  f.getFile().getRelativePath().matches("fs/btrfs/disk-io.c") and

  // 步骤2: 在该函数中，找到对 'read_tree_root_path' 的调用
  errorCall.getTarget().hasGlobalName("read_tree_root_path") and
  errorCall.getEnclosingFunction() = f and
  ae.getRValue() = errorCall and
  ae.getLValue() = root and

  // 步骤3: 找到紧随其后检查该调用返回值的 'if' 语句 (if (IS_ERR(root)))
  // 使用CFG来确保 if 语句在调用之后，并且是其后继节点之一
  outerIf.getControlFlowScope() = errorCall.getControlFlowScope() and
  outerIf.getASuccessor*() = errorCall and
  // 检查条件是否为对 'IS_ERR' 的宏调用
  exists(FunctionCall isErrCall |
    isErrCall = outerIf.getCondition() and
    isErrCall.getTarget().getName() = "IS_ERR" and
    // 关键链接：确保 IS_ERR 的参数，就是 errorCall 返回值所赋给的那个变量
    isErrCall.getArgument(0).toString() = root.toString()
  ) and

  // 步骤4: 在这个外部 'if' 的 'then' 代码块中，找到一个嵌套的 'if' 语句
  innerIf.getParent*() = outerIf.getThen() and

  // 步骤5: 确认关键的错误处理操作（给 'ret' 变量赋值）只存在于嵌套 'if' 的内部
  criticalAssignment.getLValue().(VariableAccess).getTarget().getName() = "ret" and
  criticalAssignment.getParent*() = innerIf.getThen() and

  // 步骤6: (关键) 确认在外部 'if' 的 'then' 块中，但在嵌套 'if' 之外，
  // 不存在其他对 'ret' 的赋值操作。
  not exists(Assignment otherAssignment |
    otherAssignment.getLValue().(VariableAccess).getTarget().getName() = "ret" and
    otherAssignment.getParent*() = outerIf.getThen() and
    not otherAssignment.getParent*() = innerIf
  )

select outerIf, innerIf, criticalAssignment, "11"