import cpp

from
  Function f,
  FunctionCall errorCall,
  IfStmt outerIf,
  IfStmt innerIf,
  Assignment criticalAssignment,
  VariableAccess root,
  AssignExpr ae
where
  // 步骤1: 将查询范围限定在目标函数和文件中
  f.hasGlobalName("load_global_roots_objectid") and
  f.getFile().getRelativePath().matches("fs/btrfs/disk-io.c") and

  // 步骤2: 在该函数中，找到对 'read_tree_root_path' 的调用
  errorCall.getTarget().hasGlobalName("read_tree_root_path") and
  errorCall.getEnclosingFunction() = f and
  ae.getRValue() = errorCall and
  ae.getLValue() = root and

  // 步骤3: 找到紧随其后检查该调用返回值的 'if' 语句 (if (IS_ERR(root)))
  // 使用CFG来确保 if 语句在调用之后，并且是其后继节点之一
  outerIf.getControlFlowScope() = errorCall.getControlFlowScope() and
  outerIf.getASuccessor*() = errorCall and
  // 检查条件是否为对 'IS_ERR' 的宏调用
  exists(FunctionCall isErrCall |
    isErrCall = outerIf.getCondition() and
    isErrCall.getTarget().getName() = "IS_ERR" and
    // 关键链接：确保 IS_ERR 的参数，就是 errorCall 返回值所赋给的那个变量
    isErrCall.getArgument(0).toString() = root.toString()
  ) and

  // 步骤4: 在这个外部 'if' 的 'then' 代码块中，找到一个嵌套的 'if' 语句
  innerIf.getParent*() = outerIf.getThen() and

  // 步骤5: 确认关键的错误处理操作（给 'ret' 变量赋值）只存在于嵌套 'if' 的内部
  criticalAssignment.getLValue().(VariableAccess).getTarget().getName() = "ret" and
  criticalAssignment.getParent*() = innerIf.getThen() and

  // 步骤6: (关键) 确认在外部 'if' 的 'then' 块中，但在嵌套 'if' 之外，
  // 不存在其他对 'ret' 的赋值操作。
  not exists(Assignment otherAssignment |
    otherAssignment.getLValue().(VariableAccess).getTarget().getName() = "ret" and
    otherAssignment.getParent*() = outerIf.getThen() and
    not otherAssignment.getParent*() = innerIf
  )

select outerIf, innerIf, criticalAssignment