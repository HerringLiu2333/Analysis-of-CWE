/**
 * @name Swallowed ret status after bypassable error branch
 * @description Tracks value flow ret = 0 -> return ret when an IS_ERR/IS_ERR_OR_NULL branch's
 *              then-block can bypass any non-zero assignment to ret (none present OR all nested),
 *              suggesting a swallowed error update pattern.
 * @kind path-problem
 * @problem.severity warning
 * @precision medium
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow
import semmle.code.cpp.dataflow.new.TaintTracking

predicate isZeroLiteral(Expr e) { e instanceof Literal and e.getValue() = "0" }
predicate isNonZeroLiteral(Expr e) { e instanceof Literal and not e.getValue() = "0" }

predicate retZeroAssign(Expr e) {
  exists(AssignExpr a, VariableAccess va |
    a.getRValue() = e and a.getLValue() = va and va.getTarget().getName() = "ret" and isZeroLiteral(a.getRValue()))
}

predicate retNonZeroAssign(AssignExpr a) {
  a.getLValue() instanceof VariableAccess and a.getLValue().(VariableAccess).getTarget().getName() = "ret" and
  ( isNonZeroLiteral(a.getRValue()) or exists(FunctionCall fc | a.getRValue() = fc and fc.getTarget().getName() = "PTR_ERR") )
}

predicate isErrPred(FunctionCall c) { exists(string n | n = c.getTarget().getName() and n.regexpMatch("IS_ERR(_OR_NULL)?")) }
class ErrorIf extends IfStmt {}
predicate isErrorIf(ErrorIf i) { i.getCondition() instanceof FunctionCall and isErrPred(i.getCondition()) }

predicate bypassableRet(ErrorIf ei) {
  (not exists(AssignExpr a | a.getParent*() = ei.getThen() and retNonZeroAssign(a))) or
  (forall(AssignExpr a | a.getParent*() = ei.getThen() and retNonZeroAssign(a) |
     exists(IfStmt inner | a.getParent*() = inner.getThen() and inner.getParent*() = ei.getThen())))
}

predicate hasBypassErrorIf(Function f) {
  exists(ErrorIf ei | ei.getEnclosingFunction() = f and isErrorIf(ei) and bypassableRet(ei))
}

predicate retReturn(Expr e) {
  exists(ReturnStmt r, VariableAccess va | r.getExpr() = va and va.getTarget().getName() = "ret" and e = r.getExpr())
}

predicate barrierExpr(Expr e) {
  exists(AssignExpr a | retNonZeroAssign(a) and e = a.getRValue()) or
  exists(ReturnStmt r | r.getExpr() = e and isNonZeroLiteral(r.getExpr()))
}

predicate before(Expr e1, Expr e2) { e1.getFile() = e2.getFile() and e1.getLocation().getEndLine() < e2.getLocation().getStartLine() }

module RetFlowConfig implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node s) { exists(Expr e | retZeroAssign(e) and s.asExpr() = e) }
  predicate isSink(DataFlow::Node t) { exists(Expr e | retReturn(e) and t.asExpr() = e) }
  predicate isBarrier(DataFlow::Node b) { exists(Expr e | barrierExpr(e) and b.asExpr() = e) }
}

module RetFlow = TaintTracking::Global<RetFlowConfig>;
import RetFlow::PathGraph

from RetFlow::PathNode src, RetFlow::PathNode snk, Function f
where RetFlow::flowPath(src, snk) and src != snk
select snk.getNode(), src, snk,
  "ret remains 0 and is returned while a bypassable IS_ERR branch exists (potential swallowed error)."