/**
 * @name CVE-2024-57949
 * @description irqchip/gic-v3-its: its_irq_set_vcpu_affinity() used guard(raw_spinlock_irq)
 * inside a call chain that already disabled interrupts via irq_get_desc_lock()
 * (raw_spin_lock_irqsave). Exiting the guard re-enabled IRQs prematurely,
 * leading to "irq_put_desc_unlock()" warnings and broken IRQ state nesting.
 * The fix switches to guard(raw_spinlock) to avoid modifying IRQ state.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/gicv3-its-vlpi-lock-irq-guard
 * @tags
 * irqchip
 * gic-v3
 * its
 * locking
 * irq-flags
 * race-condition
 * robustness
 * @patch-commit d7b0e89610dd45ac6cf0d6f99bfa9ccc787db344
 * @source-file drivers/irqchip/irq-gic-v3-its.c
 * @affected-function its_irq_set_vcpu_affinity
 * @vulnerability-type incorrect IRQ state management (premature IRQ enable)
 * @patch-diff |
 * diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
 * index 30e60bcc3b4e0b...4f8512385870a8 100644
 * --- a/drivers/irqchip/irq-gic-v3-its.c
 * +++ b/drivers/irqchip/irq-gic-v3-its.c
 * @@ -1967,7 +1967,7 @@ static int its_irq_set_vcpu_affinity(struct irq_data *d, void vcpu_info)
 * 	if (!is_v4(its_dev->its))
 * 		return -EINVAL;
 *
 * -	guard(raw_spinlock_irq)(&its_dev->event_map.vlpi_lock);
 * +	guard(raw_spinlock)(&its_dev->event_map.vlpi_lock);
 *
 * 	/* Unmap request? &#47;
 * 	if (!info)
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=d7b0e89610dd45ac6cf0d6f99bfa9ccc787db344 
 * @remediation When taking a lock under a call chain that already used irqsave to disable
 * interrupts, do not use lock helpers that manipulate IRQ state (e.g. *_irq).
 * Use guard(raw_spinlock) (no IRQ state change) to maintain proper nesting and
 * prevent premature IRQ re-enable and related warnings.
 */



import cpp

// 查找特定的函数 its_irq_set_vcpu_affinity
predicate isTargetFunction(Function f) {
  f.getName() = "its_irq_set_vcpu_affinity"
}

// 查找 guard(raw_spinlock_irq) 调用
predicate isGuardRawSpinlockIrqCall(FunctionCall fc) {
  fc.getTarget().getName() = "guard" and
  exists(Expr arg | arg = fc.getArgument(0) |
    arg.toString().matches("%raw_spinlock_irq%")
  )
}

from
  FunctionCall guardCall, Function targetFunc
where
  isTargetFunction(targetFunc) and
  guardCall.getEnclosingFunction() = targetFunc and
  isGuardRawSpinlockIrqCall(guardCall)
select
  guardCall,
  "Potential interrupt enabling issue: guard(raw_spinlock_irq) used in its_irq_set_vcpu_affinity()" +
  ". This may enable interrupts in interrupt-disabled context."
  