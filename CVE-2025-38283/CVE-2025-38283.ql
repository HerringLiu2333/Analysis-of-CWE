/**
 * @name CVE-2025-38283
 * @description During VFIO live migration of Hisilicon ACC devices, DMA addresses are restored from migration data. If the VF driver was not loaded in the guest OS, these DMA addresses can be NULL. The function `vf_qm_load_data` on the destination host uses these addresses without a prior null check, leading to a null pointer dereference and host kernel panic.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/hisi-vfio-migration-npe
 * @tags security
 *       correctness
 *       null-pointer-dereference
 *       external/cwe/cwe-476
 * @patch-commit 2777a40998deb36f96b6afc48bd397cf58a4edf0
 * @source-file drivers/vfio/pci/hisilicon/hisi_acc_vfio_pci.c
 * @affected-function vf_qm_load_data
 * @kernel-config CONFIG_HISI_ACC_VFIO_PCI
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *     @@ -498,6 +491,20 @@ static int vf_qm_load_data(struct hisi_acc_vf_core_device *hisi_acc_vdev,
 *      	if (migf->total_length < sizeof(struct acc_vf_data))
 *      		return -EINVAL;
 *      
 *     +	if (!vf_data->eqe_dma || !vf_data->aeqe_dma ||
 *     +	    !vf_data->sqc_dma || !vf_data->cqc_dma) {
 *     +		dev_info(dev, "resume dma addr is NULL!\n");
 *     +		hisi_acc_vdev->vf_qm_state = QM_NOT_READY;
 *     +		return 0;
 *     +	}
 *     +
 *      	qm->eqe_dma = vf_data->eqe_dma;
 *      	qm->aeqe_dma = vf_data->aeqe_dma;
 *      	qm->sqc_dma = vf_data->sqc_dma;
 *     ...
 *     @@ -1531,6 +1538,7 @@ static int hisi_acc_vfio_pci_migrn_init_dev(struct vfio_device *core_vdev)
 *      	hisi_acc_vdev->vf_id = pci_iov_vf_id(pdev) + 1;
 *      	hisi_acc_vdev->pf_qm = pf_qm;
 *      	hisi_acc_vdev->vf_dev = pdev;
 *     +	hisi_acc_vdev->vf_qm_state = QM_NOT_READY;
 *      	mutex_init(&hisi_acc_vdev->state_mutex);
 *      	mutex_init(&hisi_acc_vdev->open_mutex);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38283
 * @remediation
 */

import cpp
import semmle.code.cpp.dataflow.new.TaintTracking
import semmle.code.cpp.controlflow.Guards
/**
 * 定义 CVE-2025-38283 的数据流分析配置
 */
module HisiVfioPciConfig implements DataFlow::ConfigSig {
predicate isSource(DataFlow::Node source) {
  exists(FieldAccess fa, Function f |
    source.asExpr() = fa and
    f = fa.getEnclosingFunction() and
    f.hasName("vf_qm_load_data") and
    fa.getTarget().getName().regexpMatch(".*_dma") and
    fa.getQualifier().(VariableAccess).getTarget().hasName("vf_data")
  )
}

  predicate isSink(DataFlow::Node sink) {
    exists(AssignExpr assign, FieldAccess lvalue |
      // 汇点是赋值操作的右侧 (RValue)
      sink.asExpr() = assign.getRValue() and
      // 添加限制条件
        lvalue = assign.getLValue() and
        lvalue.getEnclosingFunction().getName() = "vf_qm_load_data" and
        lvalue.getQualifier().(VariableAccess).getTarget().getName() = "qm"
    )
  }

  /**
   * 定义屏障 (Barrier)：即阻止污点流动的安全检查。
   * 此处我们手动识别空指针检查模式来替代 isCheckNull。
   */
  predicate isBarrier(DataFlow::Node node) {
    exists(IfStmt ifStmt |
      // 匹配 vf_qm_load_data 函数中的 if 语句
      ifStmt.getEnclosingFunction().getName() = "vf_qm_load_data" and
      // 确保 if 语句包含对 DMA 地址的检查
      exists(LogicalOrExpr orExpr | 
        orExpr = ifStmt.getCondition() and
        count(FieldAccess fa |
          fa.getTarget().getName().regexpMatch(".*_dma") and
          fa.getQualifier().(VariableAccess).getTarget().hasName("vf_data") and
          exists(NotExpr notExpr | notExpr.getOperand() = fa)
        ) >= 2
      ) and
      // 数据流节点位于 if 语句之后
      node.getLocation().getStartLine() > ifStmt.getLocation().getStartLine()
    )
  }
}



// 实例化上面定义的配置模块，用于全局污点跟踪
module HisiVfioPciFlow = TaintTracking::Global<HisiVfioPciConfig>;

// 导入专用的 PathGraph，用于后续的路径查询
import HisiVfioPciFlow::PathGraph

// from 子句定义查询的起点和终点
from HisiVfioPciFlow::PathNode source, HisiVfioPciFlow::PathNode sink
// where 子句查找从源到汇的完整数据流路径
where HisiVfioPciFlow::flowPath(source, sink)
// select 子句定义查询结果的展示格式
select sink.getNode(), source, sink,
  source.getNode()