import cpp
import semmle.code.cpp.dataflow.new.TaintTracking
import semmle.code.cpp.controlflow.Guards
/**
 * 定义 CVE-2025-38283 的数据流分析配置
 */
module HisiVfioPciConfig implements DataFlow::ConfigSig {
predicate isSource(DataFlow::Node source) {
  exists(FieldAccess fa, Function f |
    source.asExpr() = fa and
    f = fa.getEnclosingFunction() and
    f.hasName("vf_qm_load_data") and
    fa.getTarget().getName().regexpMatch(".*_dma") and
    fa.getQualifier().(VariableAccess).getTarget().hasName("vf_data")
  )
}

  predicate isSink(DataFlow::Node sink) {
    exists(AssignExpr assign, FieldAccess lvalue |
      // 汇点是赋值操作的右侧 (RValue)
      sink.asExpr() = assign.getRValue() and
      // 添加限制条件
        lvalue = assign.getLValue() and
        lvalue.getEnclosingFunction().getName() = "vf_qm_load_data" and
        lvalue.getQualifier().(VariableAccess).getTarget().getName() = "qm"
    )
  }

  /**
   * 定义屏障 (Barrier)：即阻止污点流动的安全检查。
   * 此处我们手动识别空指针检查模式来替代 isCheckNull。
   */
  predicate isBarrier(DataFlow::Node node) {
    exists(IfStmt ifStmt |
      // 匹配 vf_qm_load_data 函数中的 if 语句
      ifStmt.getEnclosingFunction().getName() = "vf_qm_load_data" and
      // 确保 if 语句包含对 DMA 地址的检查
      exists(LogicalOrExpr orExpr | 
        orExpr = ifStmt.getCondition() and
        count(FieldAccess fa |
          fa.getTarget().getName().regexpMatch(".*_dma") and
          fa.getQualifier().(VariableAccess).getTarget().hasName("vf_data") and
          exists(NotExpr notExpr | notExpr.getOperand() = fa)
        ) >= 2
      ) and
      // 数据流节点位于 if 语句之后
      node.getLocation().getStartLine() > ifStmt.getLocation().getStartLine()
    )
  }
}



// 实例化上面定义的配置模块，用于全局污点跟踪
module HisiVfioPciFlow = TaintTracking::Global<HisiVfioPciConfig>;

// 导入专用的 PathGraph，用于后续的路径查询
import HisiVfioPciFlow::PathGraph

// from 子句定义查询的起点和终点
from HisiVfioPciFlow::PathNode source, HisiVfioPciFlow::PathNode sink
// where 子句查找从源到汇的完整数据流路径
where HisiVfioPciFlow::flowPath(source, sink)
// select 子句定义查询结果的展示格式
select sink.getNode(), source, sink,
  source.getNode()