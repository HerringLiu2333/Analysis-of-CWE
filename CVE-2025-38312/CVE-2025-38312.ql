/**
 * @name CVE-2025-38312
 * @description In the fb_find_mode_cvt function, if the user-provided refresh rate is a large value (e.g., 0x80000000),
 *              a subsequent multiplication can cause an integer overflow, resulting in the calculated f_refresh becoming zero.
 *              This zero value is later used as a divisor, leading to a division-by-zero error and a kernel panic.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/integer-overflow-leads-to-division-by-zero
 * @tags security
 *       correctness
 *       kernel
 *       integer-overflow
 *       division-by-zero
 *       external/cwe/cwe-190
 *       external/cwe/cwe-369
 * @patch-commit 3f6dae09fc8c306eb70fdfef70726e1f154e173a
 * @source-file drivers/video/fbdev/core/fbcvt.c
 * @affected-function fb_find_mode_cvt
 * @kernel-config CONFIG_FB
 * @vulnerability-type integer-overflow, division-by-zero
 * @patch-diff |
 *     @@ -312,7 +312,7 @@ int fb_find_mode_cvt(struct fb_videomode *mode, int margins, int rb)
 *      	cvt.f_refresh = cvt.refresh;
 *      	cvt.interlace = 1;
 *      
 *     -	if (!cvt.xres || !cvt.yres || !cvt.refresh) {
 *     +	if (!cvt.xres || !cvt.yres || !cvt.refresh || cvt.f_refresh > INT_MAX) {
 *      		printk(KERN_INFO "fbcvt: Invalid input parameters\n");
 *      		return 1;
 *      	}
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38312
 * @remediation
 * @patch-description |
 *     fbdev: core: fbcvt: avoid division by 0 in fb_cvt_hperiod()
 *     In fb_find_mode_cvt(), iff mode->refresh somehow happens to be 0x80000000,
 *     cvt.f_refresh will become 0 when multiplying it by 2 due to overflow. It's
 *     then passed to fb_cvt_hperiod(), where it's used as a divider -- division
 *     by 0 will result in kernel oops. Add a sanity check for cvt.f_refresh to
 *     avoid such overflow...
 *     
 *     Found by Linux Verification Center (linuxtesting.org) with the Svace static
 *     analysis tool.
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow
import semmle.code.cpp.dataflow.new.TaintTracking

/**
 * 检查函数是否为fb_find_mode_cvt且在fbcvt.c文件中
 */
predicate isFbFindModeCvtFunction(Function f) {
  f.getName() = "fb_find_mode_cvt" and
  f.getFile().getBaseName() = "fbcvt.c"
}

/**
 * 检查函数是否为fb_cvt_hperiod且在fbcvt.c文件中
 */
predicate isFbCvtHperiodFunction(Function f) {
  f.getName() = "fb_cvt_hperiod" and
  f.getFile().getBaseName() = "fbcvt.c"
}

module FbCvtConfig implements DataFlow::ConfigSig {
  /**
   * 定义污点源：cvt.f_refresh = cvt.refresh 赋值语句
   * 这是漏洞的起始点，f_refresh字段被赋值但可能存在整数溢出风险
   */
  predicate isSource(DataFlow::Node source) {
    exists(AssignExpr assign, FieldAccess lhs, FieldAccess rhs |
      // 源头是赋值表达式
      source.asExpr() = assign.getRValue() and
      // 左值是f_refresh字段访问
      assign.getLValue() = lhs and
      lhs.getTarget().getName() = "f_refresh" and
      // 右值是refresh字段访问
      assign.getRValue() = rhs and
      rhs.getTarget().getName() = "refresh"
    )
  }

  /**
   * 定义污点汇：fb_cvt_hperiod函数中的除法操作
   * 这是漏洞的终点，f_refresh作为除数可能导致除零错误
   */
  predicate isSink(DataFlow::Node sink) {
    exists(DivExpr div, FieldAccess denominator |
      // 汇是除法表达式
      sink.asExpr() = div and
      // 除法的分母是f_refresh字段访问
      div.getRightOperand() = denominator and
      denominator.getTarget().getName() = "f_refresh"
    )
  }

  /**
   * 定义屏障：对f_refresh进行INT_MAX边界检查的验证语句
   * 如果存在适当的验证，则不认为是漏洞
   */
  predicate isBarrier(DataFlow::Node barrier) {
    exists(FieldAccess field, AssignExpr sourceAssign, IfStmt validationIf |
      barrier.asExpr() = field and
      field.getTarget().getName() = "f_refresh" and
      
      // 找到源赋值语句
      sourceAssign.getLValue().(FieldAccess).getTarget().getName() = "f_refresh" and
      
      // 找到验证if语句
      validationIf.getEnclosingFunction() = sourceAssign.getEnclosingFunction() and
      exists(LogicalOrExpr loe, GTExpr gt |
        validationIf.getCondition() = loe and
        loe.getAnOperand() = gt and
        gt.getAnOperand().toString() = "f_refresh"
      ) and
      
      // 验证必须在赋值之后
      // sourceAssign.getLocation().getEndLine() < validationIf.getLocation().getStartLine() and
      dominates(sourceAssign.getBasicBlock(), validationIf.getBasicBlock()) and
      
      // 验证必须有return
      exists(ReturnStmt ret | dominates(validationIf.getBasicBlock(), ret.getBasicBlock()))
    )
  }
}

// 使用配置模块实例化全局污点跟踪分析模块
module FbCvtFlow = TaintTracking::Global<FbCvtConfig>;

// 导入路径图用于路径查询
import FbCvtFlow::PathGraph

// 查询主体：查找从源点到汇点的污点传播路径
from FbCvtFlow::PathNode source, FbCvtFlow::PathNode sink
where 
  FbCvtFlow::flowPath(source, sink) and
  // 确保源点在fb_find_mode_cvt函数中
  source.getNode().asExpr().getEnclosingFunction().getName() = "fb_find_mode_cvt" and
  // 确保汇点在fb_cvt_hperiod函数中
  sink.getNode().asExpr().getEnclosingFunction().getName() = "fb_cvt_hperiod"
select sink.getNode(), source, sink,
  source.getNode() + " 的赋值操作流向 " +
  sink.getNode() + " 的除法操作，"