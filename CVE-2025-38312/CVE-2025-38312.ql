import cpp
import semmle.code.cpp.dataflow.new.DataFlow
import semmle.code.cpp.dataflow.new.TaintTracking

/**
 * 检查函数是否为fb_find_mode_cvt且在fbcvt.c文件中
 */
predicate isFbFindModeCvtFunction(Function f) {
  f.getName() = "fb_find_mode_cvt" and
  f.getFile().getBaseName() = "fbcvt.c"
}

/**
 * 检查函数是否为fb_cvt_hperiod且在fbcvt.c文件中
 */
predicate isFbCvtHperiodFunction(Function f) {
  f.getName() = "fb_cvt_hperiod" and
  f.getFile().getBaseName() = "fbcvt.c"
}

module FbCvtConfig implements DataFlow::ConfigSig {
  /**
   * 定义污点源：cvt.f_refresh = cvt.refresh 赋值语句
   * 这是漏洞的起始点，f_refresh字段被赋值但可能存在整数溢出风险
   */
  predicate isSource(DataFlow::Node source) {
    exists(AssignExpr assign, FieldAccess lhs, FieldAccess rhs, Function f |
      // 源头是赋值表达式
      source.asExpr() = assign.getRValue() and
      // 左值是f_refresh字段访问
      assign.getLValue() = lhs and
      lhs.getTarget().getName() = "f_refresh" and
      // 右值是refresh字段访问
      assign.getRValue() = rhs and
      rhs.getTarget().getName() = "refresh" and
      // 必须在fb_find_mode_cvt函数内部且在fbcvt.c文件中
      assign.getEnclosingFunction() = f and
      isFbFindModeCvtFunction(f)
    )
  }

  /**
   * 定义污点汇：fb_cvt_hperiod函数中的除法操作
   * 这是漏洞的终点，f_refresh作为除数可能导致除零错误
   */
  predicate isSink(DataFlow::Node sink) {
    exists(DivExpr div, FieldAccess denominator, Function f |
      // 汇是除法表达式
      sink.asExpr() = div and
      // 除法的分母是f_refresh字段访问
      div.getRightOperand() = denominator and
      denominator.getTarget().getName() = "f_refresh" and
      // 必须在fb_cvt_hperiod函数内部且在fbcvt.c文件中
      f = div.getEnclosingFunction() and
      isFbCvtHperiodFunction(f)
    )
  }

  /**
   * 定义屏障：对f_refresh进行INT_MAX边界检查的验证语句
   * 如果存在适当的验证，则不认为是漏洞
   */
  predicate isBarrier(DataFlow::Node barrier) {
    exists(FieldAccess field, AssignExpr sourceAssign, IfStmt validationIf |
      barrier.asExpr() = field and
      field.getTarget().getName() = "f_refresh" and
      
      // 找到源赋值语句
      sourceAssign.getLValue().(FieldAccess).getTarget().getName() = "f_refresh" and
      isFbFindModeCvtFunction(sourceAssign.getEnclosingFunction()) and
      
      // 找到验证if语句
      validationIf.getEnclosingFunction() = sourceAssign.getEnclosingFunction() and
      exists(LogicalOrExpr loe, GTExpr gt |
        validationIf.getCondition() = loe and
        loe.getAnOperand() = gt and
        gt.getAnOperand().toString() = "f_refresh"
      ) and
      
      // 验证必须在赋值之后
      // sourceAssign.getLocation().getEndLine() < validationIf.getLocation().getStartLine() and
      dominates(sourceAssign.getBasicBlock(), validationIf.getBasicBlock()) and
      
      // 验证必须有return
      exists(ReturnStmt ret | dominates(validationIf.getBasicBlock(), ret.getBasicBlock()))
    )
  }
}

// 使用配置模块实例化全局污点跟踪分析模块
module FbCvtFlow = TaintTracking::Global<FbCvtConfig>;

// 导入路径图用于路径查询
import FbCvtFlow::PathGraph

// 查询主体：查找从源点到汇点的污点传播路径
from FbCvtFlow::PathNode source, FbCvtFlow::PathNode sink
where 
  FbCvtFlow::flowPath(source, sink) and
  // 确保源点在fb_find_mode_cvt函数中
  source.getNode().asExpr().getEnclosingFunction().getName() = "fb_find_mode_cvt" and
  // 确保汇点在fb_cvt_hperiod函数中
  sink.getNode().asExpr().getEnclosingFunction().getName() = "fb_cvt_hperiod"
select sink.getNode(), source, sink,
  source.getNode() + " 的赋值操作流向 " +
  sink.getNode() + " 的除法操作，"