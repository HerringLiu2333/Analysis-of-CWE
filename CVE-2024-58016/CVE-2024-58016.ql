/**
 * @name CVE-2024-58016
 * @description safesetid's policy update handler did not validate the size of the write
 *              buffer from userspace. syzbot could pass an extremely large 'len' to the
 *              securityfs write path handled by handle_policy_update(), triggering kmalloc()
 *              warnings and risking excessive allocation attempts. The fix rejects writes
 *              with len >= KMALLOC_MAX_SIZE before any allocation.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/safesetid-policy-write-size-check
 * @tags
 *   security
 *   lsm
 *   safesetid
 *   securityfs
 *   input-validation
 *   memory-allocation
 *   dos
 * @patch-commit f09ff307c7299392f1c88f763299e24bc99811c7
 * @source-file security/safesetid/securityfs.c
 * @affected-function handle_policy_update
 * @vulnerability-type improper-input-validation
 * @patch-diff
 *   diff --git a/security/safesetid/securityfs.c b/security/safesetid/securityfs.c
 *   index 25310468bcddff..8e1ffd70b18ab4 100644
 *   --- a/security/safesetid/securityfs.c
 *   +++ b/security/safesetid/securityfs.c
 *   @@ -143,6 +143,9 @@ static ssize_t handle_policy_update(struct file *file,
 *           char *buf, *p, *end;
 *           int err;
 *   
 *   +       if (len >= KMALLOC_MAX_SIZE)
 *   +               return -EINVAL;
 *   +
 *           pol = kmalloc(sizeof(struct setid_ruleset), GFP_KERNEL);
 *           if (!pol)
 *                   return -ENOMEM;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f09ff307c7299392f1c88f763299e24bc99811c7
 * @remediation Validate the userspace-provided write length before allocating buffers. Reject
 *              oversized writes (e.g., len >= KMALLOC_MAX_SIZE) with -EINVAL to avoid allocator
 *              warnings and potential memory pressure or denial-of-service conditions.
 */




import cpp

from FunctionCall kmallocCall, Parameter sizeParam
where
  // 查找kmalloc调用
  kmallocCall.getTarget().getName() = "kmalloc" and
  // 获取大小参数（通常是第一个参数）
  exists(VariableAccess sizeAccess |
    sizeAccess = kmallocCall.getArgument(0) and
    sizeAccess.getTarget() = sizeParam
  ) and
  // 检查在kmalloc之前没有对大小参数进行边界检查
  not exists(IfStmt sizeCheck |
    sizeCheck.getCondition().getAChild*() = sizeParam.getAnAccess() and
    (sizeCheck.getCondition().toString().matches("%>=%") or
     sizeCheck.getCondition().toString().matches("%>%")) and
    (sizeCheck.getCondition().toString().matches("%KMALLOC_MAX_SIZE%") or
     sizeCheck.getCondition().toString().matches("%PAGE_SIZE%")) and
    sizeCheck.getLocation().getStartLine() < kmallocCall.getLocation().getStartLine()
  )
select kmallocCall, "Missing size validation before kmalloc: parameter '" + sizeParam.getName() + "' should be checked against KMALLOC_MAX_SIZE"