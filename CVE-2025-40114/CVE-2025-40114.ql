/**
 * @name CVE-2025-40114
 * @description The function `veml6075_read_int_time_index` reads an index value from a hardware register.
 *              This index is later used to access the `veml6075_it_ms` array. However, the code
 *              lacks a check to ensure that the index is within the valid bounds of the array.
 *              Potentially broken hardware could provide an index value between 0 and 7, while
 *              the array size is only 5, leading to an out-of-bounds read.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/out-of-bounds-read-from-hardware
 * @tags security
 *       correctness
 *       external/cwe/cwe-125
 *       external/cwe/cwe-129
 * @patch-commit ee735aa33db16c1fb5ebccbaf84ad38f5583f3cc
 * @source-file drivers/iio/light/veml6075.c
 * @affected-function veml6075_read_int_time_index
 * @kernel-config CONFIG_VEML6075
 * @vulnerability-type out-of-bounds-read
 * @patch-diff |
 *      @@ -195,13 +195,17 @@ static int veml6075_read_uv_direct(struct veml6075_data *data, int chan,
 *       
 *       static int veml6075_read_int_time_index(struct veml6075_data *data)
 *       {
 *      -	int ret, conf;
 *      +	int ret, conf, int_index;
 *       
 *       	ret = regmap_read(data->regmap, VEML6075_CMD_CONF, &conf);
 *       	if (ret < 0)
 *       		return ret;
 *       
 *      -	return FIELD_GET(VEML6075_CONF_IT, conf);
 *      +	int_index = FIELD_GET(VEML6075_CONF_IT, conf);
 *      +	if (int_index >= ARRAY_SIZE(veml6075_it_ms))
 *      +		return -EINVAL;
 *      +
 *      +	return int_index;
 *       }
 *       
 *       static int veml6075_read_int_time_ms(struct veml6075_data *data, int *val)
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-40114
 * @remediation
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow

/**
 * 表示可能来自外部硬件的不可信输入源
 */
abstract class HardwareInputSource extends DataFlow::Node {
}

/**
 * regmap_read函数调用 - 从硬件寄存器读取数据
 */
class RegmapReadSource extends HardwareInputSource {
  RegmapReadSource() {
    exists(FunctionCall fc |
      fc.getTarget().getName() = "regmap_read" and
      this.asExpr() = fc
    )
  }
}

/**
 * FIELD_GET宏调用 - 从寄存器值中提取字段
 */
class FieldGetSource extends HardwareInputSource {
  FieldGetSource() {
    exists(MacroInvocation mi |
      mi.getMacroName() = "FIELD_GET" and
      this.asExpr() = mi.getExpr()
    )
  }
}

/**
 * 函数调用返回值 - veml6075_read_int_time_index等函数
 */
class HardwareReadFunctionSource extends HardwareInputSource {
  HardwareReadFunctionSource() {
    exists(FunctionCall fc |
      fc.getTarget().getName().matches(".*read.*int.*time.*index") and
      this.asExpr() = fc
    )
  }
}

/**
 * 数组访问汇聚点 - 使用索引访问数组的地方
 */
abstract class ArrayIndexSink extends DataFlow::Node {
}

/**
 * 直接的数组索引访问
 */
class DirectArrayIndexSink extends ArrayIndexSink {
  DirectArrayIndexSink() {
    exists(ArrayExpr ae |
      this.asExpr() = ae.getArrayOffset() and
      // 确保访问的是静态数组（如veml6075_it_ms）
      exists(Variable v |
        ae.getArrayBase().(VariableAccess).getTarget() = v and
        v.getType() instanceof ArrayType
      )
    )
  }
}

/**
 * 位移运算中的索引使用（如 2 << index）
 */
class ShiftIndexSink extends ArrayIndexSink {
  ShiftIndexSink() {
    exists(LShiftExpr shift |
      this.asExpr() = shift.getRightOperand()
    )
  }
}

/**
 * 检测ARRAY_SIZE宏的使用（包括宏展开后的形式）
 */
predicate isArraySizeCheck(Expr expr, Variable arrayVar) {
  // ARRAY_SIZE宏展开后的形式: sizeof(array)/sizeof(array[0])
  exists(DivExpr divExpr, SizeofExprOperator sizeofArray, SizeofExprOperator sizeofElement |
    expr = divExpr and
    sizeofArray = divExpr.getLeftOperand() and
    sizeofElement = divExpr.getRightOperand() and
    // sizeof(array)
    sizeofArray.getExprOperand().(VariableAccess).getTarget() = arrayVar and
    // sizeof(array[0]) 或 sizeof(*array)
    (
      sizeofElement.getExprOperand().(ArrayExpr).getArrayBase().(VariableAccess).getTarget() = arrayVar
      or
      sizeofElement.getExprOperand().(PointerDereferenceExpr).getOperand().(VariableAccess).getTarget() = arrayVar
    )
  )
}

/**
 * 获取数组访问中的数组变量
 */
Variable getArrayVariable(DataFlow::Node sink) {
  exists(ArrayExpr ae |
    sink.asExpr() = ae.getArrayOffset() and
    result = ae.getArrayBase().(VariableAccess).getTarget()
  )
}

/**
 * 检查是否存在对索引的边界检查
 */
predicate hasIndexBoundsCheck(DataFlow::Node source, DataFlow::Node sink) {
  exists(IfStmt ifStmt, RelationalOperation relOp, Variable arrayVar |
    arrayVar = getArrayVariable(sink) and
    ifStmt.getCondition() = relOp and
    ifStmt.getLocation().getFile() = sink.asExpr().getLocation().getFile() and
    ifStmt.getLocation().getStartLine() < sink.asExpr().getLocation().getStartLine() and
    (
      // 检查 index >= ARRAY_SIZE(array) 并返回错误
      (relOp.getLeftOperand() = source.asExpr() and
       relOp.getOperator() = ">=" and
       isArraySizeCheck(relOp.getRightOperand(), arrayVar)
      ) or
      // 检查 index < ARRAY_SIZE(array)
      (relOp.getLeftOperand() = source.asExpr() and
       relOp.getOperator() = "<" and
       isArraySizeCheck(relOp.getRightOperand(), arrayVar)
      )
    )
  )
}

/**
 * 检查变量赋值时是否有边界检查
 */
predicate hasAssignmentBoundsCheck(DataFlow::Node source, DataFlow::Node sink) {
  exists(AssignExpr assign, Variable indexVar, IfStmt ifStmt, GEExpr relOp, VariableAccess arrayVar |
    arrayVar.toString() = "veml6075_it_ms" and
    // source流向赋值表达式
    assign.getRValue() = source.asExpr() and
    assign.getLValue().(VariableAccess).getTarget() = indexVar and
    // 在赋值后有边界检查
    ifStmt.getCondition() = relOp and
    ifStmt.getLocation().getStartLine() > assign.getLocation().getStartLine() and
    ifStmt.getEnclosingFunction() = assign.getEnclosingFunction() and
    (
      // 检查 index >= ARRAY_SIZE(array)
      (relOp.getLeftOperand().(VariableAccess).getTarget() = indexVar and
       relOp.getOperator() = ">=" and
       isArraySizeCheck(relOp.getRightOperand().(AddExpr).getLeftOperand(), arrayVar.getTarget())
      ) or
      // 检查 index < ARRAY_SIZE(array)
      (relOp.getLeftOperand().(VariableAccess).getTarget() = indexVar and
       relOp.getOperator() = "<" and
       isArraySizeCheck(relOp.getRightOperand().(AddExpr).getLeftOperand(), arrayVar.getTarget())
      )
    )
  )
}

/**
 * 数据流配置：从硬件输入源到数组索引使用
 */
module HardwareToArrayIndexConfig implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    source instanceof HardwareInputSource
  }

  predicate isSink(DataFlow::Node sink) {
    sink instanceof ArrayIndexSink
  }

  predicate isBarrier(DataFlow::Node node) {
    // 如果存在边界检查，则作为屏障阻止数据流
    exists(DataFlow::Node otherNode |
      hasIndexBoundsCheck(node, otherNode) or
      hasAssignmentBoundsCheck(node, otherNode)
    )
  }
}

module HardwareToArrayIndexFlow = DataFlow::Global<HardwareToArrayIndexConfig>;

from 
  DataFlow::Node source, 
  DataFlow::Node sink,
  Variable arrayVar
where
  HardwareToArrayIndexFlow::flow(source, sink) and
  arrayVar = getArrayVariable(sink) and
  // 额外检查：确保没有适当的边界检查
  // not hasIndexBoundsCheck(source, sink) and
  not hasAssignmentBoundsCheck(source, sink)

select source, sink,
  "数组越界访问漏洞: 来自硬件的未验证数据 $@ 被用作数组索引访问 $@，可能导致越界访问。" +
  "建议在使用索引前添加边界检查，如: if (index >= ARRAY_SIZE(array)) return -EINVAL;",
  source, "硬件输入源",
  arrayVar, arrayVar.getName()