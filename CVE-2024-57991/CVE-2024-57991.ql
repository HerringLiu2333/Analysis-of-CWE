/**
 * @name CVE-2024-57991
 * @description wifi: rtw89: rtw89_entity_recalc_mgnt_roles() could spin in list iteration,
 *              leading to a soft lockup. When a target pattern was found, the code reordered
 *              the list and used 'break', which only exited the inner for-loop, while the
 *              outer list_for_each_entry continued. In special cases this could loop forever
 *              and trigger a watchdog soft lockup. The fix uses 'goto fill' to break out of
 *              the outer iteration and proceed to the fill stage.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/rtw89-entity-recalc-soft-lockup-break-out-of-loop
 * @tags
 *       wifi
 *       rtw89
 *       control-flow
 *       list-iteration
 *       soft-lockup
 *       watchdog
 * @patch-commit e4790b3e314a4814f1680a5dc552031fb199b878
 * @source-file drivers/net/wireless/realtek/rtw89/chan.c
 * @affected-function rtw89_entity_recalc_mgnt_roles
 * @vulnerability-type logic-bug/soft-lockup
 * @patch-diff |
 *     diff --git a/drivers/net/wireless/realtek/rtw89/chan.c b/drivers/net/wireless/realtek/rtw89/chan.c
 *     index abc78716596d00..c06d305519df46 100644
 *     --- a/drivers/net/wireless/realtek/rtw89/chan.c
 *     +++ b/drivers/net/wireless/realtek/rtw89/chan.c
 *     @@ -391,11 +391,12 @@ static void rtw89_entity_recalc_mgnt_roles(struct rtw89_dev *rtwdev)
 *      
 *      				list_del(&role->mgnt_entry);
 *      				list_add(&role->mgnt_entry, &mgnt->active_list);
 *     -				break;
 *     +				goto fill;
 *      			}
 *      		}
 *      	}
 *      
 *     +fill:
 *      	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
 *      		if (unlikely(pos >= RTW89_MAX_INTERFACE_NUM)) {
 *      			rtw89_warn(rtwdev,
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e4790b3e314a4814f1680a5dc552031fb199b878 
 * @remediation When reordering list entries upon finding the target pattern, ensure the outer
 *              iteration is terminated as well. Use a labeled goto (or restructure control flow)
 *              to exit the outer list_for_each_entry loop and continue with the next phase,
 *              preventing infinite loops and soft lockups.
 * @patch-description |
 *  wifi: rtw89: chan: fix soft lockup in rtw89_entity_recalc_mgnt_roles()
 *  During rtw89_entity_recalc_mgnt_roles(), there is a normalizing process
 *  which will re-order the list if an entry with target pattern is found.
 *  And once one is found, should have aborted the list_for_each_entry. But,
 *  `break` just aborted the inner for-loop. The outer list_for_each_entry
 *  still continues. Normally, only the first entry will match the target
 *  pattern, and the re-ordering will change nothing, so there won't be
 *  soft lockup. However, in some special cases, soft lockup would happen.
 *
 *  Fix it by `goto fill` to break from the list_for_each_entry.
 *
 *  The following is a sample of kernel log for this problem.
 *  
 *  watchdog: BUG: soft lockup - CPU#1 stuck for 26s! [wpa_supplicant:2055]
 *  [...]
 *  RIP: 0010:rtw89_entity_recalc ([...] chan.c:392 chan.c:479) rtw89_core
 *  [...]
 *  
 *  Fixes: 68ec751b2881 ("wifi: rtw89: chan: manage active interfaces")
 */



import cpp

from
  BreakStmt breakStmt
where
  // 查找break语句在循环中
  exists(Stmt innerLoop |
    breakStmt.getEnclosingStmt() = innerLoop and
    (innerLoop.toString().matches("%for.*%") or innerLoop.toString().matches("%while.*%")) and
    // 查找外层循环
    exists(Stmt outerLoop |
      innerLoop.getParent*() = outerLoop and
      outerLoop != innerLoop and
      (outerLoop.toString().matches("%for.*%") or outerLoop.toString().matches("%while.*%")) and
      // 检查外层循环是列表遍历
      outerLoop.toString().matches("%list%")
    )
  )
select
  breakStmt,
  "Potential soft lockup: break at line " + breakStmt.getLocation().getStartLine() +
  " only breaks inner loop. In nested list traversals, use goto to break outer loop.",
  breakStmt.getEnclosingFunction(),
  "Function: " + breakStmt.getEnclosingFunction().getName()