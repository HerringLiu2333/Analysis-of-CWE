```markdown
### **## 根因描述**

根因在于错误使用 break 仅退出了内层 for 循环，未退出外层的 list_for_each_entry 遍历。当找到目标模式并对链表进行“重排”（list_del + list_add）后，外层遍历仍继续在被修改的链表上迭代，可能反复命中并不断重排，从而形成忙等循环，最终触发 soft lockup。

- 触发条件：
  - 正常情况下只有第一个元素匹配，重排不改变顺序，误用 break 不显现问题。
  - 特定场景下（匹配位置、链表状态等组合），重排导致外层遍历继续反复处理同一节点或形成循环迭代，CPU 长时间卡住，watchdog 报告 soft lockup。

- 正确行为：
  - 一旦找到目标并完成一次重排，应立即停止外层遍历，转入后续填充阶段。

### 被修改的代码

```c
@@ -391,11 +391,12 @@ static void rtw89_entity_recalc_mgnt_roles(struct rtw89_dev *rtwdev)

 				list_del(&role->mgnt_entry);
 				list_add(&role->mgnt_entry, &mgnt->active_list);
-				break;
+				goto fill;
 			}
 		}
 	}

+fill:
 	list_for_each_entry(role, &mgnt->active_list, mgnt_entry) {
 		if (unlikely(pos >= RTW89_MAX_INTERFACE_NUM)) {
 			rtw89_warn(rtwdev,
```

- 修改原因：
  - 旧代码的缺陷：
    1. break 仅退出内层 for，外层 list_for_each_entry 继续在已修改的链表上迭代，可能导致反复重排、忙等。
    2. 在特定链表状态下易造成死循环式的高占用迭代，触发 soft lockup。
  - 新代码的修复：
    1. 用 goto fill 跳转，直接退出外层遍历，进入后续填充逻辑，避免在已重排链表上继续迭代。
    2. 最小化改动，保持原有逻辑与意图，仅修正控制流范围。

### **## 总结**

- 问题类型：控制流错误（嵌套循环退出不当）导致的忙等/soft lockup
- 根本缺陷：仅退出内层循环，未终止外层 list 遍历，且在遍历中修改了链表
- 修复原理：使用 goto 直接跳出外层遍历（至 fill 标签），避免在重排后的链表上继续迭代
```