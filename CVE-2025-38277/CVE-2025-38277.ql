/**
 * @name CVE-2025-38277
 * @description Detects the use of a local variable that may not be initialized on all paths.
 *              If the loop processing ECC steps is skipped, the variable 'ret' remains
 *              uninitialized and its subsequent use leads to undefined behavior.
 * @kind path-problem
 * @problem.severity error
 * @precision high
 * @id cpp/uninitialized-variable-ret-mxic
 * @tags security
 *       correctness
 *       external/cwe/cwe-457
 * @patch-commit d95846350aac72303036a70c4cdc69ae314aa26d
 * @source-file drivers/mtd/nand/ecc-mxic.c
 * @affected-function mxic_ecc_finish_io_req_external
 * @kernel-config CONFIG_MTD_NAND_MXIC
 * @vulnerability-type use-after-free
 * @patch-diff |
 *     @@ -614,7 +614,7 @@ static int mxic_ecc_finish_io_req_external(struct nand_device *nand,
 *      {
 *      	struct mxic_ecc_engine *mxic = nand_to_mxic(nand);
 *      	struct mxic_ecc_ctx *ctx = nand_to_ecc_ctx(nand);
 *     -	int nents, step, ret;
 *     +	int nents, step, ret = 0;
 *      
 *      	if (req->mode == MTD_OPS_RAW)
 *      		return 0;
 * @references https://nvd.nist.gov/vuln/detail/CVE-2025-38277
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow

module UninitializedRetConfig implements DataFlow::ConfigSig {
  /**
   * 定义源头：即 'ret' 变量的声明，因为它没有初始化器。
   */
    predicate isSource(DataFlow::Node source) {
    exists(DeclStmt decl, VariableDeclarationEntry vde, Variable v |
        decl.getEnclosingFunction().hasName("mxic_ecc_finish_io_req_external") and
        decl.getFile().getBaseName() = "ecc-mxic.c" and

        vde = decl.getADeclarationEntry() and
        v = vde.getVariable() and
        v.getName() = "ret" and

        // 如果你要绑定初始化器
        source.asVariable() = vde.getVariable()
        )
    }

    /**
     * 定义汇点：即函数返回 `ret` 的地方。
     */
    predicate isSink(DataFlow::Node sink) {
    exists(ReturnStmt retStmt, Expr e, Variable v, Function f |
        // 限定函数范围
        f.hasName("mxic_ecc_finish_io_req_external") and
        f.getFile().getBaseName() = "ecc-mxic.c" and
        retStmt.getEnclosingFunction() = f and

        // 返回表达式是变量 e
        e = retStmt.getExpr() and
        e instanceof VariableAccess and
        v = e.(VariableAccess).getTarget() and
        v.getName() = "ret" and

        // 绑定 sink 到 return 语句的表达式上
        sink.asExpr() = e
    )
    }

  /**
   * 定义屏障：即任何对变量进行赋值的操作。
   * 这会“净化”变量，使其不再处于“未初始化”状态。
   */
  predicate isBarrier(DataFlow::Node barrier) {
    // 屏障节点是任何赋值表达式的左侧（被赋值的一方）
    exists(AssignExpr assign | barrier.asExpr() = assign.getLValue())
  }
}

// 实例化一个全局数据流分析模块
module UninitializedRetFlow = DataFlow::Global<UninitializedRetConfig>;

// 从实例化的模块中导入 PathGraph，用于路径查询
import UninitializedRetFlow::PathGraph

// from子句使用我们实例化的模块中的路径节点
from UninitializedRetFlow::PathNode source, UninitializedRetFlow::PathNode sink
// where子句调用我们实例化的模块中的 flowPath 谓词来查找路径
where UninitializedRetFlow::flowPath(source, sink)
// select子句用于格式化输出结果
select sink.getNode(), source, sink,
  "Variable 'ret' may be returned uninitialized on some paths." 