/**
 * @name CVE-2025-38349
 * @description Detects a use-after-free vulnerability in the epoll implementation.
 *              The `mutex_unlock()` function may still access the mutex structure after the lock
 *              has been internally released. If an object's reference count is decremented
 *              before calling `mutex_unlock()`, another thread can acquire the lock, decrement
 *              the final reference count, and free the containing object. This creates a race
 *              condition where the original thread's `mutex_unlock()` will access freed memory.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/use-after-free-in-unlock
 * @tags security
 *       correctness
 *       concurrency
 *       race-condition
 *       use-after-free
 *       external/cwe/cwe-362
 *       external/cwe/cwe-416
 *       external/cwe/cwe-667
 * @patch-commit 8c2e52ebbe885c7eeaabd3b7ddcdc1246fc400d2
 * @source-file fs/eventpoll.c
 * @affected-function ep_clear_and_put
 * @kernel-config CONFIG_EPOLL
 * @vulnerability-type race-condition, use-after-free
 * @patch-diff |
 *     diff --git a/fs/eventpoll.c b/fs/eventpoll.c
 *     index a97a771a459c9c..895256cd2786e2 100644
 *     --- a/fs/eventpoll.c
 *     +++ b/fs/eventpoll.c
 *     @@ -828,7 +828,7 @@ static bool __ep_remove(struct eventpoll *ep, struct epitem *epi, bool force)
 *      	kfree_rcu(epi, rcu);
 *      
 *      	percpu_counter_dec(&ep->user->epoll_watches);
 *     -	return ep_refcount_dec_and_test(ep);
 *     +	return true;
 *      }
 *      
 *      /*
 *     @@ -836,14 +836,14 @@ static bool __ep_remove(struct eventpoll *ep, struct epitem *epi, bool force)
 *       *&#47;
 *      static void ep_remove_safe(struct eventpoll *ep, struct epitem *epi)
 *      {
 *     -	WARN_ON_ONCE(__ep_remove(ep, epi, false));
 *     +	if (__ep_remove(ep, epi, false))
 *     +		WARN_ON_ONCE(ep_refcount_dec_and_test(ep));
 *      }
 *      
 *      static void ep_clear_and_put(struct eventpoll *ep)
 *      {
 *      	struct rb_node *rbp, *next;
 *      	struct epitem *epi;
 *     -	bool dispose;
 *      
 *      	/* We need to release all tasks waiting for these file *&#47;
 *      	if (waitqueue_active(&ep->poll_wait))
 *     @@ -876,10 +876,8 @@ static void ep_clear_and_put(struct eventpoll *ep)
 *      		cond_resched();
 *      	}
 *      
 *     -	dispose = ep_refcount_dec_and_test(ep);
 *      	mutex_unlock(&ep->mtx);
 *     -
 *     -	if (dispose)
 *     +	if (ep_refcount_dec_and_test(ep))
 *      		ep_free(ep);
 *      }
 *      
 *     @@ -1100,7 +1098,7 @@ again:
 *      		dispose = __ep_remove(ep, epi, true);
 *      		mutex_unlock(&ep->mtx);
 *      
 *     -		if (dispose)
 *     +		if (dispose && ep_refcount_dec_and_test(ep))
 *      			ep_free(ep);
 *      		goto again;
 *      	}
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38349
 * @references https://www.kernel.org/doc/Documentation/locking/mutex-design.rst
 * @remediation
 * @patch-description |
 *     eventpoll: don't decrement ep refcount while still holding the ep mutex
 *     Jann Horn points out that epoll is decrementing the ep refcount and then
 *     doing a
 *     
 *         mutex_unlock(&ep->mtx);
 *     
 *     afterwards. That's very wrong, because it can lead to a use-after-free.
 *     
 *     That pattern is actually fine for the very last reference, because the
 *     code in question will delay the actual call to "ep_free(ep)" until after
 *     it has unlocked the mutex.
 *     
 *     But it's wrong for the much subtler "next to last" case when somebody
 *     *else* may also be dropping their reference and free the ep while we're
 *     still using the mutex.
 *     
 *     Note that this is true even if that other user is also using the same ep
 *     mutex: mutexes, unlike spinlocks, can not be used for object ownership,
 *     even if they guarantee mutual exclusion.
 *     
 *     A mutex "unlock" operation is not atomic, and as one user is still
 *     accessing the mutex as part of unlocking it, another user can come in
 *     and get the now released mutex and free the data structure while the
 *     first user is still cleaning up.
 *     
 *     See our mutex documentation in Documentation/locking/mutex-design.rst,
 *     in particular the section [1] about semantics:
 *     
 *     	"mutex_unlock() may access the mutex structure even after it has
 *     	 internally released the lock already - so it's not safe for
 *     	 another context to acquire the mutex and assume that the
 *     	 mutex_unlock() context is not using the structure anymore"
 *     
 *     So if we drop our ep ref before the mutex unlock, but we weren't the
 *     last one, we may then unlock the mutex, another user comes in, drops
 *     _their_ reference and releases the 'ep' as it now has no users - all
 *     while the mutex_unlock() is still accessing it.
 *     
 *     Fix this by simply moving the ep refcount dropping to outside the mutex:
 *     the refcount itself is atomic, and doesn't need mutex protection (that's
 *     the whole _point_ of refcounts: unlike mutexes, they are inherently
 *     about object lifetimes).
 */

import cpp

// 定义互斥锁解锁函数调用
class MutexUnlockCall extends FunctionCall {
  MutexUnlockCall() {
    this.getTarget().getName() = "mutex_unlock"
  }
  
  // 获取被解锁的互斥锁参数
  string getMutexArg() {
    result = this.getArgument(0).(AddressOfExpr).getOperand().(PointerFieldAccess).getQualifier().toString()
  }
}

// 定义引用计数递减测试函数调用
class RefCountDecCall extends FunctionCall {
  RefCountDecCall() {
    this.getTarget().getName() = "ep_refcount_dec_and_test"
  }
  
  // 获取引用计数操作的对象参数
  string getRefCountArg() {
    result = this.getArgument(0).toString()
  }
}

// 定义对象释放函数调用
class ObjectFreeCall extends FunctionCall {
  ObjectFreeCall() {
    this.getTarget().getName() = "ep_free"
  }
}

// 检查在同一个函数中，引用计数递减是否在mutex_unlock之前执行
predicate refCountDecBeforeMutexUnlock(RefCountDecCall refcall, MutexUnlockCall unlockcall) {
  exists(Function f |
    refcall.getEnclosingFunction() = f and
    unlockcall.getEnclosingFunction() = f and
    // 检查引用计数递减调用在解锁调用之前
    dominates(refcall.getBasicBlock(), unlockcall.getBasicBlock()) and
    // 检查是否操作同一个对象
    unlockcall.getMutexArg() = refcall.getRefCountArg()
  )
}

// 检查是否存在条件释放模式
predicate hasConditionalFreePattern(RefCountDecCall refcall) {
  exists(IfStmt ifstmt, ObjectFreeCall freecall |
    // 检查引用计数递减调用是否在if条件中
    ifstmt.getCondition() = refcall and
    // 检查if语句体中是否有对象释放调用
    freecall.getEnclosingStmt().getParent*() = ifstmt.getThen()
  )
  or
  exists(ConditionalExpr condexpr, ObjectFreeCall freecall |
    // 检查三元表达式中的条件释放模式
    condexpr.getCondition() = refcall and
    freecall.getEnclosingStmt().getParent*() = condexpr.getEnclosingStmt()
  )
}

// 检查函数返回值是否被用于条件判断
predicate refCountUsedInCondition(RefCountDecCall refcall) {
  exists(IfStmt ifstmt |
    ifstmt.getCondition() = refcall
  )
  or
  exists(ReturnStmt retstmt |
    retstmt.getExpr() = refcall
  )
}

from RefCountDecCall refcall, MutexUnlockCall unlockcall, Function f
where
  // 在同一个函数中
  refcall.getEnclosingFunction() = f and
  unlockcall.getEnclosingFunction() = f and
  // 引用计数递减在解锁之前执行
  (refCountDecBeforeMutexUnlock(refcall, unlockcall) or
  // 引用计数递减的结果被用于条件判断或返回
  refCountUsedInCondition(refcall) or
  // 存在基于引用计数的条件释放模式
  hasConditionalFreePattern(refcall))
select refcall, 
  "潜在的Use-After-Free漏洞: 在 $@ 之前调用引用计数递减函数，可能导致对象在解锁过程中被其他线程释放。建议将引用计数递减操作移到mutex_unlock()之后。",
  unlockcall, "mutex_unlock"