/**
 * @name CVE-2025-38349: eventpoll mutex_unlock后Use-After-Free漏洞检测
 * @description 检测在mutex_unlock()调用之前进行引用计数递减操作，可能导致对象在解锁过程中被释放的Use-After-Free漏洞
 * @kind problem
 * @problem.severity error
 * @security-severity 8.1
 * @precision high
 * @id cpp/cve-2025-38349-eventpoll-use-after-free
 * @tags security
 *       external/cve/cve-2025-38349
 *       external/cwe/cwe-416
 */

import cpp

// 定义互斥锁解锁函数调用
class MutexUnlockCall extends FunctionCall {
  MutexUnlockCall() {
    this.getTarget().getName() = "mutex_unlock"
  }
  
  // 获取被解锁的互斥锁参数
  string getMutexArg() {
    result = this.getArgument(0).(AddressOfExpr).getOperand().(PointerFieldAccess).getQualifier().toString()
  }
}

// 定义引用计数递减测试函数调用
class RefCountDecCall extends FunctionCall {
  RefCountDecCall() {
    this.getTarget().getName() = "ep_refcount_dec_and_test"
  }
  
  // 获取引用计数操作的对象参数
  string getRefCountArg() {
    result = this.getArgument(0).toString()
  }
}

// 定义对象释放函数调用
class ObjectFreeCall extends FunctionCall {
  ObjectFreeCall() {
    this.getTarget().getName() = "ep_free"
  }
}

// 检查在同一个函数中，引用计数递减是否在mutex_unlock之前执行
predicate refCountDecBeforeMutexUnlock(RefCountDecCall refcall, MutexUnlockCall unlockcall) {
  exists(Function f |
    refcall.getEnclosingFunction() = f and
    unlockcall.getEnclosingFunction() = f and
    // 检查引用计数递减调用在解锁调用之前
    dominates(refcall.getBasicBlock(), unlockcall.getBasicBlock()) and
    // 检查是否操作同一个对象
    unlockcall.getMutexArg() = refcall.getRefCountArg()
  )
}

// 检查是否存在条件释放模式
predicate hasConditionalFreePattern(RefCountDecCall refcall) {
  exists(IfStmt ifstmt, ObjectFreeCall freecall |
    // 检查引用计数递减调用是否在if条件中
    ifstmt.getCondition() = refcall and
    // 检查if语句体中是否有对象释放调用
    freecall.getEnclosingStmt().getParent*() = ifstmt.getThen()
  )
  or
  exists(ConditionalExpr condexpr, ObjectFreeCall freecall |
    // 检查三元表达式中的条件释放模式
    condexpr.getCondition() = refcall and
    freecall.getEnclosingStmt().getParent*() = condexpr.getEnclosingStmt()
  )
}

// 检查函数返回值是否被用于条件判断
predicate refCountUsedInCondition(RefCountDecCall refcall) {
  exists(IfStmt ifstmt |
    ifstmt.getCondition() = refcall
  )
  or
  exists(ReturnStmt retstmt |
    retstmt.getExpr() = refcall
  )
}

from RefCountDecCall refcall, MutexUnlockCall unlockcall, Function f
where
  // 在同一个函数中
  refcall.getEnclosingFunction() = f and
  unlockcall.getEnclosingFunction() = f and
  // 引用计数递减在解锁之前执行
  (refCountDecBeforeMutexUnlock(refcall, unlockcall) or
  // 引用计数递减的结果被用于条件判断或返回
  refCountUsedInCondition(refcall) or
  // 存在基于引用计数的条件释放模式
  hasConditionalFreePattern(refcall))
select refcall, 
  "潜在的Use-After-Free漏洞: 在 $@ 之前调用引用计数递减函数，可能导致对象在解锁过程中被其他线程释放。建议将引用计数递减操作移到mutex_unlock()之后。",
  unlockcall, "mutex_unlock"