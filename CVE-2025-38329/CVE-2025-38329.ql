/**
 * @name CVE-2025-38329
 * @description Detects an out-of-bounds read vulnerability. The issue arises when the size for a destination
 *              buffer is calculated by rounding up an original size for alignment purposes. If this new, larger
 *              size is then used in a `memcpy` operation as the number of bytes to copy from the original source,
 *              it can lead to reading past the boundary of the source buffer.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/oob-read-on-rounded-up-size
 * @tags security
 *       correctness
 *       memory
 *       external/cwe/cwe-125
 * @patch-commit d979b783d61f7f1f95664031b71a33afc74627b2
 * @source-file drivers/firmware/cirrus/test/cs_dsp_mock_wmfw.c
 * @affected-function cs_dsp_mock_wmfw_add_info
 * @kernel-config CONFIG_SND_SOC_CIRRUS_TEST
 * @vulnerability-type out-of-bounds-read
 * @patch-diff |
 *     @@ -133,10 +133,11 @@ void cs_dsp_mock_wmfw_add_info(struct cs_dsp_mock_wmfw_builder *builder,
 *      
 *      	if (info_len % 4) {
 *      		/* Create a padded string with length a multiple of 4 *&#47;
 *     +		size_t copy_len = info_len;
 *      		info_len = round_up(info_len, 4);
 *      		tmp = kunit_kzalloc(builder->test_priv->test, info_len, GFP_KERNEL);
 *      		KUNIT_ASSERT_NOT_ERR_OR_NULL(builder->test_priv->test, tmp);
 *     -		memcpy(tmp, info, info_len);
 *     +		memcpy(tmp, info, copy_len);
 *      		info = tmp;
 *      	}
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38329
 * @remediation 
 */

import cpp

/**
 * 表示memcpy函数调用
 */
class MemcpyCall extends FunctionCall {
  MemcpyCall() {
    this.getTarget().getName() = "memcpy"
  }
}

from MemcpyCall memcpy, Variable lengthVar, Assignment assign
where
  // memcpy的第三个参数（长度参数）使用了某个变量
  memcpy.getArgument(2).(VariableAccess).getTarget() = lengthVar and
  
  // 这个长度变量在memcpy调用之前被赋值修改过
  assign.getLValue().(VariableAccess).getTarget() = lengthVar and
  assign.getLocation().getStartLine() < memcpy.getLocation().getStartLine() and
  
  // 赋值的右边是一个函数调用或表达式（表明长度被修改了）
  (assign.getRValue() instanceof FunctionCall or
   assign.getRValue() instanceof BinaryOperation) and
  
  // 确保在同一个函数中
  assign.getEnclosingFunction() = memcpy.getEnclosingFunction()

select memcpy, "memcpy的长度参数使用了被修改的变量 '" + lengthVar.getName() + 
              "'，请检查是否应该使用原始长度以避免越界读取"