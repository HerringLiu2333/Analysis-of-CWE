/**
 * @name CVE-2024-58017
 * @description printk LOG_BUF_LEN_MAX used (u32)(1 << 31), which shifts a signed 32-bit
 *              integer and overflows before the cast, leading to undefined behavior on
 *              32-bit platforms. The fix casts 1 to u32 prior to shifting, i.e. ((u32)1 << 31),
 *              ensuring a well-defined unsigned shift.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/printk-log-buf-len-max-signed-shift-overflow
 * @tags
 *   correctness
 *   undefined-behavior
 *   integer-overflow
 *   portability
 *   printk
 * @patch-commit dfb7b179741ee09506dc7719d92f9e1cea01f10e
 * @source-file kernel/printk/printk.c
 * @affected-macro LOG_BUF_LEN_MAX
 * @vulnerability-type signed-integer-overflow
 * @patch-diff
 *   diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
 *   index a8af93cbc2936b..3a7fd61c0e7be8 100644
 *   --- a/kernel/printk/printk.c
 *   +++ b/kernel/printk/printk.c
 *   @@ -420,7 +420,7 @@ static u64 clear_seq;
 *    /* record buffer &#47;
 *    #define LOG_ALIGN __alignof__(unsigned long)
 *    #define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
 *   -#define LOG_BUF_LEN_MAX (u32)(1 << 31)
 *   +#define LOG_BUF_LEN_MAX ((u32)1 << 31)
 *    static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
 *    static char *log_buf = __log_buf;
 *    static u32 log_buf_len = __LOG_BUF_LEN;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=dfb7b179741ee09506dc7719d92f9e1cea01f10e
 * @remediation When defining constants via bit shifts, cast to an unsigned type before shifting
 *              (e.g., (u32)1 << 31) to avoid signed overflow and undefined behavior. Consider
 *              using BIT(31) where available for clarity and type safety.
 */



import cpp

from BinaryOperation shiftOp
where
  // 查找移位操作
  (shiftOp.getOperator() = "<<" or shiftOp.getOperator() = ">>") and
  // 检查左操作数是十进制整数字面量
  shiftOp.getLeftOperand().toString().matches("^[0-9]+$") and
  // 检查右操作数是较大的数字（可能导致溢出）
  (shiftOp.getRightOperand().toString() = "31" or
   shiftOp.getRightOperand().toString() = "32" or
   shiftOp.getRightOperand().toString().matches("3[0-9]") or
   shiftOp.getRightOperand().toString().matches("[4-6][0-9]")) and
  // 检查没有进行无符号类型转换
  not shiftOp.getLeftOperand().toString().matches("%[uU]%") and
  not shiftOp.getLeftOperand().toString().matches("%unsigned%") and
  // 检查左操作数没有被强制转换为无符号类型
  not shiftOp.toString().matches("%(u32)%") and
  not shiftOp.toString().matches("%(unsigned)%")
select shiftOp, "Potential signed integer overflow: shift operation " + 
       shiftOp.getLeftOperand().toString() + " " + shiftOp.getOperator() + " " + 
       shiftOp.getRightOperand().toString() + " may cause undefined behavior"