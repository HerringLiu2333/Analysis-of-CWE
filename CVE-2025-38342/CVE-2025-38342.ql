/**
 * @name 数组索引边界检查差一错误检测
 * @description 检测数组访问中的差一错误(Off-by-One Error)，特别是边界检查逻辑
 *              未正确验证访问指定索引所需的安全内存大小的情况
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/array-bounds-off-by-one
 * @tags security
 *       reliability
 *       correctness
 *       external/cwe/cwe-193
 *       external/cwe/cwe-125
 */

import cpp

// 定义一个谓词来识别可能的索引乘法表达式
predicate isIndexMultiplication(MulExpr mul, Variable index) {
  mul.getAnOperand() = index.getAnAccess() and
  exists(Expr sizeofExpr | 
    mul.getAnOperand() = sizeofExpr and
    sizeofExpr instanceof SizeofOperator
  )
}

// 定义一个谓词来识别可能有问题的边界检查
predicate isFaultyBoundsCheck(RelationalOperation rel, MulExpr indexMul, Variable lengthVar) {
  // 检查形如 "index * sizeof(...) >= length" 的模式
  (rel instanceof GEExpr or rel instanceof GTExpr) and
  rel.getLeftOperand() = indexMul and
  rel.getRightOperand() = lengthVar.getAnAccess()
}

// 定义一个谓词来检测数组访问
predicate hasArrayAccess(Function f, Variable index, Variable arrayVar) {
  exists(ArrayExpr arr |
    arr.getEnclosingFunction() = f and
    arr.getArrayOffset() = index.getAnAccess() and
    (
      // 直接数组访问
      arr.getArrayBase() = arrayVar.getAnAccess() or
      // 通过指针访问
      exists(PointerDereferenceExpr deref |
        arr.getArrayBase() = deref and
        deref.getOperand() = arrayVar.getAnAccess()
      )
    )
  )
}

// 定义一个谓词来检测通过指针偏移的访问
predicate hasPointerAccess(Function f, Variable index, Variable ptrVar) {
  exists(PointerArithmeticOperation ptrArith |
    ptrArith.getEnclosingFunction() = f and
    ptrArith.getLeftOperand() = ptrVar.getAnAccess() and
    ptrArith.getRightOperand() = index.getAnAccess()
  )
}

from Function f, RelationalOperation faultyCheck, MulExpr indexMul, 
     Variable index, Variable lengthVar
where
  // 识别有问题的边界检查模式
  isIndexMultiplication(indexMul, index) and
  isFaultyBoundsCheck(faultyCheck, indexMul, lengthVar) and
  faultyCheck.getEnclosingFunction() = f and
  
  // 确保函数中存在对应的数组或指针访问
  (
    exists(Variable arrayVar | hasArrayAccess(f, index, arrayVar)) or
    exists(Variable ptrVar | hasPointerAccess(f, index, ptrVar))
  ) and
  
  // 确保这是在边界检查之后的访问
  exists(Expr access |
    access.getEnclosingFunction() = f and
    (
      access.(ArrayExpr).getArrayOffset() = index.getAnAccess() or
      access.(PointerArithmeticOperation).getRightOperand() = index.getAnAccess()
    ) and
    faultyCheck.getLocation().getStartLine() < access.getLocation().getStartLine()
  )

select faultyCheck, 
       "潜在的差一错误: 边界检查 '" + faultyCheck.toString() + 
       "' 未正确验证访问索引 " + index.getName() + 
       " 所需的安全内存大小。应该检查 '(" + index.getName() + 
       " + 1) * sizeof(...) > " + lengthVar.getName() + 
       "' 以避免越界读取。"