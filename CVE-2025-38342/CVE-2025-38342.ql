/**
 * @name CVE-2025-38342
 * @description Detects an incorrect Out-of-Bounds (OOB) check in the `software_node_get_reference_args` function.
 *              The check to validate the size of a property before accessing an element at a specific index
 *              was flawed. It did not correctly calculate the minimum required size, leading to a potential
 *              off-by-one error. A malformed property could exploit this to cause an OOB read, resulting
 *              in a kernel panic or information disclosure.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/improper-boundary-check
 * @tags security
 *       correctness
 *       external/cwe/cwe-125
 *       external/cwe/cwe-193
 * @patch-commit 31e4e12e0e9609850cefd4b2e1adf782f56337d6
 * @source-file drivers/base/swnode.c
 * @affected-function software_node_get_reference_args
 * @kernel-config N/A (Core driver model)
 * @vulnerability-type out-of-bounds-read
 * @patch-diff |
 *     @@ -529,7 +529,7 @@ software_node_get_reference_args(const struct fwnode_handle *fwnode,
 *      	if (prop->is_inline)
 *      		return -EINVAL;
 *      
 *     -	if (index * sizeof(*ref) >= prop->length)
 *     +	if ((index + 1) * sizeof(*ref) > prop->length)
 *      		return -ENOENT;
 *      
 *      	ref_array = prop->pointer;
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38342
 * @remediation 
 */

import cpp

// 定义一个谓词来识别可能的索引乘法表达式
predicate isIndexMultiplication(MulExpr mul, Variable index) {
  mul.getAnOperand() = index.getAnAccess() and
  exists(Expr sizeofExpr | 
    mul.getAnOperand() = sizeofExpr and
    sizeofExpr instanceof SizeofOperator
  )
}

// 定义一个谓词来识别可能有问题的边界检查
predicate isFaultyBoundsCheck(RelationalOperation rel, MulExpr indexMul, Variable lengthVar) {
  // 检查形如 "index * sizeof(...) >= length" 的模式
  (rel instanceof GEExpr or rel instanceof GTExpr) and
  rel.getLeftOperand() = indexMul and
  rel.getRightOperand() = lengthVar.getAnAccess()
}

// 定义一个谓词来检测数组访问
predicate hasArrayAccess(Function f, Variable index, Variable arrayVar) {
  exists(ArrayExpr arr |
    arr.getEnclosingFunction() = f and
    arr.getArrayOffset() = index.getAnAccess() and
    (
      // 直接数组访问
      arr.getArrayBase() = arrayVar.getAnAccess() or
      // 通过指针访问
      exists(PointerDereferenceExpr deref |
        arr.getArrayBase() = deref and
        deref.getOperand() = arrayVar.getAnAccess()
      )
    )
  )
}

// 定义一个谓词来检测通过指针偏移的访问
predicate hasPointerAccess(Function f, Variable index, Variable ptrVar) {
  exists(PointerArithmeticOperation ptrArith |
    ptrArith.getEnclosingFunction() = f and
    ptrArith.getLeftOperand() = ptrVar.getAnAccess() and
    ptrArith.getRightOperand() = index.getAnAccess()
  )
}

from Function f, RelationalOperation faultyCheck, MulExpr indexMul, 
     Variable index, Variable lengthVar
where
  // 识别有问题的边界检查模式
  isIndexMultiplication(indexMul, index) and
  isFaultyBoundsCheck(faultyCheck, indexMul, lengthVar) and
  faultyCheck.getEnclosingFunction() = f and
  
  // 确保函数中存在对应的数组或指针访问
  (
    exists(Variable arrayVar | hasArrayAccess(f, index, arrayVar)) or
    exists(Variable ptrVar | hasPointerAccess(f, index, ptrVar))
  ) and
  
  // 确保这是在边界检查之后的访问
  exists(Expr access |
    access.getEnclosingFunction() = f and
    (
      access.(ArrayExpr).getArrayOffset() = index.getAnAccess() or
      access.(PointerArithmeticOperation).getRightOperand() = index.getAnAccess()
    ) and
    faultyCheck.getLocation().getStartLine() < access.getLocation().getStartLine()
  )

select faultyCheck, 
       "潜在的差一错误: 边界检查 '" + faultyCheck.toString() + 
       "' 未正确验证访问索引 " + index.getName() + 
       " 所需的安全内存大小。应该检查 '(" + index.getName() + 
       " + 1) * sizeof(...) > " + lengthVar.getName() + 
       "' 以避免越界读取。"