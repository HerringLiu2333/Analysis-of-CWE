/**
 * @name CVE-2025-39728
 * @description An out-of-bounds array access vulnerability exists in the `samsung_clk_init()` function.
 *              The code attempts to initialize the `ctx->clk_data.hws` array before setting the array's size in `ctx->clk_data.num`.
 *              When the kernel is compiled with UBSAN (Undefined Behavior Sanitizer), this leads to a kernel panic due to accessing an array
 *              whose size is considered to be zero.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/array-access-before-size-initialization
 * @tags security
 *       correctness
 *       external/cwe/cwe-129
 *       external/cwe/cwe-665
 *       external/cwe/cwe-457
 * @patch-commit d19d7345a7bcdb083b65568a11b11adffe0687af
 * @source-file drivers/clk/samsung/clk.c
 * @affected-function samsung_clk_init
 * @kernel-config CONFIG_COMMON_CLK_SAMSUNG
 * @vulnerability-type improper-initialization
 * @patch-diff |
 *     @@ -74,12 +74,12 @@ struct samsung_clk_provider * __init samsung_clk_init(struct device *dev,
 *      	if (!ctx)
 *      		panic("could not allocate clock provider context.\n");
 *      
 *     +	ctx->clk_data.num = nr_clks;
 *      	for (i = 0; i < nr_clks; ++i)
 *      		ctx->clk_data.hws[i] = ERR_PTR(-ENOENT);
 *      
 *      	ctx->dev = dev;
 *      	ctx->reg_base = base;
 *     -	ctx->clk_data.num = nr_clks;
 *      	spin_lock_init(&ctx->lock);
 *      
 *      	return ctx;
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-39728
 * @remediation
 * @patch-description |
 *     clk: samsung: Fix UBSAN panic in samsung_clk_init()
 *     With UBSAN_ARRAY_BOUNDS=y, I'm hitting the below panic due to
 *     dereferencing `ctx->clk_data.hws` before setting
 *     `ctx->clk_data.num = nr_clks`. Move that up to fix the crash.
 *     
 *       UBSAN: array index out of bounds: 00000000f2005512 [#1] PREEMPT SMP
 *       <snip>
 *       Call trace:
 *        samsung_clk_init+0x110/0x124 (P)
 *        samsung_clk_init+0x48/0x124 (L)
 *        samsung_cmu_register_one+0x3c/0xa0
 *        exynos_arm64_register_cmu+0x54/0x64
 *        __gs101_cmu_top_of_clk_init_declare+0x28/0x60
 *        ...
 */

import cpp

from ArrayExpr arrayAccess, Assignment sizeAssign, FieldAccess arrayField, FieldAccess sizeField
where
  // 数组访问基于字段访问
  arrayAccess.getArrayBase() = arrayField and
  
  // 大小赋值给字段
  sizeAssign.getLValue() = sizeField and
  
  // 两个字段属于同一结构体类型
  arrayField.getTarget().getDeclaringType() = sizeField.getTarget().getDeclaringType() and
  
  // 大小字段名包含常见标识符
  (
    sizeField.getTarget().getName().matches("%num%") or
    sizeField.getTarget().getName().matches("%size%") or
    sizeField.getTarget().getName().matches("%count%") or
    sizeField.getTarget().getName().matches("%len%")
  ) and
  
  // 在同一函数中
  arrayAccess.getEnclosingFunction() = sizeAssign.getEnclosingFunction() and

  arrayAccess.getEnclosingFunction().getName() = "samsung_clk_init" and
  
  // 使用控制流分析：数组访问在大小字段赋值之前执行
  arrayAccess.getASuccessor*() = sizeAssign and
  
  // 排除在数组访问之前已经有其他地方设置了大小字段的情况
  not exists(Assignment earlierAssign |
    earlierAssign != sizeAssign and
    earlierAssign.getLValue().(FieldAccess).getTarget() = sizeField.getTarget() and
    earlierAssign.getASuccessor*() = arrayAccess and
    // 确保访问同一结构体实例
    earlierAssign.getLValue().(FieldAccess).getQualifier().toString() = 
    arrayField.getQualifier().toString()
  ) and
  
  // 确保访问同一结构体实例
  arrayField.getQualifier().toString() = sizeField.getQualifier().toString()

select arrayAccess, 
       "在设置大小字段之前访问数组，可能导致UBSAN边界检查触发恐慌。应该先设置 $@ 再访问数组。",
       sizeField, "大小字段"