/**
 * @name CVE-2024-58081
 * @description Incorrect initialization order in MMP2 power domain registration caused a NULL
 *  device name for the generic PM domain. pm_genpd_init() sets the genpd device’s
 *  name based on genpd->name; calling it before assigning genpd->name leaves the
 *  device name NULL. Subsequent users (e.g., debugfs) dereference the NULL name
 *  and crash (strlen on NULL).
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/genpd-init-before-name
 * @tags
 *  correctness
 *  reliability
 *  null-dereference
 *  power-management
 *  genpd
 *  pmdomain
 * @patch-commit eca01d5911fb34218d10a58d8d9534b758c8fd0a
 * @source-file drivers/clk/mmp/pwr-island.c
 * @affected-function mmp_pm_domain_register
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *  diff --git a/drivers/clk/mmp/pwr-island.c b/drivers/clk/mmp/pwr-island.c
 *  index edaa2433a472ad…eaf5d2c5e59337 100644
 *  --- a/drivers/clk/mmp/pwr-island.c
 *  +++ b/drivers/clk/mmp/pwr-island.c
 *  @@ -106,10 +106,10 @@ struct generic_pm_domain *mmp_pm_domain_register(const char *name,
 *    pm_domain->flags = flags;
 *    pm_domain->lock = lock;
 *
 *  - pm_genpd_init(&pm_domain->genpd, NULL, true);
 *    pm_domain->genpd.name = name;
 *    pm_domain->genpd.power_on = mmp_pm_domain_power_on;
 *    pm_domain->genpd.power_off = mmp_pm_domain_power_off;
 *  + pm_genpd_init(&pm_domain->genpd, NULL, true);
 *
 *    return &pm_domain->genpd;
 *  }
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=eca01d5911fb34218d10a58d8d9534b758c8fd0a
 * @remediation Set genpd->name before calling pm_genpd_init(), so the internal dev_set_name()
 *  receives a valid string. In general, initialize all required genpd fields (e.g.,
 *  name, callbacks) prior to pm_genpd_init() to prevent NULL dereferences in debugfs
 *  or other subsystems that use dev_name(&genpd->dev).
 * @patch-description |
 *  clk: mmp2: call pm_genpd_init() only after genpd.name is set
 *  commit e24b15d4704dcb73920c3d18a6157abd18df08c1 upstream.
 *  
 *  Setting the genpd's struct device's name with dev_set_name() is
 *  happening within pm_genpd_init(). If it remains NULL, things can blow up
 *  later, such as when crafting the devfs hierarchy for the power domain:
 *  
 *    Unable to handle kernel NULL pointer dereference at virtual address 00000000 when read
 *    ...
 *    Call trace:
 *     strlen from start_creating+0x90/0x138
 *     start_creating from debugfs_create_dir+0x20/0x178
 *     debugfs_create_dir from genpd_debug_add.part.0+0x4c/0x144
 *     genpd_debug_add.part.0 from genpd_debug_init+0x74/0x90
 *     genpd_debug_init from do_one_initcall+0x5c/0x244
 *     do_one_initcall from kernel_init_freeable+0x19c/0x1f4
 *     kernel_init_freeable from kernel_init+0x1c/0x12c
 *     kernel_init from ret_from_fork+0x14/0x28
 *  
 *  Bisecting tracks this crash back to commit 899f44531fe6 ("pmdomain: core:
 *  Add GENPD_FLAG_DEV_NAME_FW flag"), which exchanges use of genpd->name
 *  with dev_name(&genpd->dev) in genpd_debug_add.part().
 *  
 *  Fixes: 899f44531fe6 ("pmdomain: core: Add GENPD_FLAG_DEV_NAME_FW flag")
 */

import cpp

/*
 * 检测时钟驱动中的初始化顺序问题
 * 该查询用于识别在设置genpd.name之前调用pm_genpd_init()的情况
 * 这可能导致NULL指针解引用，因为pm_genpd_init()需要genpd.name已设置
 * This query identifies initialization order issues where pm_genpd_init() is called
 * before genpd.name is set, which may lead to NULL pointer dereference
 */

// 检查是否为mmp_pm_domain_register函数
// Check if it's mmp_pm_domain_register function
predicate isMmpPmDomainRegisterFunction(Function f) {
  f.getName() = "mmp_pm_domain_register"
}

// 检查是否为pm_genpd_init函数调用
// Check if it's pm_genpd_init function call
predicate isPmGenpdInitCall(FunctionCall fc) {
  fc.getTarget().getName() = "pm_genpd_init"
}

// 检查是否为genpd.name赋值
// Check if it's genpd.name assignment
predicate isGenpdNameAssignment(AssignExpr assign) {
  exists(FieldAccess fa |
    fa = assign.getLValue() and
    fa.getTarget().getName() = "name" and
    exists(FieldAccess genpdAccess |
      genpdAccess = fa.getQualifier() and
      genpdAccess.getTarget().getName() = "genpd"
    )
  )
}

// 检查初始化顺序是否正确
// Check if initialization order is correct
predicate hasCorrectInitializationOrder(FunctionCall initCall, AssignExpr nameAssign) {
  nameAssign.getLocation().getStartLine() < initCall.getLocation().getStartLine()
}

from
  Function f,
  FunctionCall initCall,    // pm_genpd_init调用
  AssignExpr nameAssign     // genpd.name赋值
where
  // 限制在mmp_pm_domain_register函数内
  isMmpPmDomainRegisterFunction(f) and
  initCall.getEnclosingFunction() = f and
  nameAssign.getEnclosingFunction() = f and
  // 查找pm_genpd_init调用
  isPmGenpdInitCall(initCall) and
  // 查找genpd.name赋值
  isGenpdNameAssignment(nameAssign) and
  // 检查初始化顺序错误（pm_genpd_init在genpd.name赋值之前调用）
  not hasCorrectInitializationOrder(initCall, nameAssign)
select
  initCall,
  "Potential NULL pointer dereference: pm_genpd_init() called before genpd.name is set, may cause NULL pointer dereference in debugfs"