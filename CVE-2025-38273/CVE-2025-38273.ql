/**
 * @name CVE-2025-38273
 * @description Detects a race condition between network namespace destruction and a TIPC
 *              timer callback. The use of 'get_net()' without checking the namespace's
 *              liveness can lead to a use-after-free vulnerability, as it may operate
 *              on an object whose refcount is already zero.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/linux/tipc-unsafe-get-net-in-async
 * @tags security
 *       correctness
 *       concurrency
 *       race-condition
 *       external/cwe/cwe-362
 *       external/cwe/cwe-416
 * @patch-commit f29ccaa07cf3d35990f4d25028cc55470d29372b
 * @source-file net/tipc/crypto.c
 * @affected-function tipc_aead_encrypt
 * @kernel-config CONFIG_TIPC
 * @vulnerability-type race-condition use-after-free
 * @patch-diff |
 *      @@ -818,7 +818,11 @@ static int tipc_aead_encrypt(struct tipc_aead *aead, struct sk_buff *skb,
 *       	}
 *       
 *       	/* Get net to avoid freed tipc_crypto when delete namespace *&#47;
 *      -	get_net(aead->crypto->net);
 *      +	if (!maybe_get_net(aead->crypto->net)) {
 *      +		tipc_bearer_put(b);
 *      +		rc = -ENODEV;
 *      +		goto exit;
 *      +	}
 *       
 *       	/* Now, do encrypt *&#47;
 *       	rc = crypto_aead_encrypt(req);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38273
 * @remediation 
 * @patch-description |
 *     net: tipc: fix refcount warning in tipc_aead_encrypt
 *     syzbot reported a refcount warning [1] caused by calling get_net() on
 *     a network namespace that is being destroyed (refcount=0). This happens
 *     when a TIPC discovery timer fires during network namespace cleanup.
 *     
 *     The recently added get_net() call in commit e279024617134 ("net/tipc:
 *     fix slab-use-after-free Read in tipc_aead_encrypt_done") attempts to
 *     hold a reference to the network namespace. However, if the namespace
 *     is already being destroyed, its refcount might be zero, leading to the
 * '   use-after-free warning.
 *     
 *     Replace get_net() with maybe_get_net(), which safely checks if the
 *     refcount is non-zero before incrementing it. If the namespace is being
 *     destroyed, return -ENODEV early, after releasing the bearer reference.
 */
import cpp

from FunctionCall getNet
where
      getNet.getTarget().getName() = "get_net" and
      exists(PointerFieldAccess netAcc, PointerFieldAccess cryptoAcc, VariableAccess aeadVar |
            netAcc = getNet.getArgument(0) and
            netAcc.getTarget().getName() = "net" and
            cryptoAcc = netAcc.getQualifier() and
            cryptoAcc.getTarget().getName() = "crypto" and
            aeadVar = cryptoAcc.getQualifier() and
            aeadVar.getTarget().getName() = "aead"
      )
select getNet, "Unguarded get_net on aead->crypto->net (pre-patch pattern)"