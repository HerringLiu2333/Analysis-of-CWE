/**
 * @name CVE-2024-58055
 * @description In the USB gadget TCM function driver, commands were freed immediately after
 *  sending a CHECK CONDITION with sense data. The command must be freed only after
 *  the status (sense) completion, otherwise it can be freed twice, leading to
 *  double-free/use-after-free and potential memory corruption.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/double-free-on-early-free
 * @tags 
 *  security
 *  correctness
 *  reliability
 *  memory-safety
 *  double-free
 *  use-after-free
 *  external/cwe/cwe-415
 *  external/cwe/cwe-416
 * @patch-commit f0c33e7d387ccbb6870e73a43c558fefede06614
 * @source-file drivers/usb/gadget/function/f_tcm.c
 * @affected-function usbg_cmd_work
 * @affected-function bot_cmd_work
 * @kernel-config N/A
 * @vulnerability-type double-free
 * @patch-diff |
 *  diff --git a/drivers/usb/gadget/function/f_tcm.c b/drivers/usb/gadget/function/f_tcm.c
 *  index 81b6d0d18a8cd6…948888316fbd54 100644
 *  --- a/drivers/usb/gadget/function/f_tcm.c
 *  +++ b/drivers/usb/gadget/function/f_tcm.c
 *  @@ -1066,7 +1066,6 @@ static void usbg_cmd_work(struct work_struct *work)
 *    out:
 *    transport_send_check_condition_and_sense(se_cmd,
 *    TCM_UNSUPPORTED_SCSI_OPCODE, 1);
 *  - transport_generic_free_ccmd(&cmd->se_cmd, 0);
 *    }
 *
 *    static struct usbg_cmd *usbg_get_cmd(struct f_uas *fu,
 *  @@ -1195,7 +1194,6 @@ static void bot_cmd_work(struct work_struct *work)
 *    out:
 *    transport_send_check_condition_and_sense(se_cmd,
 *    TCM_UNSUPPORTED_SCSI_OPCODE, 1);
 *  - transport_generic_free_cmd(&cmd->se_cmd, 0);
 *    }
 *
 *    static int bot_submit_command(struct f_uas *fu,
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f0c33e7d387ccbb6870e73a43c558fefede06614
 * @remediation Do not free se_cmd immediately after sending CHECK CONDITION and sense data.
 *  Defer freeing until the status completion callback for the sense status runs,
 *  which safely releases the command and prevents double-free/use-after-free.
 */

import cpp

/*
 * 检测usb gadget f_tcm驱动中的双重释放漏洞
 * 该查询用于识别在transport_send_check_condition_and_sense调用后立即调用transport_generic_free_cmd的情况
 * 这可能导致命令被双重释放，因为transport_send_check_condition_and_sense内部可能已经处理了命令的释放
 * This query identifies double-free vulnerability where transport_generic_free_cmd is called
 * immediately after transport_send_check_condition_and_sense, which may already handle command freeing
 */

// 检查是否为transport_send_check_condition_and_sense函数调用
// Check if it's transport_send_check_condition_and_sense function call
predicate isTransportSendCheckConditionCall(FunctionCall fc) {
  fc.getTarget().getName() = "transport_send_check_condition_and_sense"
}

// 检查是否为transport_generic_free_cmd函数调用
// Check if it's transport_generic_free_cmd function call
predicate isTransportGenericFreeCmdCall(FunctionCall fc) {
  fc.getTarget().getName() = "transport_generic_free_cmd"
}

// 检查两个函数调用是否在同一基本块中连续出现
// Check if two function calls appear consecutively in the same basic block
predicate areCallsConsecutive(FunctionCall firstCall, FunctionCall secondCall) {
  firstCall.getLocation().getStartLine() < secondCall.getLocation().getStartLine() and
  firstCall.getEnclosingBlock() = secondCall.getEnclosingBlock()
}

// 检查transport_generic_free_cmd是否在transport_send_check_condition_and_sense之后立即调用
// Check if transport_generic_free_cmd is called immediately after transport_send_check_condition_and_sense
predicate isFreeCmdAfterCheckCondition(FunctionCall checkCall, FunctionCall freeCall) {
  areCallsConsecutive(checkCall, freeCall) and
  isTransportSendCheckConditionCall(checkCall) and
  isTransportGenericFreeCmdCall(freeCall)
}

from
  FunctionCall checkCall,  // transport_send_check_condition_and_sense调用
  FunctionCall freeCall    // transport_generic_free_cmd调用
where
  // 两个调用在同一个函数内
  checkCall.getEnclosingFunction() = freeCall.getEnclosingFunction() and
  // 检查freeCall是否在checkCall之后立即调用
  isFreeCmdAfterCheckCondition(checkCall, freeCall)
select
  freeCall,
  "Potential double-free vulnerability: transport_generic_free_cmd() called immediately after transport_send_check_condition_and_sense(), which may already handle command freeing"