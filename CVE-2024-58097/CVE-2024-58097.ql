/**
 * @name CVE-2024-58058
 * @description UBIFS could dereference a NULL pointer when dumping the TNC tree if slab cache
 *              reclaim freed all znodes, leaving c->zroot.znode == NULL. Calling ubifs_dump_tnc()
 *              then accessed znode->level unconditionally, causing a kernel NULL dereference.
 *              The fix guards the dump with a zroot check and logs an empty-tree message instead.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/ubifs-tnc-dump-null-check
 * @tags
 *       correctness
 *       reliability
 *       null-dereference
 *       filesystem
 *       ubifs
 * @patch-commit e01b55f261ccc96e347eba4931e4429d080d879d
 * @source-file fs/ubifs/debug.c
 * @affected-function ubifs_dump_tnc
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *     diff --git a/fs/ubifs/debug.c b/fs/ubifs/debug.c
 *     index 3f128b9fdfbb23..9613725ed19359 100644
 *     --- a/fs/ubifs/debug.c
 *     +++ b/fs/ubifs/debug.c
 *     @@ -946,16 +946,20 @@ void ubifs_dump_tnc(struct ubifs_info *c)
 *      
 *      	pr_err("\n");
 *      	pr_err("(pid %d) start dumping TNC tree\n", current->pid);
 *     -	znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, NULL);
 *     -	level = znode->level;
 *     -	pr_err("== Level %d ==\n", level);
 *     -	while (znode) {
 *     -		if (level != znode->level) {
 *     -			level = znode->level;
 *     -			pr_err("== Level %d ==\n", level);
 *     -		}
 *     -		ubifs_dump_znode(c, znode);
 *     -		znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, znode);
 *     +	if (c->zroot.znode) {
 *     +		znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, NULL);
 *     +		level = znode->level;
 *     +		pr_err("== Level %d ==\n", level);
 *     +		while (znode) {
 *     +			if (level != znode->level) {
 *     +				level = znode->level;
 *     +				pr_err("== Level %d ==\n", level);
 *     +			}
 *     +			ubifs_dump_znode(c, znode);
 *     +			znode = ubifs_tnc_levelorder_next(c, c->zroot.znode, znode);
 *     +		}
 *     +	} else {
 *     +		pr_err("empty TNC tree in memory\n");
 *      	}
 *      	pr_err("(pid %d) finish dumping TNC tree\n", current->pid);
 *      }
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=e01b55f261ccc96e347eba4931e4429d080d879d
 * @remediation In UBIFS diagnostics, verify c->zroot.znode is non-NULL before traversing the TNC.
 *              If it is NULL (e.g., after slab cache reclaim), skip traversal and emit a clear
 *              log message. Avoid dereferencing znode or accessing znode->level without a prior
 *              NULL check.
 */


import cpp

/*
 * 检测ath11k驱动中的RCU停滞漏洞
 * 该查询用于识别在处理监视器目标环时使用break而不是goto next_msdu的情况
 * 这可能导致无限循环和RCU停滞，因为无效的buf_id会中断处理而不是跳过
 * This query identifies RCU stall vulnerabilities where break is used instead of goto next_msdu
 * in monitor destination ring processing, which may cause infinite loops and RCU stalls
 */

// 检查是否为ath11k_dp_rx_mon_mpdu_pop或ath11k_dp_rx_full_mon_mpdu_pop函数
// Check if it's ath11k_dp_rx_mon_mpdu_pop or ath11k_dp_rx_full_mon_mpdu_pop function
predicate isTargetFunction(Function f) {
  f.getName() = "ath11k_dp_rx_mon_mpdu_pop" or
  f.getName() = "ath11k_dp_rx_full_mon_mpdu_pop"
}

// 检查是否为无效buf_id的调试消息
// Check for invalid buf_id debug message
predicate isInvalidBufIdDebug(FunctionCall fc) {
  fc.getTarget().getName() = "ath11k_dbg" and
  fc.getArgument(1).toString().matches("%ATH11K_DBG_DATA%") and
  fc.getArgument(2).toString().matches("%invalid buf_id%")
}

// 检查是否为break语句
// Check for break statement
predicate isBreakAfterDebug(FunctionCall debugCall) {
  exists(BreakStmt breakStmt |
    breakStmt.getEnclosingFunction() = debugCall.getEnclosingFunction() and
    breakStmt.getLocation().getStartLine() > debugCall.getLocation().getStartLine() and
    breakStmt.getLocation().getStartLine() < debugCall.getLocation().getStartLine() + 10
  )
}

// 检查是否为goto next_msdu语句
// Check for goto next_msdu statement
predicate isGotoNextMsduAfterDebug(FunctionCall debugCall) {
  exists(GotoStmt gotoStmt |
    gotoStmt.getEnclosingFunction() = debugCall.getEnclosingFunction() and
    gotoStmt.getLocation().getStartLine() > debugCall.getLocation().getStartLine() and
    gotoStmt.getLocation().getStartLine() < debugCall.getLocation().getStartLine() + 10 and
    gotoStmt.toString().matches("%next_msdu%")
  )
}

from
  Function f,
  FunctionCall debugCall  // 调试消息调用
where
  // 限制在目标函数内
  isTargetFunction(f) and
  debugCall.getEnclosingFunction() = f and
  // 查找无效buf_id的调试消息
  isInvalidBufIdDebug(debugCall) and
  // 在调试消息之后有break语句
  isBreakAfterDebug(debugCall) and
  // 在调试消息之后没有goto next_msdu语句
  not isGotoNextMsduAfterDebug(debugCall)
select
  debugCall,
  "Potential RCU stall issue: Using break instead of goto next_msdu for invalid buf_id handling, may cause infinite loop and RCU stall"