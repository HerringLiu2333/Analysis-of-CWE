/**
 * @name CVE-2025-38245
 * @description Detects critical operations that are not properly protected by locks,
 *              which may lead to race conditions and data corruption in concurrent environments.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/unprotected-critical-operation
 * @tags security
 *       correctness
 *       concurrency
 *       race-condition
 *       external/cwe/cwe-362
 *       external/cwe/cwe-667
 * @patch-commit a433791aeaea6e84df709e0b9584b9bbe040cd1c
 * @source-file net/atm/resources.c
 * @affected-function atm_dev_deregister
 * @kernel-config CONFIG_ATM
 * @vulnerability-type race-condition
 * @patch-diff |
 *     @@ -146,11 +146,10 @@ void atm_dev_deregister(struct atm_dev *dev)
 *          mutex_lock(&atm_dev_mutex);
 *          list_del(&dev->dev_list);
 *     -	  mutex_unlock(&atm_dev_mutex);
 *     -
 *          atm_dev_release_vccs(dev);
 *          atm_unregister_sysfs(dev);
 *          atm_proc_dev_deregister(dev);
 *     +    mutex_lock(&atm_dev_mutex);
 *      
 *          atm_dev_put(dev);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38245
 * @remediation Add known hazardous functions to the list of isCriticalOperations
 *              Use findTargetFunction to restrict function level queries
 * @patch-description |
 *     atm: Release atm_dev_mutex after removing procfs in atm_dev_deregister().
 *     syzbot reported a warning below during atm_dev_register(). [0]
 *     
 *     Before creating a new device and procfs/sysfs for it, atm_dev_register()
 *     looks up a duplicated device by __atm_dev_lookup().  These operations are
 *     done under atm_dev_mutex.
 *     
 *     However, when removing a device in atm_dev_deregister(), it releases the
 *     mutex just after removing the device from the list that __atm_dev_lookup()
 *     iterates over.
 *     
 *     So, there will be a small race window where the device does not exist on
 *     the device list but procfs/sysfs are still not removed, triggering the
 *     splat.
 *     
 *     Let's hold the mutex until procfs/sysfs are removed in
 *     atm_dev_deregister().
 *     
 *     [0]:
 *     proc_dir_entry 'atm/atmtcp:0' already registered
 *     WARNING: CPU: 0 PID: 5919 at fs/proc/generic.c:377 proc_register+0x455/0x5f0 fs/proc/generic.c:377
 *     Modules linked in:
 *     CPU: 0 UID: 0 PID: 5919 Comm: syz-executor284 Not tainted 6.16.0-rc2-syzkaller-00047-g52da431bf03b #0 PREEMPT(full)
 *     Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/07/2025
 *     RIP: 0010:proc_register+0x455/0x5f0 fs/proc/generic.c:377
 *     Code: 48 89 f9 48 c1 e9 03 80 3c 01 00 0f 85 a2 01 00 00 48 8b 44 24 10 48 c7 c7 20 c0 c2 8b 48 8b b0 d8 00 00 00 e8 0c 02 1c ff 90 <0f> 0b 90 90 48 c7 c7 80 f2 82 8e e8 0b de 23 09 48 8b 4c 24 28 48
 *     RSP: 0018:ffffc9000466fa30 EFLAGS: 00010282
 *     RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff817ae248
 *     RDX: ffff888026280000 RSI: ffffffff817ae255 RDI: 0000000000000001
 *     RBP: ffff8880232bed48 R08: 0000000000000001 R09: 0000000000000000
 *     R10: 0000000000000000 R11: 0000000000000001 R12: ffff888076ed2140
 *     R13: dffffc0000000000 R14: ffff888078a61340 R15: ffffed100edda444
 *     FS:  00007f38b3b0c6c0(0000) GS:ffff888124753000(0000) knlGS:0000000000000000
 *     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 *     CR2: 00007f38b3bdf953 CR3: 0000000076d58000 CR4: 00000000003526f0
 *     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
 *     DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
 *     Call Trace:
 *      <TASK>
 *      proc_create_data+0xbe/0x110 fs/proc/generic.c:585
 *      atm_proc_dev_register+0x112/0x1e0 net/atm/proc.c:361
 *      atm_dev_register+0x46d/0x890 net/atm/resources.c:113
 *      atmtcp_create+0x77/0x210 drivers/atm/atmtcp.c:369
 *      atmtcp_attach drivers/atm/atmtcp.c:403 [inline]
 *      atmtcp_ioctl+0x2f9/0xd60 drivers/atm/atmtcp.c:464
 *      do_vcc_ioctl+0x12c/0x930 net/atm/ioctl.c:159
 *      sock_do_ioctl+0x115/0x280 net/socket.c:1190
 *      sock_ioctl+0x227/0x6b0 net/socket.c:1311
 *      vfs_ioctl fs/ioctl.c:51 [inline]
 *      __do_sys_ioctl fs/ioctl.c:907 [inline]
 *      __se_sys_ioctl fs/ioctl.c:893 [inline]
 *      __x64_sys_ioctl+0x18b/0x210 fs/ioctl.c:893
 *      do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
 *      do_syscall_64+0xcd/0x4c0 arch/x86/entry/syscall_64.c:94
 *      entry_SYSCALL_64_after_hwframe+0x77/0x7f
 *     RIP: 0033:0x7f38b3b74459
 *     Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48
 *     RSP: 002b:00007f38b3b0c198 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
 *     RAX: ffffffffffffffda RBX: 00007f38b3bfe318 RCX: 00007f38b3b74459
 *     RDX: 0000000000000000 RSI: 0000000000006180 RDI: 0000000000000005
 *     RBP: 00007f38b3bfe310 R08: 65732f636f72702f R09: 65732f636f72702f
 *     R10: 65732f636f72702f R11: 0000000000000246 R12: 00007f38b3bcb0ac
 *     R13: 00007f38b3b0c1a0 R14: 0000200000000200 R15: 00007f38b3bcb03b
 *      </TASK>
 *     
 *     Fixes: 64bf69ddff76 ("[ATM]: deregistration removes device from atm_devs list immediately")
 */
import cpp
import semmle.code.cpp.valuenumbering.GlobalValueNumbering

// 定义锁类型和对应的解锁函数
predicate isLockFunction(string lockFunc, string unlockFunc) {
  (lockFunc = "mutex_lock" and unlockFunc = "mutex_unlock") or
  (lockFunc = "spin_lock" and unlockFunc = "spin_unlock") or
  (lockFunc = "spin_lock_irqsave" and unlockFunc = "spin_unlock_irqrestore") or
  (lockFunc = "read_lock" and unlockFunc = "read_unlock") or
  (lockFunc = "write_lock" and unlockFunc = "write_unlock") or
  (lockFunc = "raw_spin_lock" and unlockFunc = "raw_spin_unlock") or
  (lockFunc = "down" and unlockFunc = "up") or
  (lockFunc = "down_read" and unlockFunc = "up_read") or
  (lockFunc = "down_write" and unlockFunc = "up_write")
}

// 泛化的关键操作检测
predicate isCriticalOperation(FunctionCall fc) {
  // 特定的危险函数列表
  fc.getTarget().getName() in [
    "atm_proc_dev_deregister"
  ]
}

predicate findTargetFunction(Function f, string filePath, string funcName) {
  f.getFile().getRelativePath() = filePath and
  f.getName() = funcName
}

predicate operateOnSameLock(FunctionCall fc1, FunctionCall fc2) {
  // 先进行廉价的文本比较。这能处理绝大多数情况。
  fc1.getArgument(0).toString() = fc2.getArgument(0).toString()
}

predicate isActivelyProtectedBy(FunctionCall op, FunctionCall lock, string lockFunc, string unlockFunc) {
  // 首先确保这是一对有效的锁/解锁函数
  isLockFunction(lockFunc, unlockFunc) and
  // 确保lock调用的是lockFunc
  lock.getTarget().getName() = lockFunc and
  
  // 条件1: lock 必须在 op 之前执行
  strictlyDominates(lock, op) and

  // 条件2: 必须不存在任何一个"干预的解锁"
  not exists(FunctionCall interveningUnlock |
    // a) 这个解锁必须与 lock 匹配且是对应的解锁函数
    operateOnSameLock(lock, interveningUnlock) and
    interveningUnlock.getTarget().getName() = unlockFunc and
    // b) 这个解锁必须位于 lock 和 op 之间
    strictlyDominates(lock, interveningUnlock) and
    strictlyDominates(interveningUnlock, op)
  )
}

// 跨函数分析：查找调用链上的锁保护
predicate isProtectedThroughCallChain(FunctionCall criticalOp) {
  exists(Function callee, Function caller, FunctionCall callSite, FunctionCall lockCall, string lockFunc, string unlockFunc |
    // criticalOp 在被调用函数中
    criticalOp.getEnclosingFunction() = callee and
    // callSite 是从 caller 调用 callee 的地方
    callSite.getEnclosingFunction() = caller and
    callSite.getTarget() = callee and
    // 在 caller 中有锁保护 callSite
    lockCall.getEnclosingFunction() = caller and
    isActivelyProtectedBy(callSite, lockCall, lockFunc, unlockFunc)
  )
}

// 直接在函数内的锁保护
predicate isDirectlyProtected(FunctionCall criticalOp) {
  exists(FunctionCall lockCall, string lockFunc, string unlockFunc |
    lockCall.getEnclosingFunction() = criticalOp.getEnclosingFunction() and
    isActivelyProtectedBy(criticalOp, lockCall, lockFunc, unlockFunc)
  )
}

from Function func, FunctionCall criticalOp
where
  // findTargetFunction(func, "net/atm/resources.c", "atm_dev_deregister") and
  criticalOp.getEnclosingFunction() = func and
  isCriticalOperation(criticalOp) and

  // 既没有直接保护，也没有通过调用链保护
  not isDirectlyProtected(criticalOp) and
  not isProtectedThroughCallChain(criticalOp)

select criticalOp, "Critical operation '" + criticalOp.getTarget().getName() + "' is not properly protected by locks"
