/**
 * @name CVE-2025-38245
 * @description Detects critical operations that are not properly protected by locks,
 *              which may lead to race conditions and data corruption in concurrent environments.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/unprotected-critical-operation
 * @tags security
 *       correctness
 *       concurrency
 *       race-condition
 *       external/cwe/cwe-362
 *       external/cwe/cwe-667
 * @patch-commit a1b2c3d4e5f6789012345678901234567890abcd
 * @source-file net/atm/resources.c
 * @affected-function atm_dev_deregister
 * @kernel-config CONFIG_ATM
 * @vulnerability-type race-condition
 * @patch-diff |
 *     @@ -146,11 +146,10 @@ void atm_dev_deregister(struct atm_dev *dev)
 *          mutex_lock(&atm_dev_mutex);
 *          list_del(&dev->dev_list);
 *     -	  mutex_unlock(&atm_dev_mutex);
 *     -
 *          atm_dev_release_vccs(dev);
 *          atm_unregister_sysfs(dev);
 *          atm_proc_dev_deregister(dev);
 *     +    mutex_lock(&atm_dev_mutex);
 *      
 *          atm_dev_put(dev);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38245
 * @remediation Add known hazardous functions to the list of isCriticalOperations
 *              Use findTargetFunction to restrict function level queries
 */
import cpp
import semmle.code.cpp.valuenumbering.GlobalValueNumbering

// 定义锁类型和对应的解锁函数
predicate isLockFunction(string lockFunc, string unlockFunc) {
  (lockFunc = "mutex_lock" and unlockFunc = "mutex_unlock") or
  (lockFunc = "spin_lock" and unlockFunc = "spin_unlock") or
  (lockFunc = "spin_lock_irqsave" and unlockFunc = "spin_unlock_irqrestore") or
  (lockFunc = "read_lock" and unlockFunc = "read_unlock") or
  (lockFunc = "write_lock" and unlockFunc = "write_unlock") or
  (lockFunc = "raw_spin_lock" and unlockFunc = "raw_spin_unlock") or
  (lockFunc = "down" and unlockFunc = "up") or
  (lockFunc = "down_read" and unlockFunc = "up_read") or
  (lockFunc = "down_write" and unlockFunc = "up_write")
}

// 泛化的关键操作检测
predicate isCriticalOperation(FunctionCall fc) {
  // 特定的危险函数列表
  fc.getTarget().getName() in [
    "atm_proc_dev_deregister"
  ]
}

predicate findTargetFunction(Function f, string filePath, string funcName) {
  f.getFile().getRelativePath() = filePath and
  f.getName() = funcName
}

predicate operateOnSameLock(FunctionCall fc1, FunctionCall fc2) {
  // 先进行廉价的文本比较。这能处理绝大多数情况。
  fc1.getArgument(0).toString() = fc2.getArgument(0).toString()
}

predicate isActivelyProtectedBy(FunctionCall op, FunctionCall lock, string lockFunc, string unlockFunc) {
  // 首先确保这是一对有效的锁/解锁函数
  isLockFunction(lockFunc, unlockFunc) and
  // 确保lock调用的是lockFunc
  lock.getTarget().getName() = lockFunc and
  
  // 条件1: lock 必须在 op 之前执行
  strictlyDominates(lock, op) and

  // 条件2: 必须不存在任何一个"干预的解锁"
  not exists(FunctionCall interveningUnlock |
    // a) 这个解锁必须与 lock 匹配且是对应的解锁函数
    operateOnSameLock(lock, interveningUnlock) and
    interveningUnlock.getTarget().getName() = unlockFunc and
    // b) 这个解锁必须位于 lock 和 op 之间
    strictlyDominates(lock, interveningUnlock) and
    strictlyDominates(interveningUnlock, op)
  )
}

// 跨函数分析：查找调用链上的锁保护
predicate isProtectedThroughCallChain(FunctionCall criticalOp) {
  exists(Function callee, Function caller, FunctionCall callSite, FunctionCall lockCall, string lockFunc, string unlockFunc |
    // criticalOp 在被调用函数中
    criticalOp.getEnclosingFunction() = callee and
    // callSite 是从 caller 调用 callee 的地方
    callSite.getEnclosingFunction() = caller and
    callSite.getTarget() = callee and
    // 在 caller 中有锁保护 callSite
    lockCall.getEnclosingFunction() = caller and
    isActivelyProtectedBy(callSite, lockCall, lockFunc, unlockFunc)
  )
}

// 直接在函数内的锁保护
predicate isDirectlyProtected(FunctionCall criticalOp) {
  exists(FunctionCall lockCall, string lockFunc, string unlockFunc |
    lockCall.getEnclosingFunction() = criticalOp.getEnclosingFunction() and
    isActivelyProtectedBy(criticalOp, lockCall, lockFunc, unlockFunc)
  )
}

from Function func, FunctionCall criticalOp
where
  // findTargetFunction(func, "net/atm/resources.c", "atm_dev_deregister") and
  criticalOp.getEnclosingFunction() = func and
  isCriticalOperation(criticalOp) and

  // 既没有直接保护，也没有通过调用链保护
  not isDirectlyProtected(criticalOp) and
  not isProtectedThroughCallChain(criticalOp)

select criticalOp, "Critical operation '" + criticalOp.getTarget().getName() + "' is not properly protected by locks"
