/**
 * @name CVE-2025-38298
 * @description Detects cases where a global variable is not reset during a resource cleanup or deinitialization phase.
 *              This can lead to incorrect state and out-of-bounds memory access if the resource is reinitialized,
 *              potentially causing a denial of service.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/unreset-global-on-cleanup
 * @tags security
 *       correctness
 *       denial-of-service
 *       state-corruption
 *       external/cwe/cwe-404
 * @patch-commit 20d2d476b3ae18041be423671a8637ed5ffd6958
 * @source-file drivers/edac/skx_common.c
 * @affected-function skx_adxl_put
 * @kernel-config CONFIG_EDAC_SKX
 * @vulnerability-type improper-state-cleanup
 * @patch-diff |
 *      @@ -116,6 +116,7 @@ EXPORT_SYMBOL_GPL(skx_adxl_get);
 *       
 *       void skx_adxl_put(void)
 *       {
 *      +	adxl_component_count = 0;
 *       	kfree(adxl_values);
 *       	kfree(adxl_msg);
 *       }
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38298
 * @remediation
 */

import cpp

// 定义全局变量
class GlobalCounter extends GlobalVariable {
  GlobalCounter() {
    // 匹配名为 adxl_component_count 的全局变量
    this.getName() = "adxl_component_count"
  }
}

// 定义清理函数
class CleanupFunction extends Function {
  CleanupFunction() {
    // 匹配名为 skx_adxl_put 的函数
    this.getName() = "skx_adxl_put"
  }
}

from CleanupFunction cleanup, GlobalCounter counter
where
  // 在清理函数中查找对计数器的赋值操作
  not exists(Assignment a |
    a.getEnclosingFunction() = cleanup and
    a.getLValue().(VariableAccess).getTarget() = counter and
    a.getRValue().getValue() = "0"
  )
select cleanup,
  "清理函数 '" + cleanup.getName() + "' 未重置全局计数器 '" + counter.getName() +
    "'，可能导致模块重载时计数错误"