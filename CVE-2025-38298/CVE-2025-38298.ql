/**
 * @name CVE-2025-38298
 * @description Detects cases where a global variable is not reset during a resource cleanup or deinitialization phase.
 *              This can lead to incorrect state and out-of-bounds memory access if the resource is reinitialized,
 *              potentially causing a denial of service.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/unreset-global-on-cleanup
 * @tags security
 *       correctness
 *       denial-of-service
 *       state-corruption
 *       external/cwe/cwe-404
 * @patch-commit 20d2d476b3ae18041be423671a8637ed5ffd6958
 * @source-file drivers/edac/skx_common.c
 * @affected-function skx_adxl_put
 * @kernel-config CONFIG_EDAC_SKX
 * @vulnerability-type improper-state-cleanup
 * @patch-diff |
 *      @@ -116,6 +116,7 @@ EXPORT_SYMBOL_GPL(skx_adxl_get);
 *       
 *       void skx_adxl_put(void)
 *       {
 *      +	adxl_component_count = 0;
 *       	kfree(adxl_values);
 *       	kfree(adxl_msg);
 *       }
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38298
 * @remediation
 * @patch-description |
 *     EDAC/skx_common: Fix general protection fault
 *     After loading i10nm_edac (which automatically loads skx_edac_common), if
 *     unload only i10nm_edac, then reload it and perform error injection testing,
 *     a general protection fault may occur:
 *     
 *       mce: [Hardware Error]: Machine check events logged
 *       Oops: general protection fault ...
 *       ...
 *       Workqueue: events mce_gen_pool_process
 *       RIP: 0010:string+0x53/0xe0
 *       ...
 *       Call Trace:
 *       <TASK>
 *       ? die_addr+0x37/0x90
 *       ? exc_general_protection+0x1e7/0x3f0
 *       ? asm_exc_general_protection+0x26/0x30
 *       ? string+0x53/0xe0
 *       vsnprintf+0x23e/0x4c0
 *       snprintf+0x4d/0x70
 *       skx_adxl_decode+0x16a/0x330 [skx_edac_common]
 *       skx_mce_check_error.part.0+0xf8/0x220 [skx_edac_common]
 *       skx_mce_check_error+0x17/0x20 [skx_edac_common]
 *       ...
 *     
 *     The issue arose was because the variable 'adxl_component_count' (inside
 *     skx_edac_common), which counts the ADXL components, was not reset. During
 *     the reloading of i10nm_edac, the count was incremented by the actual number
 *     of ADXL components again, resulting in a count that was double the real
 *     number of ADXL components. This led to an out-of-bounds reference to the
 *     ADXL component array, causing the general protection fault above.
 *     
 *     Fix this issue by resetting the 'adxl_component_count' in adxl_put(),
 *     which is called during the unloading of {skx,i10nm}_edac.
 */

import cpp

// 定义全局变量
class GlobalCounter extends GlobalVariable {
  GlobalCounter() {
    // 匹配名为 adxl_component_count 的全局变量
    this.getName() = "adxl_component_count"
  }
}

// 定义清理函数
class CleanupFunction extends Function {
  CleanupFunction() {
    // 匹配名为 skx_adxl_put 的函数
    this.getName() = "skx_adxl_put"
  }
}

from CleanupFunction cleanup, GlobalCounter counter
where
  // 在清理函数中查找对计数器的赋值操作
  not exists(Assignment a |
    a.getEnclosingFunction() = cleanup and
    a.getLValue().(VariableAccess).getTarget() = counter and
    a.getRValue().getValue() = "0"
  )
select cleanup,
  "清理函数 '" + cleanup.getName() + "' 未重置全局计数器 '" + counter.getName() +
    "'，可能导致模块重载时计数错误"