# CVE-2025-38350

```c
// --- 被删除的旧代码 ---
if (n == 0 && len == 0) return;
```

**只有当 n 或 len 大于 0 时，队列的状态才会发生需要通知的变化**。

存在这样一种情况：队列可能因为其他原因（例如，时间到期、内部状态转换等）变为空队列，而此时 qdisc_tree_reduce_backlog 函数恰好是以 n=0 和 len=0 的参数被调用的。

在这种情况下，这个 if 语句会导致函数过早退出，**根本没有机会进入 while 循环去检查 sch->q.qlen 是否为 0**。

```c
// --- 被删除的旧代码 ---
notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&
                                       !qdisc_is_offloaded);
```

其意图是：**仅在子队列“刚刚”变为空时才通知父队列**。

- !sch->q.qlen: 这是基本条件，即子队列当前为空。
- !WARN_ON_ONCE(...): 这是问题的关键。它试图防止在队列**已经为空**的情况下（此时调用函数的参数 n 为0），再次发送通知。它认为如果队列本来就是空的，父队列的状态就已经是正确的，无需重复通知。

在多处理器或高并发环境下，状态检查和通知操作不是原子的。有可能在检查 sch->q.qlen 之后、调用 qlen_notify 之前，队列的状态再次发生变化，导致 WARN_ON_ONCE 做出错误的判断，最终**遗漏了一次必要的通知**。

最终结果是，子队列已经空了，但父队列却可能没有收到通知，仍然认为子队列是活动的。



```c
// --- 修改后的新代码 ---
notify = !sch->q.qlen;
```

补丁将 notify 的条件简化为最本质的形式：**只要子队列是空的，就满足通知条件**。





1. Use-After-Free。
2. 依赖输入参数 n 的复杂判断逻辑和错误的提前退出优化，导致在队列真实状态变为空时，错过了关键的状态更新通知。
3. 通过移除错误逻辑，强制代码总是依赖队列的真实状态 (qlen) 来决定是否发送通知，从根本上保证了状态的最终一致性。