/**
 * @name CVE-2024-58083
 * @description KVM’s kvm_get_vcpu() clamped the requested vCPU index with array_index_nospec()
 * before verifying that the vCPU was online. With a “bad” index, clamping to 0
 * could return vCPU0 instead of NULL, exposing a not-yet-online vCPU. With the
 * vCPU array converted to an xarray, this could lead to a use-after-free if vCPU0
 * access occurred while creation later failed and freed it. The fix first checks
 * i >= online_vcpus and returns NULL before nospec clamping.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/kvm-get-vcpu-verify-online-before-nospec
 * @tags
 *  security
 *  reliability
 *  memory-safety
 *  use-after-free
 *  bounds-check
 *  speculation
 *  spectre-v1
 *  kvm
 * @patch-commit f2f805ada63b536bc192458a7098388286568ad4
 * @source-file include/linux/kvm_host.h
 * @affected-function kvm_get_vcpu
 * @vulnerability-type use-after-free
 * @patch-diff |
 *  diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
 *  index 85fe9d0ebb9152…2c66ca21801c17 100644
 *  — a/include/linux/kvm_host.h
 *  +++ b/include/linux/kvm_host.h
 *  @@ -969,6 +969,15 @@ static inline struct kvm_io_bus *kvm_get_bus(struct kvm *kvm, enum kvm_bus idx)
 *  static inline struct kvm_vcpu *kvm_get_vcpu(struct kvm kvm, int i)
 *  {
 *  int num_vcpus = atomic_read(&kvm->online_vcpus);
 *  +
 *  + /*
 *  +  * Explicitly verify the target vCPU is online, as the anti-speculation
 *  +  * logic only limits the CPU’s ability to speculate, e.g. given a “bad”
 *  +  * index, clamping the index to 0 would return vCPU0, not NULL.
 *  +  &#47;
 *  + if (i >= num_vcpus)
 *  + return NULL;
 *  +
 *  i = array_index_nospec(i, num_vcpus);
 *
 *  /* Pairs with smp_wmb() in kvm_vm_ioctl_create_vcpu. &#47;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f2f805ada63b536bc192458a7098388286568ad4
 * @remediation In kvm_get_vcpu(), validate i against online_vcpus before invoking
 * array_index_nospec(). If i >= online_vcpus, return NULL. This prevents
 * erroneously exposing vCPU0 for out-of-range indices and avoids potential
 * use-after-free when vCPU0 creation fails after being temporarily visible.
 * @patch-description |
 *  KVM: Explicitly verify target vCPU is online in kvm_get_vcpu()
 *  commit 1e7381f3617d14b3c11da80ff5f8a93ab14cfc46 upstream.
 *  
 *  Explicitly verify the target vCPU is fully online _prior_ to clamping the
 *  index in kvm_get_vcpu().  If the index is "bad", the nospec clamping will
 *  generate '0', i.e. KVM will return vCPU0 instead of NULL.
 *
 *  In practice, the bug is unlikely to cause problems, as it will only come
 *  into play if userspace or the guest is buggy or misbehaving, e.g. KVM may
 *  send interrupts to vCPU0 instead of dropping them on the floor.
 *  
 *  However, returning vCPU0 when it shouldn't exist per online_vcpus is
 *  problematic now that KVM uses an xarray for the vCPUs array, as KVM needs
 *  to insert into the xarray before publishing the vCPU to userspace (see
 *  commit c5b077549136 ("KVM: Convert the kvm->vcpus array to a xarray")),
 *  i.e. before vCPU creation is guaranteed to succeed.
 *
 *  As a result, incorrectly providing access to vCPU0 will trigger a
 *  use-after-free if vCPU0 is dereferenced and kvm_vm_ioctl_create_vcpu()
 *  bails out of vCPU creation due to an error and frees vCPU0.  Commit
 *  afb2acb2e3a3 ("KVM: Fix vcpu_array[0] races") papered over that issue, but
 *  in doing so introduced an unsolvable teardown conundrum.  Preventing
 *  accesses to vCPU0 before it's fully online will allow reverting commit
 *  afb2acb2e3a3, without re-introducing the vcpu_array[0] UAF race.
 *  
 *  Fixes: 1d487e9bf8ba ("KVM: fix spectrev1 gadgets")
 */

import cpp

/*
 * 检测KVM中的vCPU在线状态验证漏洞
 * 该查询用于识别在kvm_get_vcpu函数中未验证vCPU在线状态的情况
 * 这可能导致返回错误的vCPU0而不是NULL，造成use-after-free安全问题
 * This query identifies missing vCPU online state verification in kvm_get_vcpu function
 * which may return incorrect vCPU0 instead of NULL, leading to use-after-free security issues
 */

// 检查是否为kvm_get_vcpu函数
// Check if it's kvm_get_vcpu function
predicate isKvmGetVcpuFunction(Function f) {
  f.getName() = "kvm_get_vcpu"
}

// 检查是否为array_index_nospec函数调用
// Check if it's array_index_nospec function call
predicate isArrayIndexNospecCall(FunctionCall fc) {
  fc.getTarget().getName() = "array_index_nospec"
}



// 检查是否有在线状态验证
// Check for online state verification
predicate hasOnlineStateVerification(FunctionCall nospecCall) {
  exists(IfStmt ifStmt |
    ifStmt.getLocation().getStartLine() < nospecCall.getLocation().getStartLine() and
    ifStmt.getCondition().toString().matches("%i >= num_vcpus%") and
    exists(ReturnStmt returnStmt |
      returnStmt = ifStmt.getThen().getAChild() and
      returnStmt.getExpr().toString() = "NULL"
    )
  )
}

from
  Function f,
  FunctionCall nospecCall  // array_index_nospec调用
where
  // 限制在kvm_get_vcpu函数内
  isKvmGetVcpuFunction(f) and
  nospecCall.getEnclosingFunction() = f and
  // 查找array_index_nospec调用
  isArrayIndexNospecCall(nospecCall) and
  // 没有在线状态验证
  not hasOnlineStateVerification(nospecCall)
select
  nospecCall,
  "Potential security issue: Missing vCPU online state verification in kvm_get_vcpu(), may return incorrect vCPU0 instead of NULL"