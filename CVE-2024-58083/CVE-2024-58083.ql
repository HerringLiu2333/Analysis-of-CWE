/**
 * @name CVE-2024-58083
 * @description KVM’s kvm_get_vcpu() clamped the requested vCPU index with array_index_nospec()
 * before verifying that the vCPU was online. With a “bad” index, clamping to 0
 * could return vCPU0 instead of NULL, exposing a not-yet-online vCPU. With the
 * vCPU array converted to an xarray, this could lead to a use-after-free if vCPU0
 * access occurred while creation later failed and freed it. The fix first checks
 * i >= online_vcpus and returns NULL before nospec clamping.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/kvm-get-vcpu-verify-online-before-nospec
 * @tags
 *  security
 *  reliability
 *  memory-safety
 *  use-after-free
 *  bounds-check
 *  speculation
 *  spectre-v1
 *  kvm
 * @patch-commit f2f805ada63b536bc192458a7098388286568ad4
 * @source-file include/linux/kvm_host.h
 * @affected-function kvm_get_vcpu
 * @vulnerability-type use-after-free
 * @patch-diff |
 *  diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
 *  index 85fe9d0ebb9152…2c66ca21801c17 100644
 *  — a/include/linux/kvm_host.h
 *  +++ b/include/linux/kvm_host.h
 *  @@ -969,6 +969,15 @@ static inline struct kvm_io_bus *kvm_get_bus(struct kvm *kvm, enum kvm_bus idx)
 *  static inline struct kvm_vcpu *kvm_get_vcpu(struct kvm kvm, int i)
 *  {
 *  int num_vcpus = atomic_read(&kvm->online_vcpus);
 *  +
 *  + /*
 *  +  * Explicitly verify the target vCPU is online, as the anti-speculation
 *  +  * logic only limits the CPU’s ability to speculate, e.g. given a “bad”
 *  +  * index, clamping the index to 0 would return vCPU0, not NULL.
 *  +  &#47;
 *  + if (i >= num_vcpus)
 *  + return NULL;
 *  +
 *  i = array_index_nospec(i, num_vcpus);
 *
 *  /* Pairs with smp_wmb() in kvm_vm_ioctl_create_vcpu. &#47;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f2f805ada63b536bc192458a7098388286568ad4
 * @remediation In kvm_get_vcpu(), validate i against online_vcpus before invoking
 * array_index_nospec(). If i >= online_vcpus, return NULL. This prevents
 * erroneously exposing vCPU0 for out-of-range indices and avoids potential
 * use-after-free when vCPU0 creation fails after being temporarily visible.
 */

import cpp

/*
 * 检测KVM中的vCPU在线状态验证漏洞
 * 该查询用于识别在kvm_get_vcpu函数中未验证vCPU在线状态的情况
 * 这可能导致返回错误的vCPU0而不是NULL，造成use-after-free安全问题
 * This query identifies missing vCPU online state verification in kvm_get_vcpu function
 * which may return incorrect vCPU0 instead of NULL, leading to use-after-free security issues
 */

// 检查是否为kvm_get_vcpu函数
// Check if it's kvm_get_vcpu function
predicate isKvmGetVcpuFunction(Function f) {
  f.getName() = "kvm_get_vcpu"
}

// 检查是否为array_index_nospec函数调用
// Check if it's array_index_nospec function call
predicate isArrayIndexNospecCall(FunctionCall fc) {
  fc.getTarget().getName() = "array_index_nospec"
}



// 检查是否有在线状态验证
// Check for online state verification
predicate hasOnlineStateVerification(FunctionCall nospecCall) {
  exists(IfStmt ifStmt |
    ifStmt.getLocation().getStartLine() < nospecCall.getLocation().getStartLine() and
    ifStmt.getCondition().toString().matches("%i >= num_vcpus%") and
    exists(ReturnStmt returnStmt |
      returnStmt = ifStmt.getThen().getAChild() and
      returnStmt.getExpr().toString() = "NULL"
    )
  )
}

from
  Function f,
  FunctionCall nospecCall  // array_index_nospec调用
where
  // 限制在kvm_get_vcpu函数内
  isKvmGetVcpuFunction(f) and
  nospecCall.getEnclosingFunction() = f and
  // 查找array_index_nospec调用
  isArrayIndexNospecCall(nospecCall) and
  // 没有在线状态验证
  not hasOnlineStateVerification(nospecCall)
select
  nospecCall,
  "Potential security issue: Missing vCPU online state verification in kvm_get_vcpu(), may return incorrect vCPU0 instead of NULL"