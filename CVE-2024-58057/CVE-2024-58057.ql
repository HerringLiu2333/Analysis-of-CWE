/**
 * @name CVE-2024-58057
 * @description IDPF used CPU-bound workqueues, so if a kworker’s CPU was heavily loaded,
 *  driver work could be starved, causing long delays, timeouts, and crashes.
 *  The fix converts all driver workqueues to WQ_UNBOUND | WQ_MEM_RECLAIM so
 *  work can migrate to other CPUs in the NUMA node and make progress even
 *  under per-CPU contention.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/bound-workqueue-starvation
 * @tags 
 *  availability
 *  reliability
 *  performance
 *  scheduling
 *  workqueue
 * @patch-commit 9a5b021cb8186f1854bac2812bd4f396bb1e881c
 * @source-file drivers/net/ethernet/intel/idpf/idpf_main.c
 * @affected-function idpf_probe
 * @vulnerability-type workqueue-starvation
 * @patch-diff |
 *  diff --git a/drivers/net/ethernet/intel/idpf/idpf_main.c b/drivers/net/ethernet/intel/idpf/idpf_main.c
 *  index f71d3182580b6a…b6c515d14cbf08 100644
 *  --- a/drivers/net/ethernet/intel/idpf/idpf_main.c
 *  +++ b/drivers/net/ethernet/intel/idpf/idpf_main.c
 *  @@ -174,7 +174,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 *  pci_set_master(pdev);
 *  pci_set_drvdata(pdev, adapter);
 *
 *  - adapter->init_wq = alloc_workqueue("%s-%s-init", 0, 0,
 *  + adapter->init_wq = alloc_workqueue("%s-%s-init",
 *  + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
 *    dev_driver_string(dev),
 *    dev_name(dev));
 *  if (!adapter->init_wq) {
 *  @@ -183,7 +184,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 *    goto err_free;
 *    }
 *
 *  - adapter->serv_wq = alloc_workqueue("%s-%s-service", 0, 0,
 *  + adapter->serv_wq = alloc_workqueue("%s-%s-service",
 *  + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
 *    dev_driver_string(dev),
 *    dev_name(dev));
 *    if (!adapter->serv_wq) {
 *  @@ -192,7 +194,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 *    goto err_serv_wq_alloc;
 *    }
 *
 *  - adapter->mbx_wq = alloc_workqueue("%s-%s-mbx", 0, 0,
 *  + adapter->mbx_wq = alloc_workqueue("%s-%s-mbx",
 *  + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
 *    dev_driver_string(dev),
 *    dev_name(dev));
 *    if (!adapter->mbx_wq) {
 *  @@ -201,7 +204,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 *    goto err_mbx_wq_alloc;
 *    }
 *
 *  - adapter->stats_wq = alloc_workqueue("%s-%s-stats", 0, 0,
 *  + adapter->stats_wq = alloc_workqueue("%s-%s-stats",
 *  + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
 *    dev_driver_string(dev),
 *    dev_name(dev));
 *    if (!adapter->stats_wq) {
 *  @@ -210,7 +214,8 @@ static int idpf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 *    goto err_stats_wq_alloc;
 *    }
 *
 *  - adapter->vc_event_wq = alloc_workqueue("%s-%s-vc_event", 0, 0,
 *  + adapter->vc_event_wq = alloc_workqueue("%s-%s-vc_event",
 *  + WQ_UNBOUND | WQ_MEM_RECLAIM, 0,
 *    dev_driver_string(dev),
 *    dev_name(dev));
 *    if (!adapter->vc_event_wq) {
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9a5b021cb8186f1854bac2812bd4f396bb1e881c
 * @remediation For driver work that must make progress regardless of a single CPU’s load,
 *  create workqueues with WQ_UNBOUND | WQ_MEM_RECLAIM. Avoid pinning work to a
 *  specific CPU unless strict affinity is required; let the scheduler select an
 *  available worker to prevent starvation under CPU hogging.
 * @patch-description |
 *  idpf: convert workqueues to unbound
 *  When a workqueue is created with `WQ_UNBOUND`, its work items are
 *  served by special worker-pools, whose host workers are not bound to
 *  any specific CPU. In the default configuration (i.e. when
 *  `queue_delayed_work` and friends do not specify which CPU to run the
 *  work item on), `WQ_UNBOUND` allows the work item to be executed on any
 *  CPU in the same node of the CPU it was enqueued on. While this
 *  solution potentially sacrifices locality, it avoids contention with
 *  other processes that might dominate the CPU time of the processor the
 *  work item was scheduled on.
 *  
 *  This is not just a theoretical problem: in a particular scenario
 *  misconfigured process was hogging most of the time from CPU0, leaving
 *  less than 0.5% of its CPU time to the kworker. The IDPF workqueues
 *  that were using the kworker on CPU0 suffered large completion delays
 *  as a result, causing performance degradation, timeouts and eventual
 *  system crash.
 *  
 *  Tested:
 *
 *  * I have also run a manual test to gauge the performance
 *    improvement. The test consists of an antagonist process
 *    (`./stress --cpu 2`) consuming as much of CPU 0 as possible. This
 *    process is run under `taskset 01` to bind it to CPU0, and its
 *    priority is changed with `chrt -pQ 9900 10000 ${pid}` and
 *    `renice -n -20 ${pid}` after start.

 *    Then, the IDPF driver is forced to prefer CPU0 by editing all calls
 *    to `queue_delayed_work`, `mod_delayed_work`, etc... to use CPU 0.
 *  
 *    Finally, `ktraces` for the workqueue events are collected.
 *  
 *    Without the current patch, the antagonist process can force
 *    arbitrary delays between `workqueue_queue_work` and
 *    `workqueue_execute_start`, that in my tests were as high as
 *    `30ms`. With the current patch applied, the workqueue can be
 *    migrated to another unloaded CPU in the same node, and, keeping
 *    everything else equal, the maximum delay I could see was `6us`.
 *  
 *  Fixes: 0fe45467a104 ("idpf: add create vport and netdev configuration")
 */

import cpp

/*
 * 检测IDPF驱动中的工作队列配置问题
 * 该查询用于识别alloc_workqueue调用中未使用WQ_UNBOUND标志的情况
 * 缺少WQ_UNBOUND标志可能导致工作队列在CPU绑定时出现性能问题和系统崩溃
 * This query identifies alloc_workqueue calls missing WQ_UNBOUND flag in IDPF driver
 * which can cause performance degradation and system crashes when workqueues are CPU-bound
 */

// 检查是否为alloc_workqueue函数调用
// Check if it's alloc_workqueue function call
predicate isAllocWorkqueueCall(FunctionCall fc) {
  fc.getTarget().getName() = "alloc_workqueue"
}

// 检查是否为IDPF驱动文件
// Check if it's IDPF driver file
predicate isIdpfDriverFile(File f) {
  f.getBaseName() = "idpf_main.c"
}

// 检查alloc_workqueue调用是否缺少WQ_UNBOUND标志
// Check if alloc_workqueue call is missing WQ_UNBOUND flag
predicate isMissingWqUnboundFlag(FunctionCall fc) {
  // 检查第二个参数（flags参数）是否不包含WQ_UNBOUND和WQ_MEM_RECLAIM
  not fc.getArgument(1).getChild(0).toString().matches("%WQ_UNBOUND%") and
  not fc.getArgument(1).getChild(0).toString().matches("%WQ_MEM_RECLAIM%") 
}

from
  FunctionCall allocCall  // alloc_workqueue调用
where
  // 限制在IDPF驱动文件中
  isIdpfDriverFile(allocCall.getFile()) and
  // 查找alloc_workqueue调用
  isAllocWorkqueueCall(allocCall) and
  // 检查是否缺少WQ_UNBOUND标志
  isMissingWqUnboundFlag(allocCall)
select
  allocCall,
  "Potential performance issue: alloc_workqueue() call missing WQ_UNBOUND flag, may cause CPU contention and system crashes"