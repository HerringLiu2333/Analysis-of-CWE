/**
 * @name CVE-2025-38317
 * @description Detects a buffer overflow vulnerability in the ath12k driver's debugfs interface.
 *              The function `ath12k_write_htt_stats_type` allocates a fixed-size buffer but fails
 *              to validate the size of the user-provided input before copying it, leading to potential
 *              memory corruption if the input size exceeds the buffer's capacity.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/buffer-overflow-ath12k-debugfs
 * @tags security
 *       correctness
 *       external/cwe/cwe-120
 * @patch-commit 8c7a5031a6b0d42e640fbd2d5d05f61f74e32dce
 * @source-file drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
 * @affected-function ath12k_write_htt_stats_type
 * @kernel-config CONFIG_ATH12K
 * @vulnerability-type buffer-overflow
 * @patch-diff |
 *      @@ -5377,6 +5377,9 @@ static ssize_t ath12k_write_htt_stats_type(struct file *file,
 *       	const int size = 32;
 *       	int num_args;
 *       
 *      +	if (count > size)
 *      +		return -EINVAL;
 *      +
 *       	char *buf __free(kfree) = kzalloc(size, GFP_KERNEL);
 *       	if (!buf)
 *       		return -ENOMEM;
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38317
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow
import semmle.code.cpp.dataflow.new.TaintTracking

module BufferOverflowConfig implements DataFlow::ConfigSig {
  /**
   * 定义污点源：函数参数 `count`，表示用户输入的数据长度
   */
  predicate isSource(DataFlow::Node source) {
    exists(Parameter param, Function f |
      // 源头是函数参数
      source.asParameter() = param and
      // 参数名为 count
      param.getName() = "count" and
      // 该参数必须位于目标函数内部
      f = param.getFunction() and
      f.getName() = "ath12k_write_htt_stats_type" and
      // 该函数必须位于指定文件中
      f.getFile().getRelativePath().matches("*debugfs_htt_stats.c")
    )
  }

  /**
   * 定义污点汇：内存拷贝函数的长度参数位置
   */
  predicate isSink(DataFlow::Node sink) {
    exists(FunctionCall call, Function f |
      // 汇是函数调用的长度参数
      (
        // copy_from_user 的第三个参数（长度）
        (call.getTarget().getName() = "copy_from_user" and
         sink.asExpr() = call.getArgument(2)) or
        // memcpy 的第三个参数（长度）
        (call.getTarget().getName() = "memcpy" and
         sink.asExpr() = call.getArgument(2)) or
        // strncpy 的第三个参数（长度）
        (call.getTarget().getName() = "strncpy" and
         sink.asExpr() = call.getArgument(2))
      ) and
      // 该调用必须位于目标函数内部
      f = call.getEnclosingFunction() and
      f.getName() = "ath12k_write_htt_stats_type" and
      // 该函数必须位于指定文件中
      f.getFile().getRelativePath().matches("*debugfs_htt_stats.c") and
      // 确保存在固定大小的缓冲区分配
      exists(FunctionCall allocCall |
        allocCall.getTarget().getName() = "kzalloc" and
        allocCall.getEnclosingFunction() = f and
        allocCall.getArgument(0).(Literal).getValue().toInt() <= 64 // 检查小缓冲区
      )
    )
  }

  /**
   * 定义屏障：长度检查操作，阻止污点数据流向危险函数
   */
  predicate isBarrier(DataFlow::Node barrier) {
    exists(IfStmt ifStmt, ComparisonOperation comp |
      // 检查 if (count > size) 或 if (count >= size) 模式
      ifStmt.getCondition() = comp and
      (
        (comp instanceof GTExpr and
         barrier.asExpr() = comp.getLeftOperand()) or
        (comp instanceof GEExpr and
         barrier.asExpr() = comp.getLeftOperand())
      ) and
      // 确保条件分支中包含返回语句
      exists(ReturnStmt retStmt |
        ifStmt.getThen().getAChild*() = retStmt and
        retStmt.getExpr().(UnaryMinusExpr).getOperand().(Literal).getValue() = "22" // -EINVAL
      )
    ) or
    // 其他类型的边界检查
    exists(FunctionCall boundCheck |
      boundCheck.getTarget().getName().matches("*check*") and
      barrier.asExpr() = boundCheck.getAnArgument()
    )
  }
}

// 使用上面定义的配置模块来实例化一个全局的污点跟踪分析模块
module BufferOverflowFlow = TaintTracking::Global<BufferOverflowConfig>;

// 从实例化的分析模块中导入专用的 PathGraph，用于路径查询
import BufferOverflowFlow::PathGraph

// 查询污点数据流路径
from BufferOverflowFlow::PathNode source, BufferOverflowFlow::PathNode sink
where BufferOverflowFlow::flowPath(source, sink)
select sink.getNode(), source, sink, 
       "缓冲区溢出漏洞：用户输入的长度参数 '" + source.getNode().asParameter().getName() + 
       "' 在第" + source.getNode().getLocation().getStartLine() + "行未经边界检查，" +
       "直接流向第" + sink.getNode().getLocation().getStartLine() + "行的内存拷贝操作，" +
       "可能导致缓冲区溢出。建议在内存拷贝前添加长度检查。"