/**
 * @name CVE-2025-39735 JFS扩展属性大小验证不足导致整数溢出
 * @description 检测在JFS文件系统中，EALIST_SIZE宏返回的扩展属性大小未经INT_MAX验证
 *              就被用于clamp_t转换，可能导致整数溢出和后续的内存越界访问
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/jfs-xattr-size-overflow
 * @tags security
 *       external/cwe/cwe-190
 *       external/cwe/cwe-125
 */

import cpp

/**
 * 表示EALIST_SIZE宏调用
 */
class EalistSizeMacro extends MacroInvocation {
  EalistSizeMacro() {
    this.getMacroName() = "EALIST_SIZE"
  }
}

/**
 * 表示clamp_t宏调用
 */
class ClampTMacro extends MacroInvocation {
  ClampTMacro() {
    this.getMacroName() = "clamp_t"
  }
}

/**
 * 表示print_hex_dump函数调用
 */
class PrintHexDumpCall extends FunctionCall {
  PrintHexDumpCall() {
    this.getTarget().getName() = "print_hex_dump"
  }
  
  /**
   * 获取长度参数（第8个参数，索引为7）
   */
  Expr getLengthArg() {
    result = this.getArgument(7)
  }
}

/**
 * 表示大小相关的变量
 */
class SizeVariable extends Variable {
  SizeVariable() {
    this.getName().regexpMatch(".*size.*") and
    this.getType() instanceof IntType
  }
}

/**
 * 检查给定位置附近是否存在INT_MAX检查
 */
predicate hasIntMaxCheck(Location loc) {
  exists(ComparisonOperation comp |
    comp.getLocation().getFile() = loc.getFile() and
    // 在同一行或前几行
    comp.getLocation().getStartLine() >= loc.getStartLine() - 10 and
    comp.getLocation().getStartLine() <= loc.getStartLine() + 10 and
    // 比较操作中包含INT_MAX
    comp.toString().regexpMatch(".*INT_MAX.*")
  )
}

/**
 * 检查是否在ea_get函数中
 */
predicate inEaGetFunction(Locatable elem) {
  exists(Function f |
    f.getName() = "ea_get" and
    elem.getLocation().getFile() = f.getLocation().getFile() and
    elem.getLocation().getStartLine() >= f.getLocation().getStartLine() and
    elem.getLocation().getEndLine() <= f.getLocation().getEndLine()
  )
}

/**
 * 检查是否在xattr.c文件中
 */
predicate inXattrFile(Locatable elem) {
  elem.getLocation().getFile().getBaseName() = "xattr.c"
}

from EalistSizeMacro ealistSize, ClampTMacro clampT, PrintHexDumpCall hexDump, SizeVariable sizeVar
where 
  // 都在同一个文件系统文件中
  inXattrFile(ealistSize) and
  inXattrFile(clampT) and
  inXattrFile(hexDump) and
  
  // 都在ea_get函数中
  inEaGetFunction(ealistSize) and
  inEaGetFunction(clampT) and
  inEaGetFunction(hexDump) and
  
  // EALIST_SIZE调用在clamp_t之前
  ealistSize.getLocation().getStartLine() < clampT.getLocation().getStartLine() and
  
  // clamp_t在print_hex_dump之前
  clampT.getLocation().getStartLine() < hexDump.getLocation().getStartLine() and
  
  // 存在size变量的赋值，其值来自clamp_t
  exists(AssignExpr assign |
    assign.getLValue() = sizeVar.getAnAccess() and
    assign.getLocation().getStartLine() = clampT.getLocation().getStartLine() and
    inXattrFile(assign)
  ) and
  
  // size变量被用作print_hex_dump的长度参数
  hexDump.getLengthArg() = sizeVar.getAnAccess() and
  
  // 没有INT_MAX验证
  not hasIntMaxCheck(ealistSize.getLocation()) and
  
  // 确保在size_check代码块中（通过行号范围判断）
  ealistSize.getLocation().getStartLine() >= 560 and
  ealistSize.getLocation().getStartLine() <= 580

select hexDump, "潜在的内存越界访问：扩展属性大小 $@ 未经INT_MAX验证通过clamp_t $@ 转换后用于 $@，当EALIST_SIZE返回超过INT_MAX的值时会导致整数溢出和越界读取", 
       ealistSize, "EALIST_SIZE宏调用", 
       clampT, "clamp_t宏调用",
       hexDump.getLengthArg(), "print_hex_dump长度参数"