/**
 * @name CVE-2025-39735
 * @description Detects an integer overflow vulnerability in the JFS filesystem's `ea_get` function.
 *              When processing a crafted filesystem with an extended attribute size larger than INT_MAX,
 *              the size value (a u32) is cast to a signed int for a clamp operation, causing it to
 *              wrap around and become negative. This negative value is then passed to `print_hex_dump`
 *              where it is reinterpreted as a very large unsigned `size_t`. This breaks the loop
 *              termination condition within the hex dump logic, leading to a slab-out-of-bounds read
 *              and a potential kernel panic.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/jfs-integer-overflow-oob-read
 * @tags security
 *       correctness
 *       integer-overflow
 *       out-of-bounds-read
 *       external/cwe/cwe-190
 *       external/cwe/cwe-125
 * @patch-commit fdf480da5837c23b146c4743c18de97202fcab37
 * @source-file fs/jfs/xattr.c
 * @affected-function ea_get
 * @kernel-config CONFIG_JFS_FS
 * @vulnerability-type integer-overflow, out-of-bounds-read
 * @patch-diff |
 *     @@ -559,11 +559,16 @@ static int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)
 *      
 *            size_check:
 *      	if (EALIST_SIZE(ea_buf->xattr) != ea_size) {
 * -		int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));
 * -
 * -		printk(KERN_ERR "ea_get: invalid extended attribute\n");
 * -		print_hex_dump(KERN_ERR, "", DUMP_PREFIX_ADDRESS, 16, 1,
 * -				     ea_buf->xattr, size, 1);
 * +		if (unlikely(EALIST_SIZE(ea_buf->xattr) > INT_MAX)) {
 * +			printk(KERN_ERR "ea_get: extended attribute size too large: %u > INT_MAX\n",
 * +			       EALIST_SIZE(ea_buf->xattr));
 * +		} else {
 * +			int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));
 * +
 * +			printk(KERN_ERR "ea_get: invalid extended attribute\n");
 * +			print_hex_dump(KERN_ERR, "", DUMP_PREFIX_ADDRESS, 16, 1,
 * +				       ea_buf->xattr, size, 1);
 * +		}
 *      		ea_release(inode, ea_buf);
 *      		rc = -EIO;
 *      		goto clean_up;
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-39735
 * @remediation 
 * @patch-description |
 *     jfs: fix slab-out-of-bounds read in ea_get()
 *     commit fdf480da5837c23b146c4743c18de97202fcab37 upstream.
 *     
 *     During the "size_check" label in ea_get(), the code checks if the extended
 *     attribute list (xattr) size matches ea_size. If not, it logs
 *     "ea_get: invalid extended attribute" and calls print_hex_dump().
 *     
 *     Here, EALIST_SIZE(ea_buf->xattr) returns 4110417968, which exceeds
 *     INT_MAX (2,147,483,647). Then ea_size is clamped:
 *     
 *     	int size = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));
 *     
 *     Although clamp_t aims to bound ea_size between 0 and 4110417968, the upper
 *     limit is treated as an int, causing an overflow above 2^31 - 1. This leads
 *     "size" to wrap around and become negative (-184549328).
 *     
 *     The "size" is then passed to print_hex_dump() (called "len" in
 *     print_hex_dump()), it is passed as type size_t (an unsigned
 *     type), this is then stored inside a variable called
 *     "int remaining", which is then assigned to "int linelen" which
 *     is then passed to hex_dump_to_buffer(). In print_hex_dump()
 *     the for loop, iterates through 0 to len-1, where len is
 *     18446744073525002176, calling hex_dump_to_buffer()
 *     on each iteration:
 *     
 *     	for (i = 0; i < len; i += rowsize) {
 *     		linelen = min(remaining, rowsize);
 *     		remaining -= rowsize;
 *     
 *     		hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,
 *     				   linebuf, sizeof(linebuf), ascii);
 *     
 *     		...
 *     	}
 *     
 *     The expected stopping condition (i < len) is effectively broken
 *     since len is corrupted and very large. This eventually leads to
 *     the "ptr+i" being passed to hex_dump_to_buffer() to get closer
 *     to the end of the actual bounds of "ptr", eventually an out of
 *     bounds access is done in hex_dump_to_buffer() in the following
 *     for loop:
 *     
 *     	for (j = 0; j < len; j++) {
 *     			if (linebuflen < lx + 2)
 *     				goto overflow2;
 *     			ch = ptr[j];
 *     		...
 *     	}
 *     
 *     To fix this we should validate "EALIST_SIZE(ea_buf->xattr)"
 *     before it is utilised.
 */

import cpp

/**
 * 表示EALIST_SIZE宏调用
 */
class EalistSizeMacro extends MacroInvocation {
  EalistSizeMacro() {
    this.getMacroName() = "EALIST_SIZE"
  }
}

/**
 * 表示clamp_t宏调用
 */
class ClampTMacro extends MacroInvocation {
  ClampTMacro() {
    this.getMacroName() = "clamp_t"
  }
}

/**
 * 表示print_hex_dump函数调用
 */
class PrintHexDumpCall extends FunctionCall {
  PrintHexDumpCall() {
    this.getTarget().getName() = "print_hex_dump"
  }
  
  /**
   * 获取长度参数（第8个参数，索引为7）
   */
  Expr getLengthArg() {
    result = this.getArgument(7)
  }
}

/**
 * 表示大小相关的变量
 */
class SizeVariable extends Variable {
  SizeVariable() {
    this.getName().regexpMatch(".*size.*") and
    this.getType() instanceof IntType
  }
}

/**
 * 检查给定位置附近是否存在INT_MAX检查
 */
predicate hasIntMaxCheck(Location loc) {
  exists(ComparisonOperation comp |
    comp.getLocation().getFile() = loc.getFile() and
    // 在同一行或前几行
    comp.getLocation().getStartLine() >= loc.getStartLine() - 10 and
    comp.getLocation().getStartLine() <= loc.getStartLine() + 10 and
    // 比较操作中包含INT_MAX
    comp.toString().regexpMatch(".*INT_MAX.*")
  )
}

/**
 * 检查是否在ea_get函数中
 */
predicate inEaGetFunction(Locatable elem) {
  exists(Function f |
    f.getName() = "ea_get" and
    elem.getLocation().getFile() = f.getLocation().getFile() and
    elem.getLocation().getStartLine() >= f.getLocation().getStartLine() and
    elem.getLocation().getEndLine() <= f.getLocation().getEndLine()
  )
}

/**
 * 检查是否在xattr.c文件中
 */
predicate inXattrFile(Locatable elem) {
  elem.getLocation().getFile().getBaseName() = "xattr.c"
}

from EalistSizeMacro ealistSize, ClampTMacro clampT, PrintHexDumpCall hexDump, SizeVariable sizeVar
where 
  // 都在同一个文件系统文件中
  inXattrFile(ealistSize) and
  inXattrFile(clampT) and
  inXattrFile(hexDump) and
  
  // 都在ea_get函数中
  inEaGetFunction(ealistSize) and
  inEaGetFunction(clampT) and
  inEaGetFunction(hexDump) and
  
  // EALIST_SIZE调用在clamp_t之前
  ealistSize.getLocation().getStartLine() < clampT.getLocation().getStartLine() and
  
  // clamp_t在print_hex_dump之前
  clampT.getLocation().getStartLine() < hexDump.getLocation().getStartLine() and
  
  // 存在size变量的赋值，其值来自clamp_t
  exists(AssignExpr assign |
    assign.getLValue() = sizeVar.getAnAccess() and
    assign.getLocation().getStartLine() = clampT.getLocation().getStartLine() and
    inXattrFile(assign)
  ) and
  
  // size变量被用作print_hex_dump的长度参数
  hexDump.getLengthArg() = sizeVar.getAnAccess() and
  
  // 没有INT_MAX验证
  not hasIntMaxCheck(ealistSize.getLocation()) and
  
  // 确保在size_check代码块中（通过行号范围判断）
  ealistSize.getLocation().getStartLine() >= 560 and
  ealistSize.getLocation().getStartLine() <= 580

select hexDump, "潜在的内存越界访问：扩展属性大小 $@ 未经INT_MAX验证通过clamp_t $@ 转换后用于 $@，当EALIST_SIZE返回超过INT_MAX的值时会导致整数溢出和越界读取", 
       ealistSize, "EALIST_SIZE宏调用", 
       clampT, "clamp_t宏调用",
       hexDump.getLengthArg(), "print_hex_dump长度参数"