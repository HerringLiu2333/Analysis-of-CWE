/**
 * @name Linux Kernel - DAMON sysfs memcg_path Memory Leak
 * @description Detects a memory leak in the DAMON sysfs interface. Writing to the 'memcg_path'
 *              sysfs file assigns a newly allocated buffer to a pointer without freeing the
 *              previously allocated buffer. Repeated writes can exhaust kernel memory, leading
 *              to a denial-of-service (DoS) condition.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/kernel/damon-memcg-path-leak
 * @tags security
 *       correctness
 *       memory
 *       leak
 *       denial-of-service
 *       external/cwe/cwe-401
 * @patch-commit 4f489fe6afb395dbc79840efa3c05440b760d883
 * @source-file mm/damon/sysfs-schemes.c
 * @affected-function memcg_path_store
 * @kernel-config CONFIG_DAMON
 * @vulnerability-type memory-leak
 * @patch-diff |
 *     @@ -472,6 +472,7 @@ static ssize_t memcg_path_store(struct kobject *kobj,
 *      		return -ENOMEM;
 *      
 *      	strscpy(path, buf, count + 1);
 *     +	kfree(filter->memcg_path);
 *      	filter->memcg_path = path;
 *      	return count;
 *      }
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f5769359c5b241978e6933672bb78b3adc36aa18
 * @remediation 
 * @patch-description |
 *     mm/damon/sysfs-schemes: free old damon_sysfs_scheme_filter->memcg_path on write
 *     memcg_path_store() assigns a newly allocated memory buffer to
 *     filter->memcg_path, without deallocating the previously allocated and
 *     assigned memory buffer.  As a result, users can leak kernel memory by
 *     continuously writing a data to memcg_path DAMOS sysfs file.  Fix the leak
 *     by deallocating the previously set memory buffer.```
 */
import cpp
import semmle.code.cpp.controlflow.ControlFlowGraph

predicate isDeallocator(FunctionCall c) {
  exists(string name |
    name in ["kfree", "kvfree", "kfree_sensitive"] and
    c.getTarget().getName() = name
  )
}

// FieldAccess to pointer field
predicate isPointerField(FieldAccess fa) { fa instanceof PointerFieldAccess }

// Structural equality: same qualifier variable AND same field symbol
predicate sameField(FieldAccess a, FieldAccess b) {
  a.getTarget() = b.getTarget() and
  exists(Variable va, Variable vb |
    a.getQualifier() instanceof VariableAccess and
    b.getQualifier() instanceof VariableAccess and
    va = a.getQualifier().(VariableAccess).getTarget() and
    vb = b.getQualifier().(VariableAccess).getTarget() and
    va = vb
  )
}

// Helper: transitive subexpression relation (expression-only)
predicate subExpr(Expr parent, Expr child) {
  parent = child or
  exists(Expr mid | mid = parent.getAChild() and subExpr(mid, child))
}

/* Fallback: 在变量初始化器(可能是 statement expression) 源码范围内，出现对参数的引用 */
predicate initRangeMentionsParam(Variable v, Parameter p) {
  exists(VariableAccess va |
    va.getTarget() = p and
    va.getLocation().getFile() = v.getInitializer().getLocation().getFile() and
    va.getLocation().getStartLine() >= v.getInitializer().getLocation().getStartLine() and
    va.getLocation().getEndLine()   <= v.getInitializer().getLocation().getEndLine()
  )
}

/**
 * Persistent object heuristic:
 * 1. Qualifier is the kobj parameter itself, OR
 * 2. Local variable whose initializer (even after macro expansion into a statement expression)
 *    derives from the kobj parameter:
 *    - either kobj appears as a (transitive) subexpression (simple cases)
 *    - or kobj is referenced somewhere inside the initializer’s source range (covers statement expressions).
 */
predicate isPersistentObject(Expr qual) {
  qual instanceof VariableAccess and
  (
    // kobj parameter itself
    (qual.(VariableAccess).getTarget() instanceof Parameter and
     qual.(VariableAccess).getTarget().getName() = "kobj")
    or
    // local derived from kobj
    exists(Variable v, Parameter k |
      v = qual.(VariableAccess).getTarget() and
      not (v instanceof Parameter) and
      k.getName() = "kobj" and
      (
        // direct subexpression reference (works if kobj not hidden inside stmt expr)
        exists(VariableAccess refK |
          refK.getTarget() = k and
          subExpr(v.getInitializer().getExpr(), refK)
        )
        or
        // fallback: kobj referenced somewhere in initializer source range (covers container_of expansion)
        initRangeMentionsParam(v, k)
      )
    )
  )
}

// Control flow node helper
ControlFlowNode nodeOf(Expr e) { result.getEnclosingElement() = e }

from Assignment asg, FieldAccess lhsFA, Expr rhs
where
  asg.getFile().getBaseName() = "sysfs-schemes.c" and
  lhsFA = asg.getLValue() and
  isPointerField(lhsFA) and
  isPersistentObject(lhsFA.getQualifier()) and
  // 必须是一块动态分配内存的地址
  lhsFA.toString().regexpMatch(".*path*") and

  rhs = asg.getRValue() and

  // // No preceding free-like call on the exact same field (structural match) dominating this assignment
  not exists(FunctionCall freeCall, FieldAccess freedFA |
    isDeallocator(freeCall) and
    freedFA = freeCall.getArgument(0).(FieldAccess) and
    sameField(freedFA, lhsFA) and
    dominates(nodeOf(freeCall).getBasicBlock(), nodeOf(asg).getBasicBlock())
  )
select asg,
  "Potential memory leak: overwrites persistent pointer field '" +
  lhsFA.getTarget().getName() +
  "' with a newly allocated buffer without freeing the previous value (sysfs memcg_path). Add kfree() before this assignment if an old value may exist.",
  lhsFA, rhs