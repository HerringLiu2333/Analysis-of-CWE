import cpp
import semmle.code.cpp.controlflow.ControlFlowGraph

/**
 * 判断表达式 e 是否代表一个应被释放的堆分配指针，例如通过 kfree 释放。
 */
predicate isHeapAllocatedPointer(Expr e) {
  // 一个简单的启发式规则：任何指针类型的变量都可能持有堆内存。
  // 这是一个宽泛的假设，用于避免数据流分析，可能会产生更多结果。
  e.getType().getUnspecifiedType() instanceof PointerType
}

/**
 * 获取给定表达式的控制流节点。
 */
ControlFlowNode getControlFlowNode(Expr e) { result.getEnclosingElement() = e }

// 从 Assignment(赋值), FieldAccess(字段访问), Function(函数) 中查询
from Assignment assign, FieldAccess fieldAccess, Function function
where
  function = assign.getEnclosingFunction() and
  function.hasName("memcg_path_store") and
  function.getFile().getRelativePath() = "mm/damon/sysfs-schemes.c" and

  // 1. AST: 找到一个对通过指针访问的结构体/类实例字段的赋值操作。
  //    filter->memcg_path = path;
  fieldAccess = assign.getLValue() and
  fieldAccess.getQualifier().getType() instanceof PointerType and
  // 2. AST: 确保字段本身是一个指针类型，可以持有已分配的内存。
  isHeapAllocatedPointer(fieldAccess) and
  // 3. CFG: 核心逻辑。检查在此字段上是否**不存在**前置的 'kfree' 调用。
  not exists(FunctionCall kfreeCall |
    // 3a. AST: 找到一个名为 'kfree' 的函数调用。
    kfreeCall.getTarget().getName() = "kfree" and
    // 3b. AST: 检查 'kfree' 是否在完全相同的字段访问上被调用。
    //    我们比较 AST 节点的字符串表示，这是一种简单而有效的方法，用于匹配 'kfree(filter->memcg_path)' 和 'filter->memcg_path'。
    kfreeCall.getArgument(0).toString() = fieldAccess.toString() and
    // 3c. CFG: 检查 'kfree' 调用是否在控制流中发生在赋值操作 *之前*。
    dominates(getControlFlowNode(kfreeCall).getBasicBlock(), getControlFlowNode(assign).getBasicBlock())
  )
select assign,
  fieldAccess, fieldAccess.getTarget().getName()