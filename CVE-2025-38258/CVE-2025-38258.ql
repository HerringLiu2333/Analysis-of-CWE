/**
 * @name Linux Kernel - DAMON sysfs memcg_path Memory Leak
 * @description Detects a memory leak in the DAMON sysfs interface. Writing to the 'memcg_path'
 *              sysfs file assigns a newly allocated buffer to a pointer without freeing the
 *              previously allocated buffer. Repeated writes can exhaust kernel memory, leading
 *              to a denial-of-service (DoS) condition.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/kernel/damon-memcg-path-leak
 * @tags security
 *       correctness
 *       memory
 *       leak
 *       denial-of-service
 *       external/cwe/cwe-401
 * @patch-commit 4f489fe6afb395dbc79840efa3c05440b760d883
 * @source-file mm/damon/sysfs-schemes.c
 * @affected-function memcg_path_store
 * @kernel-config CONFIG_DAMON
 * @vulnerability-type memory-leak
 * @patch-diff |
 *     @@ -472,6 +472,7 @@ static ssize_t memcg_path_store(struct kobject *kobj,
 *      		return -ENOMEM;
 *      
 *      	strscpy(path, buf, count + 1);
 *     +	kfree(filter->memcg_path);
 *      	filter->memcg_path = path;
 *      	return count;
 *      }
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f5769359c5b241978e6933672bb78b3adc36aa18
 * @remediation 
 */
import cpp
import semmle.code.cpp.controlflow.ControlFlowGraph

// ---------------- Allocation / Free Models ----------------
// Extendable lists; add more as needed (e.g., kmemdup, kstrdup, devm_* variants etc.)
predicate isAllocator(FunctionCall c) {
  exists(string name |
    name in ["kmalloc", "kzalloc", "kmalloc_array", "kcalloc", "kvzalloc", "kvmalloc", "kstrdup", "kmemdup"] and
    c.getTarget().getName() = name
  )
}

predicate isDeallocator(FunctionCall c) {
  exists(string name |
    name in ["kfree", "kvfree", "kfree_sensitive"] and
    c.getTarget().getName() = name
  )
}

// Identify a value that is (directly) the result of an allocation we care about
predicate isFreshAllocated(Expr e) {
  e instanceof FunctionCall and isAllocator(e.(FunctionCall))
  or
  // variable initialized from allocator (single-step)
  exists(Variable v, FunctionCall c |
    e instanceof VariableAccess and v = e.(VariableAccess).getTarget() and
    c = v.getAnAssignedValue() and isAllocator(c)
  )
  or
  // variable declared with initializer that calls allocator (covers: char *path = kmalloc(...); filter->memcg_path = path; )
  exists(Variable v2, FunctionCall c2, Initializer init |
    e instanceof VariableAccess and v2 = e.(VariableAccess).getTarget() and
  init = v2.getInitializer() and c2 = init.getExpr().(FunctionCall) and isAllocator(c2)
  )
}

// FieldAccess to pointer field
predicate isPointerField(FieldAccess fa) { fa instanceof PointerFieldAccess }

// Structural equality: same qualifier variable AND same field symbol
predicate sameField(FieldAccess a, FieldAccess b) {
  a.getTarget() = b.getTarget() and
  exists(Variable va, Variable vb |
    a.getQualifier() instanceof VariableAccess and
    b.getQualifier() instanceof VariableAccess and
    va = a.getQualifier().(VariableAccess).getTarget() and
    vb = b.getQualifier().(VariableAccess).getTarget() and
    va = vb
  )
}

// Heuristic: qualifier is a local variable whose only definition is via container_of(...) => persistent object
predicate isPersistentObject(Expr qual) {
  qual instanceof VariableAccess and
  exists(Variable v | v = qual.(VariableAccess).getTarget() and
    // Decl in this function, and has an initializer (macro expansion) containing "container_of"
    exists(Initializer init | init = v.getInitializer() and init.toString().regexpMatch(".*container_of.*"))
  )
  or
  // Qualifier is a parameter (also typically persistent / passed in)
  qual instanceof VariableAccess and qual.(VariableAccess).getTarget() instanceof Parameter
}

// Control flow node helper
ControlFlowNode nodeOf(Expr e) { result.getEnclosingElement() = e }

from Assignment asg, FieldAccess lhsFA, Expr rhs
where
  asg.getFile().getBaseName() = "sysfs-schemes.c" and
  lhsFA = asg.getLValue() and
  isPointerField(lhsFA) and
  // isPersistentObject(lhsFA.getQualifier()) and

  rhs = asg.getRValue() 
  // and
  // isFreshAllocated(rhs)
  //  and

  // // No preceding free-like call on the exact same field (structural match) dominating this assignment
  // not exists(FunctionCall freeCall, FieldAccess freedFA |
  //   isDeallocator(freeCall) and
  //   freedFA = freeCall.getArgument(0).(FieldAccess) and
  //   sameField(freedFA, lhsFA) and
  //   dominates(nodeOf(freeCall).getBasicBlock(), nodeOf(asg).getBasicBlock())
  // )
select asg,lhsFA, rhs, lhsFA.getQualifier().(VariableAccess).getTarget().getInitializer().toString()