### **## 根因描述**

此漏洞的根本原因在于，代码在更新一个指向动态分配内存的指针时，未能释放该指针之前所指向的旧内存。

1.  **增加的代码:**
    ```c
    +	kfree(filter->memcg_path);
    ```
    *   **修改原因:** 这是对一个经典的内存泄露漏洞的直接修复。
        *   **旧代码的缺陷:** `memcg_path_store` 函数负责处理用户通过 sysfs 写入一个新的 `memcg_path` 字符串。
            1.  它首先使用 `kmalloc` 分配一块新的内存 `path`，用于存储来自用户的新字符串。
            2.  然后，它通过 `filter->memcg_path = path;` 这行代码，将结构体中的指针更新为指向这块新分配的内存。
            3.  **致命缺陷在于**，如果 `filter->memcg_path` 在这次赋值之前，已经指向了一块之前被分配的旧内存（即用户不是第一次设置这个路径，而是在更新它），那么旧代码在用新指针覆盖掉旧指针时，完全**没有**调用 `kfree` 来释放那块旧的内存。
        *   **致命后果:** 指向旧内存块的唯一指针 `filter->memcg_path` 被覆盖丢失了。这块旧内存因此变成了“孤儿”内存——它仍然被内核占用，但没有任何指针再指向它，因此永远无法被释放。每次用户更新这个 sysfs 文件，都会泄漏掉一块内存。反复操作最终会耗尽所有可用的内核内存，导致系统因 OOM (Out Of Memory) 而崩溃。
        *   **新代码的修复:** 补丁在用新指针 `path` 覆盖 `filter->memcg_path` **之前**，增加了一行 `kfree(filter->memcg_path);`。这就确保了在更新指针之前，旧的、不再需要的内存总是会被正确地释放掉。(`kfree(NULL)` 是安全的，所以第一次设置时也能正常工作）。

### **## 总结**

*   **漏洞类型：**
    内存泄露（Memory Leak）。

*   **根本缺陷：**
    不完整的资源更新逻辑。代码在更新一个指向动态分配资源的指针时，忘记了在赋值新指针之前释放旧指针所指向的资源。

*   **修复原理：**
    实施了“先释放旧，再赋新值”的正确更新模式。修复方案通过在更新指针之前增加一个 `kfree` 调用，确保了旧的、不再被引用的内存能够被及时回收，从而堵住了内存泄露。

### ## Codeql

1. **定位操作范围**：
   首先，脚本将搜索范围严格限定在 mm/damon/sysfs-schemes.c 这一个文件中的 memcg_path_store 这一个函数内，忽略所有其他代码。
2. **识别目标行为**：
   在指定的函数内，它专门寻找一种特定的赋值操作：给一个结构体指针的字段赋予新值的代码行。同时，它会确认被赋值的这个字段本身也是一个指针类型，因为只有这类字段才存储着需要被手动释放的内存地址。
3. **检查是否遗漏释放**：
   对于每一个找到的目标赋值操作，脚本会检查在该赋值发生之前的所有可能的执行路径。它的核心规则是：如果在赋值之前，代码没有调用 kfree 函数来释放这个字段当前指向的旧内存，那么就将这行赋值代码标记为一处潜在的内存泄漏。