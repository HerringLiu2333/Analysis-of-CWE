/**
 * @name CVE-2024-58059
 * @description In uvcvideo, uvc_probe() failure could call uvc_status_unregister()
 *  before uvc_status_init() ran, leading to unregistering an uninitialized
 *  status path and potential deadlock or NULL dereference. The fix skips
 *  unregister when dev->status is NULL.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/unregister-before-init-null-check
 * @tags 
 *  correctness
 *  reliability
 *  null-dereference
 *  deadlock
 *  usb
 *  media
 * @patch-commit db577ededf3a18b39567fc1a6209f12a0c4a3c52
 * @source-file drivers/media/usb/uvc/uvc_status.c
 * @affected-function uvc_status_unregister
 * @vulnerability-type unregister-before-initialization
 * @patch-diff |
 *  diff --git a/drivers/media/usb/uvc/uvc_status.c b/drivers/media/usb/uvc/uvc_status.c
 *  index 06c867510c8fe6…f37417634ee944 100644
 *  -- a/drivers/media/usb/uvc/uvc_status.c
 *  +++ b/drivers/media/usb/uvc/uvc_status.c
 *  @@ -294,6 +294,9 @@ int uvc_status_init(struct uvc_device *dev)
 *
 *    void uvc_status_unregister(struct uvc_device *dev)
 *    {
 *  + if (!dev->status)
 *  + return;
 *  +
 *    uvc_status_suspend(dev);
 *    uvc_input_unregister(dev);
 *    }
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=db577ededf3a18b39567fc1a6209f12a0c4a3c52
 * @remediation Guard unregister paths with a NULL check on dev->status (or equivalent state)
 *  to ensure resources are only torn down if they were initialized. In probe error
 *  paths, unwind in the reverse order of successful initialization and skip steps
 *  that were not reached.
 */

import cpp

/*
 * 检测UBIFS调试功能中的NULL指针解引用漏洞
 * 该查询用于识别在访问c->zroot.znode之前未进行NULL检查的情况
 * 这可能导致在zroot为NULL时出现空指针解引用错误
 * This query identifies NULL pointer dereference vulnerabilities where
 * c->zroot.znode is accessed without NULL check in UBIFS debug functions
 */




from
  Function ubifs_dump_tnc, FunctionCall ubifs_tnc_levelorder_next
  
where
  // 限制在ubifs_dump_tnc函数内
  ubifs_dump_tnc.getName() = "ubifs_dump_tnc" and
  ubifs_tnc_levelorder_next.getEnclosingFunction() = ubifs_dump_tnc and
  
  // 查找c->zroot.znode访问
  ubifs_tnc_levelorder_next.getTarget().getName() = "ubifs_tnc_levelorder_next" and
  ubifs_tnc_levelorder_next.getArgument(2).toString() = "0" and
  ubifs_tnc_levelorder_next.getArgument(1).toString().matches("%znode%") and
  // 在访问之前没有NULL检查
  not exists(IfStmt ifstmt |
    ifstmt.getCondition().toString().matches("%znode%") and
    ifstmt.getEnclosingFunction() = ubifs_dump_tnc and   
    ifstmt.getLocation().getStartLine() < ubifs_tnc_levelorder_next.getLocation().getStartLine()
  )
select
  ubifs_tnc_levelorder_next,
  "Potential NULL pointer dereference: c->zroot.znode accessed without NULL check in ubifs_dump_tnc()"