/**
 * @name CVE-2025-38289
 * @description Detects a race condition in the lpfc_dev_loss_tmo_callbk function where a non-atomic "check-then-act"
 *              on the NLP_DROPPED flag can lead to a double-free or use-after-free of the ndlp object.
 *              Multiple threads can pass the check before the flag is set, causing lpfc_nlp_put to be called
 *              multiple times on the same object under race conditions.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/lpfc-dev-loss-race-condition
 * @tags security
 *       correctness
 *       concurrency
 *       race-condition
 *       external/cwe/cwe-362
 *       external/cwe/cwe-415
 *       external/cwe/cwe-416
 * @patch-commit b5162bb6aa1ec04dff4509b025883524b6d7e7ca
 * @source-file drivers/scsi/lpfc/lpfc_hbadisc.c
 * @affected-function lpfc_dev_loss_tmo_callbk
 * @kernel-config CONFIG_SCSI_LPFC
 * @vulnerability-type race-condition
 * @patch-diff |
 *     @@ -161,7 +161,7 @@ lpfc_dev_loss_tmo_callbk(struct fc_rport *rport)
 *      	struct lpfc_hba   *phba;
 *      	struct lpfc_work_evt *evtp;
 *      	unsigned long iflags;
 *     -	bool nvme_reg = false;
 *     +	bool drop_initial_node_ref = false;
 *      
 *      	ndlp = ((struct lpfc_rport_data *)rport->dd_data)->pnode;
 *      	if (!ndlp)
 *     @@ -188,8 +188,13 @@ lpfc_dev_loss_tmo_callbk(struct fc_rport *rport)
 *      		spin_lock_irqsave(&ndlp->lock, iflags);
 *      		ndlp->rport = NULL;
 *      
 *     -		if (ndlp->fc4_xpt_flags & NVME_XPT_REGD)
 *     -			nvme_reg = true;
 *     +		/* Only 1 thread can drop the initial node reference.
 *     +		 * If not registered for NVME and NLP_DROPPED flag is
 *     +		 * clear, remove the initial reference.
 *     +		 *&#47;
 *     +		if (!(ndlp->fc4_xpt_flags & NVME_XPT_REGD))
 *     +			if (!test_and_set_bit(NLP_DROPPED, &ndlp->nlp_flag))
 *     +				drop_initial_node_ref = true;
 *      
 *      		/* The scsi_transport is done with the rport so lpfc cannot
 *      		 * call to unregister.
 *     @@ -200,28 +205,16 @@ lpfc_dev_loss_tmo_callbk(struct fc_rport *rport)
 *      			/* If NLP_XPT_REGD was cleared in lpfc_nlp_unreg_node,
 *      			 * unregister calls were made to the scsi and nvme
 *      			 * transports and refcnt was already decremented. Clear
 *     -			 * the NLP_XPT_REGD flag only if the NVME Rport is
 *     +			 * the NLP_XPT_REGD flag only if the NVME nrport is
 *      			 * confirmed unregistered.
 *      			 *&#47;
 *     -			if (!nvme_reg && ndlp->fc4_xpt_flags & NLP_XPT_REGD) {
 *     -				ndlp->fc4_xpt_flags &= ~NLP_XPT_REGD;
 *     +			if (ndlp->fc4_xpt_flags & NLP_XPT_REGD) {
 *     +				if (!(ndlp->fc4_xpt_flags & NVME_XPT_REGD))
 *     +					ndlp->fc4_xpt_flags &= ~NLP_XPT_REGD;
 *      				spin_unlock_irqrestore(&ndlp->lock, iflags);
 *     -				lpfc_nlp_put(ndlp); /* may free ndlp *&#47;
 *     +
 *     +				/* Release scsi transport reference *&#47;
 *     +				lpfc_nlp_put(ndlp);
 *      			} else {
 *      				spin_unlock_irqrestore(&ndlp->lock, iflags);
 *      			}
 *     @@ -214,14 +222,8 @@ lpfc_dev_loss_tmo_callbk(struct fc_rport *rport)
 *      			spin_unlock_irqrestore(&ndlp->lock, iflags);
 *      		}
 *      
 *     -		/* Only 1 thread can drop the initial node reference.  If
 *     -		 * another thread has set NLP_DROPPED, this thread is done.
 *     -		 *&#47;
 *     -		if (nvme_reg || test_bit(NLP_DROPPED, &ndlp->nlp_flag))
 *     -			return;
 *     -
 *     -		set_bit(NLP_DROPPED, &ndlp->nlp_flag);
 *     -		lpfc_nlp_put(ndlp);
 *     +		if (drop_initial_node_ref)
 *     +			lpfc_nlp_put(ndlp);
 *      		return;
 *      	}
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38289
 * @remediation
 */

import cpp

// 定义目标函数调用
class RefCountFunction extends FunctionCall {
  RefCountFunction() {
    // 匹配 lpfc_nlp_put 函数调用
    this.getTarget().getName() = "lpfc_nlp_put"
  }
}

from Function f, MacroInvocation testBitMacro, FunctionCall setBitMacro, 
     RefCountFunction refCount
where
  // 定位目标函数
  f.getName() = "lpfc_dev_loss_tmo_callbk" and
  f.getFile().getBaseName() = "lpfc_hbadisc.c" and
  
  // 确保所有操作都在同一个函数中
  testBitMacro.getEnclosingFunction() = f and
  setBitMacro.getEnclosingFunction() = f and
  refCount.getEnclosingFunction() = f and
  
  // 确保是test_bit和set_bit操作
  testBitMacro.getMacroName() = "test_bit" and
  setBitMacro.getTarget().getName() = "set_bit" and
  
  // // 确保操作的是同一个标志位（NLP_DROPPED）
  testBitMacro.getExpandedArgument(0).toString().matches("%NLP_DROPPED%") and
  setBitMacro.getArgument(0).toString().matches("%NLP_DROPPED%") and
  
  // 确保操作顺序：先test_bit，后set_bit，最后是引用计数操作
  testBitMacro.getLocation().getStartLine() < setBitMacro.getLocation().getStartLine() and
  setBitMacro.getLocation().getStartLine() < refCount.getLocation().getStartLine()
  
select testBitMacro, 
       testBitMacro,
       setBitMacro,
       refCount, refCount.getTarget().getName()