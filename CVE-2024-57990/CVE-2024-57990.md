```markdown
### **## 根因描述**

根因是边界检查中的差一错误（off-by-one）。代码用 clc->idx 作为下标访问 phy->clc 数组，但旧判断条件使用了 “>”：
if (clc->idx > ARRAY_SIZE(phy->clc))
这没有拦截 clc->idx 等于数组大小的情况，而有效索引范围应为 [0, ARRAY_SIZE(phy->clc) - 1]。当 clc->idx 恰好等于数组大小时会被误判为合法，随后对 phy->clc[clc->idx] 的访问将产生越界读/写风险。

1. 被修改的代码:
    ```c
    @@ -638,7 +638,7 @@ static int mt7925_load_clc(struct mt792x_dev *dev, const char *fw_name)
     	for (offset = 0; offset < len; offset += le32_to_cpu(clc->len)) {
     		clc = (const struct mt7925_clc *)(clc_base + offset);
     
    -		if (clc->idx > ARRAY_SIZE(phy->clc))
    +		if (clc->idx >= ARRAY_SIZE(phy->clc))
     			break;
     
     		/* do not init buf again if chip reset triggered */
    ```
    - 修改原因:
        - 旧代码的缺陷:
            1. 将“>”用于上界检查，未排除等于数组大小的非法索引，导致可能的数组越界读/写。
            2. 违背 C 数组有效下标须小于数组大小的基本约束，存在潜在内存破坏风险。
        - 新代码的修复:
            1. 将判断改为 “>=”，严格限制 clc->idx 必须小于 ARRAY_SIZE(phy->clc)。
            2. 从源头阻断 idx 等于数组大小时的访问，避免越界读/写问题。

### **## 总结**

- 问题类型：差一错误（off-by-one）导致的数组越界访问
- 根本缺陷：边界检查条件使用 “>” 而非 “>=”
- 修复原理：使用 “>=” 排除等于数组大小的非法索引，确保索引范围为 [0, N-1]
```