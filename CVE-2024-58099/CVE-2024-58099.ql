/**
 * @name CVE-2024-58055
 * @description In the USB gadget TCM function driver, commands were freed immediately after
 *              sending CHECK CONDITION with sense data. The command must be freed only after
 *              the sense status completion; freeing it earlier leads to double-free/use-after-free
 *              and possible memory corruption. The fix removes the premature transport_generic_free_cmd()
 *              calls from error paths.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/usb-gadget-f-tcm-double-free
 * @tags
 *       security
 *       correctness
 *       reliability
 *       memory-safety
 *       double-free
 *       use-after-free
 *       external/cwe/cwe-415
 *       external/cwe/cwe-416
 * @patch-commit f0c33e7d387ccbb6870e73a43c558fefede06614
 * @source-file drivers/usb/gadget/function/f_tcm.c
 * @affected-function usbg_cmd_work
 * @affected-function bot_cmd_work
 * @vulnerability-type double-free
 * @patch-diff |
 *     diff --git a/drivers/usb/gadget/function/f_tcm.c b/drivers/usb/gadget/function/f_tcm.c
 *     index 81b6d0d18a8cd6..948888316fbd54 100644
 *     --- a/drivers/usb/gadget/function/f_tcm.c
 *     +++ b/drivers/usb/gadget/function/f_tcm.c
 *     @@ -1066,7 +1066,6 @@ static void usbg_cmd_work(struct work_struct *work)
 *      out:
 *      	transport_send_check_condition_and_sense(se_cmd,
 *      			TCM_UNSUPPORTED_SCSI_OPCODE, 1);
 *     -	transport_generic_free_cmd(&cmd->se_cmd, 0);
 *      }
 *      
 *      static struct usbg_cmd *usbg_get_cmd(struct f_uas *fu,
 *     @@ -1195,7 +1194,6 @@ static void bot_cmd_work(struct work_struct *work)
 *      out:
 *      	transport_send_check_condition_and_sense(se_cmd,
 *      				TCM_UNSUPPORTED_SCSI_OPCODE, 1);
 *     -	transport_generic_free_cmd(&cmd->se_cmd, 0);
 *      }
 *      
 *      static int bot_submit_command(struct f_uas *fu,
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f0c33e7d387ccbb6870e73a43c558fefede06614
 * @remediation Do not free se_cmd immediately after sending CHECK CONDITION and sense data.
 *              Defer freeing until the status completion callback for the sense status runs,
 *              ensuring the command is released exactly once and preventing double-free or
 *              use-after-free.
 * @patch-description |
 *  vmxnet3: Fix packet corruption in vmxnet3_xdp_xmit_frame
 *  [ Upstream commit 4678adf94da4a9e9683817b246b58ce15fb81782 ]
 *  
 *  Andrew and Nikolay reported connectivity issues with Cilium's service
 *  load-balancing in case of vmxnet3.
 *  
 *  If a BPF program for native XDP adds an encapsulation header such as
 *  IPIP and transmits the packet out the same interface, then in case
 *  of vmxnet3 a corrupted packet is being sent and subsequently dropped
 *  on the path.
 *
 *  vmxnet3_xdp_xmit_frame() which is called e.g. via vmxnet3_run_xdp()
 *  through vmxnet3_xdp_xmit_back() calculates an incorrect DMA address:
 *  
 *    page = virt_to_page(xdpf->data);
 *    tbi->dma_addr = page_pool_get_dma_addr(page) +
 *                    VMXNET3_XDP_HEADROOM;
 *    dma_sync_single_for_device(&adapter->pdev->dev,
 *                               tbi->dma_addr, buf_size,
 *                               DMA_TO_DEVICE);
 *  
 *  The above assumes a fixed offset (VMXNET3_XDP_HEADROOM), but the XDP
 *  BPF program could have moved xdp->data. While the passed buf_size is
 *  correct (xdpf->len), the dma_addr needs to have a dynamic offset which
 *  can be calculated as xdpf->data - (void *)xdpf, that is, xdp->data -
 *  xdp->data_hard_start.
 *
 *  Fixes: 54f00cce1178 ("vmxnet3: Add XDP support.")
 */

import cpp

/*
 * 检测vmxnet3驱动中的XDP数据包损坏漏洞
 * 该查询用于识别在vmxnet3_xdp_xmit_frame函数中使用固定偏移量而不是动态偏移量计算DMA地址的情况
 * 这可能导致数据包损坏，因为XDP BPF程序可能移动了xdp->data指针
 * This query identifies packet corruption vulnerabilities where fixed offset is used instead of dynamic offset
 * for DMA address calculation in vmxnet3_xdp_xmit_frame function
 */

// 检查是否为vmxnet3_xdp_xmit_frame函数
// Check if it's vmxnet3_xdp_xmit_frame function
predicate isVmxnet3XdpXmitFrameFunction(Function f) {
  f.getName() = "vmxnet3_xdp_xmit_frame"
}



// 检查是否为DMA地址计算表达式
// Check for DMA address calculation expression
predicate isDmaAddressCalculation(AssignExpr assign) {
  exists(FieldAccess fieldAccess |
    fieldAccess = assign.getLValue() and
    fieldAccess.getTarget().getName() = "dma_addr" and
    exists(VariableAccess tbiAccess |
      tbiAccess = fieldAccess.getQualifier() and
      tbiAccess.getTarget().getName() = "tbi"
    )
  )
}

// 检查是否为动态偏移量计算（xdpf->data - xdpf）
// Check for dynamic offset calculation (xdpf->data - xdpf)
predicate isDynamicOffsetCalculation(Expr expr) {
  exists(BinaryOperation binOp |
    binOp = expr and
    binOp.getOperator() = "-" and
    exists(FieldAccess dataAccess |
      dataAccess = binOp.getLeftOperand() and
      dataAccess.getTarget().getName() = "data" and
      exists(VariableAccess xdpfAccess |
        xdpfAccess = dataAccess.getQualifier() and
        xdpfAccess.getTarget().getName() = "xdpf"
      )
    ) and
    binOp.getRightOperand().toString() = "xdpf"
  )
}

from
  Function f,
  AssignExpr dmaAssign  // DMA地址赋值表达式
where
  // 限制在vmxnet3_xdp_xmit_frame函数内
  isVmxnet3XdpXmitFrameFunction(f) and
  dmaAssign.getEnclosingFunction() = f and
  // 查找DMA地址计算
  isDmaAddressCalculation(dmaAssign) and
  // 检查是否使用固定偏移量VMXNET3_XDP_HEADROOM
  exists(Expr expr |
    expr = dmaAssign.getRValue() and
    expr.toString().matches("%VMXNET3_XDP_HEADROOM%")
  ) and
  // 没有使用动态偏移量计算
  not exists(Expr dynamicExpr |
    dynamicExpr = dmaAssign.getRValue() and
    isDynamicOffsetCalculation(dynamicExpr)
  )
select
  dmaAssign,
  "Potential packet corruption issue: Using fixed VMXNET3_XDP_HEADROOM offset instead of dynamic offset (xdpf->data - xdpf) for DMA address calculation"