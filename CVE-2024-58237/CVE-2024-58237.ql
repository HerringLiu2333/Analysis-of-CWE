/**
 * @name CVE-2024-58022
 * @description devm_ioremap() returns NULL on failure, not error pointers. Using IS_ERR() to
 *              check its return value in th1520_map_mmio() skips the error path and may propagate
 *              a NULL mapping, leading to NULL dereference or incorrect error handling. The fix
 *              checks for NULL and returns ERR_PTR(-ENOMEM).
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/null-vs-is-err-check
 * @tags
 *       security
 *       correctness
 *       reliability
 *       null-dereference
 *       external/cwe/cwe-476
 *       external/cwe/cwe-252
 * @patch-commit ecbde88e544ff016fa08bbf2156dc431bb123e9b
 * @source-file drivers/mailbox/mailbox-th1520.c
 * @affected-function th1520_map_mmio
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *     diff --git a/drivers/mailbox/mailbox-th1520.c b/drivers/mailbox/mailbox-th1520.c
 *     index 4e84640ac3b876..e16e7c85ee3cd5 100644
 *     --- a/drivers/mailbox/mailbox-th1520.c
 *     +++ b/drivers/mailbox/mailbox-th1520.c
 *     @@ -387,8 +387,10 @@ static void __iomem *th1520_map_mmio(struct platform_device *pdev,
 *      
 *      	mapped = devm_ioremap(&pdev->dev, res->start + offset,
 *      			      resource_size(res) - offset);
 *     -	if (IS_ERR(mapped))
 *     +	if (!mapped) {
 *      		dev_err(&pdev->dev, "Failed to map resource: %s\n", res_name);
 *     +		return ERR_PTR(-ENOMEM);
 *     +	}
 *      
 *      	return mapped;
 *      }
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=ecbde88e544ff016fa08bbf2156dc431bb123e9b
 * @remediation For APIs that return NULL on failure (e.g., devm_ioremap/ioremap), check for NULL
 *              instead of using IS_ERR(). On failure, log an error and return an ERR_PTR-encoded
 *              errno (e.g., -ENOMEM) so callers handle the error path correctly.
 */

import cpp

/*
 * 检测BPF辅助函数中的包指针失效问题
 * 该查询用于识别在bpf_helper_changes_pkt_data函数中未考虑尾调用导致包指针失效的情况
 * 尾调用程序可能执行任何会使包指针失效的辅助函数，因此需要保守地假设每个尾调用都会使包指针失效
 * This query identifies packet pointer invalidation issues where tail calls are not considered
 * in bpf_helper_changes_pkt_data function, tail-called programs could execute any helpers that invalidate packet pointers
 */

// 检查是否为bpf_helper_changes_pkt_data函数
// Check if it's bpf_helper_changes_pkt_data function
predicate isBpfHelperChangesPktDataFunction(Function f) {
  f.getName() = "bpf_helper_changes_pkt_data"
}



// 检查是否为返回true的语句
// Check for statement that returns true
predicate isReturningTrue(Stmt stmt) {
  exists(ReturnStmt returnStmt |
    returnStmt = stmt and
    returnStmt.getExpr().toString() = "true"
  )
}

// 检查是否有尾调用处理
// Check for tail call handling
predicate hasTailCallHandling(Function f) {
  exists(ExprStmt exprStmt |
    exprStmt.getEnclosingFunction() = f and
    exprStmt.getExpr().toString().matches("%BPF_FUNC_tail_call%") and
    exists(Stmt nextStmt |
      nextStmt.getLocation().getStartLine() > exprStmt.getLocation().getStartLine() and
      isReturningTrue(nextStmt)
    )
  )
}

from
  Function f
where
  // 限制在bpf_helper_changes_pkt_data函数内
  isBpfHelperChangesPktDataFunction(f) and
  // 没有尾调用处理
  not hasTailCallHandling(f)
select
  f,
  "Potential packet pointer invalidation issue: Missing BPF_FUNC_tail_call handling in bpf_helper_changes_pkt_data(), tail calls may invalidate packet pointers"