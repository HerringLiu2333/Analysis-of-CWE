/**
 * @name CVE-2025-38271
 * @description Detects a NULL pointer dereference in the `rtnl_create_link` function.
 *              The `dev_set_group()` function is called on a `net_device` structure that is
 *              not fully initialized, as its `dev->netdev_ops` member is still NULL.
 *              `dev_set_group()` attempts to use this member for locking, leading to a system crash.
 *              This can be triggered by creating a network interface with a 'group' attribute via Netlink.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/cve-2025-38271-rtnl-create-link-null-deref
 * @tags security
 *       correctness
 *       dos
 *       external/cwe/cwe-476
 * @patch-commit feafc73f3e6ae73371777a037d41d2e31c929636
 * @source-file net/core/rtnetlink.c
 * @affected-function rtnl_create_link
 * @kernel-config CONFIG_NET
 * @vulnerability-type null-pointer-dereference, use-before-initialization
 * @patch-diff |
 *     @@ -3671,7 +3671,7 @@ struct net_device *rtnl_create_link(struct net *net, const char *ifname,
 *      	if (tb[IFLA_LINKMODE])
 *      		dev->link_mode = nla_get_u8(tb[IFLA_LINKMODE]);
 *      	if (tb[IFLA_GROUP])
 *     -		dev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));
 *     +		netif_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));
 *      	if (tb[IFLA_GSO_MAX_SIZE])
 *      		netif_set_gso_max_size(dev, nla_get_u32(tb[IFLA_GSO_MAX_SIZE]));
 *      	if (tb[IFLA_GSO_MAX_SEGS])
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38271
 * @remediation 
 * @patch-description |
 *     net: prevent a NULL deref in rtnl_create_link()
 *     At the time rtnl_create_link() is running, dev->netdev_ops is NULL,
 *     we must not use netdev_lock_ops() or risk a NULL deref if
 *     CONFIG_NET_SHAPER is defined.
 *     
 *     Use netif_set_group() instead of dev_set_group().
 *     
 *      RIP: 0010:netdev_need_ops_lock include/net/netdev_lock.h:33 [inline]
 *      RIP: 0010:netdev_lock_ops include/net/netdev_lock.h:41 [inline]
 *      RIP: 0010:dev_set_group+0xc0/0x230 net/core/dev_api.c:82
 *     Call Trace:
 *      <TASK>
 *       rtnl_create_link+0x748/0xd10 net/core/rtnetlink.c:3674
 *       rtnl_newlink_create+0x25c/0xb00 net/core/rtnetlink.c:3813
 *       __rtnl_newlink net/core/rtnetlink.c:3940 [inline]
 *       rtnl_newlink+0x16d6/0x1c70 net/core/rtnetlink.c:4055
 *       rtnetlink_rcv_msg+0x7cf/0xb70 net/core/rtnetlink.c:6944
 *       netlink_rcv_skb+0x208/0x470 net/netlink/af_netlink.c:2534
 *       netlink_unicast_kernel net/netlink/af_netlink.c:1313 [inline]
 *       netlink_unicast+0x75b/0x8d0 net/netlink/af_netlink.c:1339
 *       netlink_sendmsg+0x805/0xb30 net/netlink/af_netlink.c:1883
 *       sock_sendmsg_nosec net/socket.c:712 [inline]
 */

import cpp

/*
 * Generalized detection: any call to dev_set_group(dev, ...) where the first
 * argument is (or points to) a struct net_device whose netdev_ops member has
 * not yet been assigned on any path earlier in the enclosing function.
 *
 * We conservatively approximate uninitialized state by absence of any prior
 * assignment to <base>.netdev_ops (direct member write) in the same function
 * before the call location. The patched code replaces dev_set_group with
 * netif_set_group (which assumes later initialization) or ensures netdev_ops
 * is set earlier, so this query should not report after patch.
 */

/** Call to dev_set_group */
class DevSetGroupCall extends FunctionCall { DevSetGroupCall() { this.getTarget().getName() = "dev_set_group" } }

/** Access of a netdev_ops member (base->netdev_ops or base.netdev_ops). */
class NetdevOpsFieldAccess extends FieldAccess {
	NetdevOpsFieldAccess() { this.getTarget().getName() = "netdev_ops" }
}

class NetdevOpsPtrFieldAccess extends PointerFieldAccess {
	NetdevOpsPtrFieldAccess() { this.getTarget().getName() = "netdev_ops" }
}

/** An assignment writing to base->netdev_ops or base.netdev_ops */
class NetdevOpsWrite extends AssignExpr {
	NetdevOpsWrite() {
		this.getLValue() instanceof NetdevOpsFieldAccess or
		this.getLValue() instanceof NetdevOpsPtrFieldAccess
	}
	Expr getBase() {
			exists(NetdevOpsFieldAccess fa | this.getLValue() = fa and result = fa.getQualifier()) or
			exists(NetdevOpsPtrFieldAccess pfa | this.getLValue() = pfa and result = pfa.getQualifier())
	}
}

predicate isNetDevicePointer(Expr e) {
	exists(Type t | e.getType() = t and t.toString().matches("struct net_device *"))
	or
	exists(Type t | e.getType() = t and t.toString().matches("net_device *"))
}

/** Determine the canonical variable underlying an expression (simple cases). */
Variable getBaseVar(Expr e) { result = e.(VariableAccess).getTarget() }

/** Control-flow node for an expression. */
BasicBlock bbOf(Expr e) { result = e.getBasicBlock() }

/** True if write w can reach call (some path) and occurs before it along CFG. */
predicate reachesBefore(NetdevOpsWrite w, DevSetGroupCall call) {
	w.getEnclosingFunction() = call.getEnclosingFunction() and
	bbOf(w).getASuccessor*() = bbOf(call)
}

/** w dominates call: all predecessors of call are reachable from w's block. */
predicate dominatesWrite(NetdevOpsWrite w, DevSetGroupCall call) {
	reachesBefore(w, call) and
	// For every path into call's block there exists path via w's block.
	// Approximate: every predecessor block of call is reachable from w.
	forall(BasicBlock pred | pred = bbOf(call).getAPredecessor() | bbOf(w).getASuccessor*() = pred)
}

from DevSetGroupCall call, Expr devArg
where
	devArg = call.getArgument(0) and
	isNetDevicePointer(devArg) and
	// No dominating prior initialization write for same base variable
	not exists(NetdevOpsWrite w |
		getBaseVar(w.getBase()) = getBaseVar(devArg) and
		dominatesWrite(w, call)
	)
select call, "Potential NULL dereference: dev_set_group called before netdev_ops initialization (no dominating netdev_ops write)" 
