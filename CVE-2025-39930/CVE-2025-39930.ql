/**
 * @name CVE-2025-39930: 使用__free(device_node)导致的设备节点use-after-free漏洞
 * @description 检测在Linux内核中使用__free(device_node)属性的变量，
 *              当其指向的设备节点被传递给持久化数据结构后可能导致use-after-free漏洞
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/device-node-auto-free-use-after-free
 * @tags security
 *       external/cwe/cwe-416
 *       correctness
 *       linux-kernel
 */

import cpp

// 检测使用__free(device_node)属性声明的变量
class AutoFreeDeviceNodeVariable extends Variable {
  AutoFreeDeviceNodeVariable() {
    // 查找使用__free(device_node)属性的变量声明
    this.getAnAttribute().getName() = "__free" and
    this.getAnAttribute().getAnArgument().toString() = "device_node"
  }
}

// 检测可能导致节点被外部持有的赋值操作
class PotentialNodeEscapeAssignment extends Assignment {
  AutoFreeDeviceNodeVariable autoFreeVar;
  
  PotentialNodeEscapeAssignment() {
    // 赋值操作的右侧是自动释放的设备节点变量
    this.getRValue() = autoFreeVar.getAnAccess() and
    // 左侧是某个结构体成员（通常是持久化的数据结构）
    (
      this.getLValue() instanceof FieldAccess or
      this.getLValue() instanceof PointerFieldAccess
    )
  }
  
  AutoFreeDeviceNodeVariable getAutoFreeVariable() {
    result = autoFreeVar
  }
}

// 检测设备节点获取函数调用
class DeviceNodeAcquireCall extends FunctionCall {
  DeviceNodeAcquireCall() {
    this.getTarget().getName() in [
      "of_graph_get_port_parent",
      "of_get_parent", 
      "of_parse_phandle",
      "of_get_next_child",
      "of_find_node_by_name",
      "of_find_node_by_path",
      "of_find_compatible_node"
    ]
  }
}

// 主查询：检测使用__free(device_node)但可能导致use-after-free的模式
from AutoFreeDeviceNodeVariable autoFreeVar, 
     PotentialNodeEscapeAssignment assignment,
     DeviceNodeAcquireCall acquireCall,
     Function func
where
  // 变量在同一个函数内定义
  autoFreeVar.getParentScope+() = func and
  assignment.getEnclosingFunction() = func and
  acquireCall.getEnclosingFunction() = func and
  
  // 自动释放变量被赋值给了外部数据结构
  assignment.getAutoFreeVariable() = autoFreeVar and
  
  // 变量是通过设备节点获取函数初始化的
  exists(Assignment init |
    init.getLValue() = autoFreeVar.getAnAccess() and
    init.getRValue() = acquireCall
  ) and
  
  // 确保不是在错误处理路径中的赋值（通过检查是否在return语句之前）
  not exists(ReturnStmt ret |
    ret.getEnclosingFunction() = func and
    assignment.getLocation().getStartLine() > ret.getLocation().getStartLine()
  )

select autoFreeVar, 
       "使用__free(device_node)的变量 '" + autoFreeVar.getName() + 
       "' 在$@处被赋值给外部数据结构，可能导致use-after-free漏洞。" +
       "当函数返回时，设备节点会被自动释放，但外部数据结构仍持有指向已释放内存的指针。",
       assignment, "此处"
