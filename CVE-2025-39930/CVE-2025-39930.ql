/**
 * @name CVE-2025-39930
 * @description Detects the use of the `__free(...)` attribute on a resource that is passed
 *              to a callee and is still in use after the calling function returns.
 *              This leads to a use-after-free vulnerability.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/linux/use-after-free-on-returned-resource
 * @tags security
 *       correctness
 *       memory-management
 *       use-after-free
 *       external/cwe/cwe-416
 * @patch-commit de74ec718e0788e1998eb7289ad07970e27cae27
 * @source-file sound/soc/generic/simple-card-utils.c
 * @affected-function graph_util_parse_dai
 * @kernel-config CONFIG_SND_SIMPLE_CARD
 * @vulnerability-type use-after-free
 * @patch-diff |
 *     @@ -1077,6 +1077,7 @@ static int graph_get_dai_id(struct device_node *ep)
 *      int graph_util_parse_dai(struct device *dev, struct device_node *ep,
 *      			 struct snd_soc_dai_link_component *dlc, int *is_single_link)
 *      {
 *     +	struct device_node *node;
 *      	struct of_phandle_args args = {};
 *      	struct snd_soc_dai *dai;
 *      	int ret;
 *     @@ -1084,7 +1085,7 @@ int graph_util_parse_dai(struct device *dev, struct device_node *ep,
 *      	if (!ep)
 *      		return 0;
 *      
 *     -	struct device_node *node __free(device_node) = of_graph_get_port_parent(ep);
 *     +	node = of_graph_get_port_parent(ep);
 *      
 *      	/*
 *      	 * Try to find from DAI node
 *     @@ -1126,8 +1127,10 @@ int graph_util_parse_dai(struct device *dev, struct device_node *ep,
 *      	 *    if he unbinded CPU or Codec.
 *      	 *&#47;
 *      	ret = snd_soc_get_dlc(&args, dlc);
 *     -	if (ret < 0)
 *     +	if (ret < 0) {
 *     +		of_node_put(node);
 *      		return ret;
 *     +	}
 *      
 *      parse_dai_end:
 *      	if (is_single_link)
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-39930
 * @remediation
 */

import cpp

// 检测使用__free(device_node)属性声明的变量
class AutoFreeDeviceNodeVariable extends Variable {
  AutoFreeDeviceNodeVariable() {
    // 查找使用__free(device_node)属性的变量声明
    this.getAnAttribute().getName() = "__free" and
    this.getAnAttribute().getAnArgument().toString() = "device_node"
  }
}

// 检测可能导致节点被外部持有的赋值操作
class PotentialNodeEscapeAssignment extends Assignment {
  AutoFreeDeviceNodeVariable autoFreeVar;
  
  PotentialNodeEscapeAssignment() {
    // 赋值操作的右侧是自动释放的设备节点变量
    this.getRValue() = autoFreeVar.getAnAccess() and
    // 左侧是某个结构体成员（通常是持久化的数据结构）
    (
      this.getLValue() instanceof FieldAccess or
      this.getLValue() instanceof PointerFieldAccess
    )
  }
  
  AutoFreeDeviceNodeVariable getAutoFreeVariable() {
    result = autoFreeVar
  }
}

// 检测设备节点获取函数调用
class DeviceNodeAcquireCall extends FunctionCall {
  DeviceNodeAcquireCall() {
    this.getTarget().getName() in [
      "of_graph_get_port_parent",
      "of_get_parent", 
      "of_parse_phandle",
      "of_get_next_child",
      "of_find_node_by_name",
      "of_find_node_by_path",
      "of_find_compatible_node"
    ]
  }
}

// 主查询：检测使用__free(device_node)但可能导致use-after-free的模式
from AutoFreeDeviceNodeVariable autoFreeVar, 
     PotentialNodeEscapeAssignment assignment,
     DeviceNodeAcquireCall acquireCall,
     Function func
where
  // 变量在同一个函数内定义
  autoFreeVar.getParentScope+() = func and
  assignment.getEnclosingFunction() = func and
  acquireCall.getEnclosingFunction() = func and
  
  // 自动释放变量被赋值给了外部数据结构
  assignment.getAutoFreeVariable() = autoFreeVar and
  
  // 变量是通过设备节点获取函数初始化的
  exists(Assignment init |
    init.getLValue() = autoFreeVar.getAnAccess() and
    init.getRValue() = acquireCall
  ) and
  
  // 确保不是在错误处理路径中的赋值（通过检查是否在return语句之前）
  not exists(ReturnStmt ret |
    ret.getEnclosingFunction() = func and
    assignment.getLocation().getStartLine() > ret.getLocation().getStartLine()
  )

select autoFreeVar, 
       "使用__free(device_node)的变量 '" + autoFreeVar.getName() + 
       "' 在$@处被赋值给外部数据结构，可能导致use-after-free漏洞。" +
       "当函数返回时，设备节点会被自动释放，但外部数据结构仍持有指向已释放内存的指针。",
       assignment, "此处"
