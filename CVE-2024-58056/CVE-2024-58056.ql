/**
 * @name CVE-2024-58056
 * @description In remoteproc core rproc_alloc(), error paths can invoke put_device(), which
 *  triggers rproc_type_release(). Because rproc->index was zero-initialized, errors occurring
 *  before ida_alloc() cause rproc_type_release() to see index >= 0 and call ida_free() on an
 *  ID that was never allocated, leading to warnings ("ida_free called for id=0 which is not allocated").
 *  The fix allocates the ID (ida_alloc) earlier so rproc->index is valid before any put_device()
 *  on error, preventing invalid ida_free calls.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/invalid-ida-free-on-error-path
 * @tags 
 *  security
 *  correctness
 *  reliability
 *  resource-management
 *  external/cwe/cwe-665
 *  external/cwe/cwe-703
 * @patch-commit f2013d19b7704cd723ab42664b8d9408ea8cc77c
 * @source-file drivers/remoteproc/remoteproc_core.c
 * @affected-function rproc_alloc
 * @kernel-config N/A
 * @vulnerability-type invalid-free
 * @patch-diff |
 *  diff --git a/drivers/remoteproc/remoteproc_core.c b/drivers/remoteproc/remoteproc_core.c
 *  index f276956f2c5cec…ef6febe3563307 100644
 *  --- a/drivers/remoteproc/remoteproc_core.c
 *  +++ b/drivers/remoteproc/remoteproc_core.c
 *  @@ -2486,6 +2486,13 @@ struct rproc *rproc_alloc(struct device *dev, const char name,
 *    rproc->dev.driver_data = rproc;
 *    idr_init(&rproc->notifyids);
 *
 *  + /* Assign a unique device index and name &#47;
 *  + rproc->index = ida_alloc(&rproc_dev_index, GFP_KERNEL);
 *  + if (rproc->index < 0) {
 *  + dev_err(dev, "ida_alloc failed: %d\n", rproc->index);
 *  + goto put_device;
 *  + }
 *  +
 *    rproc->name = kstrdup_const(name, GFP_KERNEL);
 *    if (!rproc->name)
 *    goto put_device;
 *  @@ -2496,13 +2503,6 @@ struct rproc *rproc_alloc(struct device *dev, const char name,
 *    if (rproc_alloc_ops(rproc, ops))
 *    goto put_device;
 *
 *  - /* Assign a unique device index and name &#47;
 *  - rproc->index = ida_alloc(&rproc_dev_index, GFP_KERNEL);
 *  - if (rproc->index < 0) {
 *  - dev_err(dev, "ida_alloc failed: %d\n", rproc->index);
 *  - goto put_device;
 *  - }
 *  -
 *    dev_set_name(&rproc->dev, "remoteproc%d", rproc->index);
 *
 *    atomic_set(&rproc->power, 0);
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f2013d19b7704cd723ab42664b8d9408ea8cc77c
 * @remediation Allocate an IDA index before any operations that may call put_device() on error,
 *  and only call ida_free() for IDs that were actually allocated. Specifically, move ida_alloc()
 *  early in rproc_alloc() (or initialize rproc->index to -1 and guard free paths) so release
 *  handlers do not attempt to free an unallocated ID.
 */

import cpp

/*
 * 检测remoteproc核心中的IDA释放错误漏洞
 * 该查询用于识别在错误处理路径中，ida_free()可能在ida_alloc()之前被调用的情况
 * 这会导致ida_free()被调用时IDA尚未分配，产生警告"ida_free called for id=0 which is not allocated"
 * This query identifies cases where ida_free() might be called before ida_alloc()
 * in error handling paths, leading to "ida_free called for id=0 which is not allocated" warning
 */



from
  FunctionCall ida_alloc, IfStmt ifstmt, Function rproc_alloc, BinaryOperation bo, AssignExpr ae, FunctionCall kstrdup_const
where
  // 限制在rproc相关函数内
  rproc_alloc.getName() = "rproc_alloc" and
  ida_alloc.getTarget().getName() = "ida_alloc" and
  ida_alloc.getEnclosingFunction() = rproc_alloc and
  kstrdup_const.getTarget().getName() = "kstrdup_const" and
  kstrdup_const.getEnclosingFunction() = rproc_alloc and
  ifstmt.getEnclosingFunction() = rproc_alloc and
  ae.getEnclosingFunction() = rproc_alloc and
  ae.getLocation().getStartLine() < ifstmt.getLocation().getStartLine() and
  ae.getRValue() = ida_alloc and
  ifstmt.getCondition() = bo and
  bo.getLeftOperand().toString() = ae.getLValue().toString() and
  ae.getLocation().getStartLine() > kstrdup_const.getLocation().getStartLine()
select
  ida_alloc,
  "Potential ida_free() call before ida_alloc(): ida_free may be called with unallocated ID in error handling path"
