```markdown
### **## 根因描述**

根因在于对内存分配结果缺少判空检查。mt7925_change_vif_links() 中通过 devm_kzalloc() 为 mconf 与 mlink 分配内存，但旧代码未检查返回值是否为 NULL；在内存紧张或分配失败时，后续对这些指针的使用将导致空指针解引用（NULL deref），引发内核崩溃。

### 被修改的代码

```c
@@ -1946,6 +1946,8 @@ mt7925_change_vif_links(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 					     GFP_KERNEL);
 			mlink = devm_kzalloc(dev->mt76.dev, sizeof(*mlink),
 					     GFP_KERNEL);
+			if (!mconf || !mlink)
+				return -ENOMEM;
 		}
 
 		mconfs[link_id] = mconf;
```

- 修改原因:
  - 旧代码的缺陷:
    1. 未检查 devm_kzalloc() 的返回值，分配失败时继续使用指针导致空指针解引用。
    2. 缺乏失败回退处理，风险在低内存场景下更易触发。
  - 新代码的修复:
    1. 增加对 mconf 与 mlink 的判空检查，任一为 NULL 则立即返回 -ENOMEM，阻止后续对空指针的访问。
    2. 最小化改动，保证函数在资源不足时安全失败。

### **## 总结**

- 问题类型：空指针解引用风险
- 根本缺陷：缺少对 devm_kzalloc() 返回值的判空检查
- 修复原理：新增判空并在失败时返回 -ENOMEM，避免后续对 NULL 指针的访问
```