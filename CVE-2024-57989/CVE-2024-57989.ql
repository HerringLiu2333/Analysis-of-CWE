/**
 * @name CVE-2024-57989
 * @description wifi: mt76: mt7925: mt7925_change_vif_links() allocated mconf and mlink
 *              with devm_kzalloc() but did not check for allocation failure, leading
 *              to potential NULL pointer dereference. The fix adds a NULL check and
 *              returns -ENOMEM if either allocation fails.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/mt7925-change-vif-links-devm-kzalloc-null-check
 * @tags
 *       wifi
 *       mt76
 *       mt7925
 *       memory-allocation
 *       null-dereference
 *       external/cwe/cwe-476
 * @patch-commit 5cd0bd815c8a48862a296df9b30e0ea0da14acd3
 * @source-file drivers/net/wireless/mediatek/mt76/mt7925/main.c
 * @affected-function mt7925_change_vif_links
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *     diff --git a/drivers/net/wireless/mediatek/mt76/mt7925/main.c b/drivers/net/wireless/mediatek/mt76/mt7925/main.c
 *     index 791c8b00e11264..a5110f8485e526 100644
 *     --- a/drivers/net/wireless/mediatek/mt76/mt7925/main.c
 *     +++ b/drivers/net/wireless/mediatek/mt76/mt7925/main.c
 *     @@ -1946,6 +1946,8 @@ mt7925_change_vif_links(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 *      					     GFP_KERNEL);
 *      			mlink = devm_kzalloc(dev->mt76.dev, sizeof(*mlink),
 *      					     GFP_KERNEL);
 *     +			if (!mconf || !mlink)
 *     +				return -ENOMEM;
 *      		}
 *      
 *      		mconfs[link_id] = mconf;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=5cd0bd815c8a48862a296df9b30e0ea0da14acd3 
 * @remediation Always validate the return values of devm_kzalloc() (and similar allocators).
 *              If allocation fails, handle gracefully (e.g., return -ENOMEM) before using
 *              the allocated memory to prevent NULL pointer dereferences.
 */



import cpp

// 查找可能返回NULL的内存分配函数
predicate isMemoryAllocationFunction(FunctionCall fc) {
  fc.getTarget().getName() = "devm_kzalloc" or
  fc.getTarget().getName() = "devm_kstrdup" or
  fc.getTarget().getName() = "kzalloc" or
  fc.getTarget().getName() = "kmalloc" or
  fc.getTarget().getName() = "malloc" or
  fc.getTarget().getName().matches("%alloc%")
}

// 查找连续的内存分配赋值操作
predicate isConsecutiveMemoryAllocation(AssignOperation assign1, AssignOperation assign2) {
  exists(FunctionCall fc1, FunctionCall fc2 |
    isMemoryAllocationFunction(fc1) and
    isMemoryAllocationFunction(fc2) and
    assign1.getRValue() = fc1 and
    assign2.getRValue() = fc2 and
    // 检查两个赋值操作在同一函数中且位置接近
    assign1.getEnclosingFunction() = assign2.getEnclosingFunction() and
    assign2.getLocation().getStartLine() - assign1.getLocation().getStartLine() <= 5
  )
}

// 查找缺少NULL检查的连续内存分配
predicate missingNullCheckAfterConsecutiveAlloc(AssignOperation assign1, AssignOperation assign2) {
  isConsecutiveMemoryAllocation(assign1, assign2) and
  // 检查在两个赋值之后是否有NULL检查
  not exists(IfStmt ifStmt |
    ifStmt.getLocation().getStartLine() > assign2.getLocation().getStartLine() and
    ifStmt.getEnclosingFunction() = assign2.getEnclosingFunction() and
    // 检查NULL条件
    (ifStmt.getCondition().toString().matches("%!%mconf%") or
     ifStmt.getCondition().toString().matches("%!%mlink%") or
     ifStmt.getCondition().toString().matches("%mconf%||%mlink%") or
     ifStmt.getCondition().toString().matches("%mlink%||%mconf%") or
     ifStmt.getCondition().toString().matches("%mconf%.*NULL%") or
     ifStmt.getCondition().toString().matches("%mlink%.*NULL%"))
  )
}

// 查找变量使用（可能解引用）
predicate mayDereferenceVariable(Expr expr, Variable v) {
  expr.toString().matches("%" + v.getName() + "%") and
  not expr instanceof AssignOperation and
  expr.getLocation().getStartLine() > v.getAnAccess().getLocation().getStartLine()
}

from
  AssignOperation allocAssign1, AssignOperation allocAssign2, Expr usage1, Expr usage2
where
  missingNullCheckAfterConsecutiveAlloc(allocAssign1, allocAssign2) and
  exists(Variable v1, Variable v2 |
    exists(VariableAccess va1 | va1 = allocAssign1.getLValue() and va1.getTarget() = v1) and
    exists(VariableAccess va2 | va2 = allocAssign2.getLValue() and va2.getTarget() = v2) and
    mayDereferenceVariable(usage1, v1) and
    mayDereferenceVariable(usage2, v2) and
    usage1.getEnclosingFunction() = allocAssign1.getEnclosingFunction() and
    usage2.getEnclosingFunction() = allocAssign2.getEnclosingFunction()
  )
select
  allocAssign1,
  "Potential NULL pointer dereference: Consecutive memory allocations at lines " +
  allocAssign1.getLocation().getStartLine() + " and " + allocAssign2.getLocation().getStartLine() +
  " may return NULL, but used without proper NULL check in function '" +
  allocAssign1.getEnclosingFunction().getName() + "'.",
  allocAssign2,
  "Second allocation: " + allocAssign2.toString()