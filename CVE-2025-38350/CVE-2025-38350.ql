/**
 * @name CVE-2025-38350: qdisc_tree_reduce_backlog 不当通知逻辑导致 Use-After-Free
 * @description 检测 qdisc_tree_reduce_backlog 函数中存在的有问题的早期返回检查和复杂的通知逻辑，
 *              这些问题可能导致父队列调度器无法收到子队列状态变化的正确通知，从而引发 Use-After-Free 漏洞。
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/cve-2025-38350-qdisc-notification-bug
 * @tags security
 *       external/cve/cve-2025-38350
 *       correctness
 *       use-after-free
 */

import cpp

/**
 * 查找 qdisc_tree_reduce_backlog 函数
 */
class QdiscTreeReduceBacklogFunction extends Function {
  QdiscTreeReduceBacklogFunction() {
    this.getName() = "qdisc_tree_reduce_backlog"
  }
}

/**
 * 检测有问题的早期返回检查: if (n == 0 && len == 0) return;
 * 这种检查会阻止在某些情况下发送必要的通知
 */
class ProblematicEarlyReturn extends IfStmt {
  ProblematicEarlyReturn() {
    // 查找形如 if (n == 0 && len == 0) 的条件
    exists(LogicalAndExpr logicalAnd, EqualityOperation eq1, EqualityOperation eq2 |
      this.getCondition() = logicalAnd and
      logicalAnd.getLeftOperand() = eq1 and
      logicalAnd.getRightOperand() = eq2 and
      
      // 检查 n == 0
      (eq1.getLeftOperand().(VariableAccess).getTarget().getName() = "n" and
       eq1.getRightOperand().(Literal).getValue() = "0") and
      
      // 检查 len == 0  
      (eq2.getLeftOperand().(VariableAccess).getTarget().getName() = "len" and
       eq2.getRightOperand().(Literal).getValue() = "0")
    ) and
    
    // 确保 then 分支包含 return 语句
    exists(ReturnStmt ret | 
      ret.getParent*() = this.getThen()
    ) and
    
    // 确保这个语句在 qdisc_tree_reduce_backlog 函数内
    exists(QdiscTreeReduceBacklogFunction func |
      this.getEnclosingFunction() = func
    )
  }
}

/**
 * 检测复杂的通知逻辑，特别是包含 WARN_ON_ONCE 的复杂条件
 * 这种复杂逻辑可能导致通知在某些情况下被错误地跳过
 */
class ComplexNotifyLogic extends AssignExpr {
  ComplexNotifyLogic() {
    // 查找 notify = ... 的赋值
    this.getLValue().(VariableAccess).getTarget().getName() = "notify" and
    
    // 右侧包含复杂的逻辑表达式，特别是带有 WARN_ON_ONCE 的
    exists(LogicalAndExpr logicalAnd |
      this.getRValue() = logicalAnd and
      
      // 左操作数应该是 !sch->q.qlen
      exists(NotExpr notExpr, FieldAccess qlenAccess |
        logicalAnd.getLeftOperand() = notExpr and
        notExpr.getOperand() = qlenAccess and
        qlenAccess.getTarget().getName() = "qlen"
      ) and
      
      // 右操作数包含 WARN_ON_ONCE 调用
      exists(NotExpr rightNot, FunctionCall warnCall |
        logicalAnd.getRightOperand() = rightNot and
        rightNot.getOperand() = warnCall and
        warnCall.getTarget().getName() = "WARN_ON_ONCE"
      )
    ) and
    
    // 确保在 qdisc_tree_reduce_backlog 函数内
    exists(QdiscTreeReduceBacklogFunction func |
      this.getEnclosingFunction() = func
    )
  }
}

/**
 * 检测 qdisc_is_offloaded 变量的使用，这是漏洞代码的特征之一
 */
class QdiscOffloadedUsage extends VariableAccess {
  QdiscOffloadedUsage() {
    this.getTarget().getName() = "qdisc_is_offloaded" and
    exists(QdiscTreeReduceBacklogFunction func |
      this.getEnclosingFunction() = func
    )
  }
}

// 主查询：报告发现的有问题模式
from Element problem, string message, string category
where
  (
    // 情况1：发现有问题的早期返回
    exists(ProblematicEarlyReturn earlyRet |
      problem = earlyRet and
      message = "发现有问题的早期返回检查 'if (n == 0 && len == 0)'，这可能阻止必要的父队列通知，导致状态不一致" and
      category = "早期返回检查"
    )
  ) or (
    // 情况2：发现复杂的通知逻辑
    exists(ComplexNotifyLogic complexLogic |
      problem = complexLogic and
      message = "发现复杂的通知逻辑，包含 WARN_ON_ONCE 和 qdisc_is_offloaded 检查，这种逻辑可能导致在某些情况下跳过关键的父队列通知" and
      category = "复杂通知逻辑"
    )
  ) or (
    // 情况3：发现 qdisc_is_offloaded 的使用
    exists(QdiscOffloadedUsage offloadedUsage |
      problem = offloadedUsage and
      message = "发现 qdisc_is_offloaded 变量的使用，这是有漏洞版本的特征，可能导致通知逻辑出现问题" and
      category = "卸载队列检查"
    )
  )
select problem, "CVE-2025-38350 漏洞模式检测: " + message + " (" + category + ")"
