/**
 * @name CVE-2025-38350
 * @description In the Linux kernel's traffic control subsystem, certain enqueue operations can unexpectedly cause a child qdisc to become empty.
 *              The vulnerable code failed to reliably notify the parent qdisc in all such scenarios. This leads to the parent retaining a stale
 *              pointer to a class that could be subsequently freed and used, resulting in a use-after-free vulnerability.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/use-after-free-on-stale-qdisc-class
 * @tags security
 *       correctness
 *       concurrency
 *       use-after-free
 *       external/cwe/cwe-416
 * @patch-commit 103406b38c600fec1fe375a77b27d87e314aea09
 * @source-file net/sched/sch_api.c
 * @affected-function qdisc_tree_reduce_backlog
 * @kernel-config CONFIG_NET_SCHED
 * @vulnerability-type use-after-free
 * @patch-diff |
 *     @@ -783,21 +783,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
 *      {
 *     -	bool qdisc_is_offloaded = sch->flags & TCQ_F_OFFLOADED;
 *      	const struct Qdisc_class_ops *cops;
 *      	unsigned long cl;
 *      	u32 parentid;
 *      	bool notify;
 *      	int drops;
 *     -
 *     -	if (n == 0 && len == 0)
 *     -		return;
 *      	drops = max_t(int, n, 0);
 *      	rcu_read_lock();
 *      	while ((parentid = sch->parent)) {
 *     @@ -808,17 +796,8 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
 *      
 *      		if (sch->flags & TCQ_F_NOPARENT)
 *      			break;
 *     -		/* Notify parent qdisc only if child qdisc becomes empty.
 *     -		 *
 *     -		 * If child was empty even before update then backlog
 *     -		 * counter is screwed and we skip notification because
 *     -		 * parent class is already passive.
 *     -		 *
 *     -		 * If the original child was offloaded then it is allowed
 *     -		 * to be seem as empty, so the parent is notified anyway.
 *     -		 *&#47;
 *     -		notify = !sch->q.qlen && !WARN_ON_ONCE(!n &&
 *     -						       !qdisc_is_offloaded);
 *     +		/* Notify parent qdisc only if child qdisc becomes empty. *&#47;
 *     +		notify = !sch->q.qlen;
 *      		/* TODO: perform the search on a per txq basis *&#47;
 *      		sch = qdisc_lookup_rcu(qdisc_dev(sch), TC_H_MAJ(parentid));
 *      		if (sch == NULL) {
 *     @@ -827,6 +804,9 @@ void qdisc_tree_reduce_backlog(struct Qdisc *sch, int n, int len)
 *      		}
 *      		cops = sch->ops->cl_ops;
 *      		if (notify && cops->qlen_notify) {
 *     +			/* Note that qlen_notify must be idempotent as it may get called
 *     +			 * multiple times.
 *     +			 *&#47;
 *      			cl = cops->find(sch, parentid);
 *      			cops->qlen_notify(sch, cl);
 *      		}
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38350
 * @remediation
 */

import cpp

/**
 * 查找 qdisc_tree_reduce_backlog 函数
 */
class QdiscTreeReduceBacklogFunction extends Function {
  QdiscTreeReduceBacklogFunction() {
    this.getName() = "qdisc_tree_reduce_backlog"
  }
}

/**
 * 检测有问题的早期返回检查: if (n == 0 && len == 0) return;
 * 这种检查会阻止在某些情况下发送必要的通知
 */
class ProblematicEarlyReturn extends IfStmt {
  ProblematicEarlyReturn() {
    // 查找形如 if (n == 0 && len == 0) 的条件
    exists(LogicalAndExpr logicalAnd, EqualityOperation eq1, EqualityOperation eq2 |
      this.getCondition() = logicalAnd and
      logicalAnd.getLeftOperand() = eq1 and
      logicalAnd.getRightOperand() = eq2 and
      
      // 检查 n == 0
      (eq1.getLeftOperand().(VariableAccess).getTarget().getName() = "n" and
       eq1.getRightOperand().(Literal).getValue() = "0") and
      
      // 检查 len == 0  
      (eq2.getLeftOperand().(VariableAccess).getTarget().getName() = "len" and
       eq2.getRightOperand().(Literal).getValue() = "0")
    ) and
    
    // 确保 then 分支包含 return 语句
    exists(ReturnStmt ret | 
      ret.getParent*() = this.getThen()
    ) and
    
    // 确保这个语句在 qdisc_tree_reduce_backlog 函数内
    exists(QdiscTreeReduceBacklogFunction func |
      this.getEnclosingFunction() = func
    )
  }
}

/**
 * 检测复杂的通知逻辑，特别是包含 WARN_ON_ONCE 的复杂条件
 * 这种复杂逻辑可能导致通知在某些情况下被错误地跳过
 */
class ComplexNotifyLogic extends AssignExpr {
  ComplexNotifyLogic() {
    // 查找 notify = ... 的赋值
    this.getLValue().(VariableAccess).getTarget().getName() = "notify" and
    
    // 右侧包含复杂的逻辑表达式，特别是带有 WARN_ON_ONCE 的
    exists(LogicalAndExpr logicalAnd |
      this.getRValue() = logicalAnd and
      
      // 左操作数应该是 !sch->q.qlen
      exists(NotExpr notExpr, FieldAccess qlenAccess |
        logicalAnd.getLeftOperand() = notExpr and
        notExpr.getOperand() = qlenAccess and
        qlenAccess.getTarget().getName() = "qlen"
      ) and
      
      // 右操作数包含 WARN_ON_ONCE 调用
      exists(NotExpr rightNot, FunctionCall warnCall |
        logicalAnd.getRightOperand() = rightNot and
        rightNot.getOperand() = warnCall and
        warnCall.getTarget().getName() = "WARN_ON_ONCE"
      )
    ) and
    
    // 确保在 qdisc_tree_reduce_backlog 函数内
    exists(QdiscTreeReduceBacklogFunction func |
      this.getEnclosingFunction() = func
    )
  }
}

/**
 * 检测 qdisc_is_offloaded 变量的使用，这是漏洞代码的特征之一
 */
class QdiscOffloadedUsage extends VariableAccess {
  QdiscOffloadedUsage() {
    this.getTarget().getName() = "qdisc_is_offloaded" and
    exists(QdiscTreeReduceBacklogFunction func |
      this.getEnclosingFunction() = func
    )
  }
}

// 主查询：报告发现的有问题模式
from Element problem, string message, string category
where
  (
    // 情况1：发现有问题的早期返回
    exists(ProblematicEarlyReturn earlyRet |
      problem = earlyRet and
      message = "发现有问题的早期返回检查 'if (n == 0 && len == 0)'，这可能阻止必要的父队列通知，导致状态不一致" and
      category = "早期返回检查"
    )
  ) or (
    // 情况2：发现复杂的通知逻辑
    exists(ComplexNotifyLogic complexLogic |
      problem = complexLogic and
      message = "发现复杂的通知逻辑，包含 WARN_ON_ONCE 和 qdisc_is_offloaded 检查，这种逻辑可能导致在某些情况下跳过关键的父队列通知" and
      category = "复杂通知逻辑"
    )
  ) or (
    // 情况3：发现 qdisc_is_offloaded 的使用
    exists(QdiscOffloadedUsage offloadedUsage |
      problem = offloadedUsage and
      message = "发现 qdisc_is_offloaded 变量的使用，这是有漏洞版本的特征，可能导致通知逻辑出现问题" and
      category = "卸载队列检查"
    )
  )
select problem, "CVE-2025-38350 漏洞模式检测: " + message + " (" + category + ")"
