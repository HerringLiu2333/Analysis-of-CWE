/**
 * @name CVE-2024-58018
 * @description nvkm r535: r535_gsp_cmdq_push() miscalculated available space in the GSP
 *              command queue when handling large RPC requests. It assumed availability from
 *              [wptr, buf_end) before rolling over, causing the copy size to exceed the actual
 *              free pages and overwrite the RPC request currently being read by GSP, leading
 *              to hang/crash. The fix computes the step from the wait result (free pages) and
 *              limits the chunk size to min(free, remaining-to-end) pages.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/nvkm-gsp-cmdq-free-space-calc
 * @tags
 *   gpu
 *   drm
 *   nouveau
 *   nvkm
 *   gsp
 *   ring-buffer
 *   bounds
 *   data-corruption
 *   hang
 * @patch-commit 6b6b75728c86f60c1fc596f0d4542427d0e6065b
 * @source-file drivers/gpu/drm/nouveau/nvkm/subdev/gsp/r535.c
 * @affected-function r535_gsp_cmdq_push
 * @vulnerability-type incorrect-size-calculation
 * @patch-diff
 *   diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/r535.c b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/r535.c
 *   index bd4b5d6a7bd364..9c83bab0a53091 100644
 *   --- a/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/r535.c
 *   +++ b/drivers/gpu/drm/nouveau/nvkm/subdev/gsp/r535.c
 *   @@ -161,7 +161,7 @@ r535_gsp_cmdq_push(struct nvkm_gsp *gsp, void *argv)
 *           u64 *end;
 *           u64 csum = 0;
 *           int free, time = 1000000;
 *   -       u32 wptr, size;
 *   +       u32 wptr, size, step;
 *           u32 off = 0;
 *   
 *           argc = ALIGN(GSP_MSG_HDR_SIZE + argc, GSP_PAGE_SIZE);
 *   @@ -195,7 +195,9 @@ r535_gsp_cmdq_push(struct nvkm_gsp *gsp, void *argv)
 *           }
 *   
 *           cqe = (void *)((u8 *)gsp->shm.cmdq.ptr + 0x1000 + wptr * 0x1000);
 *   -       size = min_t(u32, argc, (gsp->cmdq.cnt - wptr) * GSP_PAGE_SIZE);
 *   +       step = min_t(u32, free, (gsp->cmdq.cnt - wptr));
 *   +       size = min_t(u32, argc, step * GSP_PAGE_SIZE);
 *   +
 *           memcpy(cqe, (u8 *)cmd + off, size);
 *   
 *           wptr += DIV_ROUND_UP(size, 0x1000);
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=6b6b75728c86f60c1fc596f0d4542427d0e6065b
 * @remediation When pushing to the GSP cmdq, bound each copy chunk by the lesser of the
 *              free pages reported by the wait and the pages remaining until the end of the
 *              queue (i.e., step = min(free, cnt - wptr); size = min(argc, step * PAGE_SIZE)).
 *              This prevents overwriting data the GSP is currently reading and avoids hangs.
 */



import cpp

// 检查是否为r535_gsp_cmdq_push函数
predicate isTargetFunction(Function f) {
  f.getName() = "r535_gsp_cmdq_push"
}

// 检查是否为等待完成超时函数调用
predicate isWaitForCompletionTimeout(FunctionCall fc) {
  fc.getTarget().getName() = "wait_for_completion_timeout"
}

// 检查是否为min_t或min函数调用
predicate isMinFunction(FunctionCall fc) {
  fc.getTarget().getName() = "min_t" or
  fc.getTarget().getName() = "min"
}

// 检查是否为乘法操作且右操作数为GSP_PAGE_SIZE(0x1000)
predicate isGspPageSizeMultiplication(BinaryOperation op) {
  op.getOperator() = "*" and
  op.getRightOperand().getValue().toInt() = 4096
}

// 检查是否为cnt - wptr减法操作
predicate isCntMinusWptr(BinaryOperation op) {
  op.getOperator() = "-" and
  exists(VariableAccess cntAccess, VariableAccess wptrAccess |
    cntAccess = op.getLeftOperand() and
    wptrAccess = op.getRightOperand() and
    cntAccess.getTarget().getName() = "cnt" and
    wptrAccess.getTarget().getName() = "wptr"
  )
}

from
  FunctionCall waitCall,
  FunctionCall minCall,
  VariableAccess freeAccess,
  BinaryOperation multOp,
  BinaryOperation subOp
where
  // 限制在目标函数内分析
  exists(Function f | isTargetFunction(f) and
    waitCall.getEnclosingFunction() = f and
    minCall.getEnclosingFunction() = f
  ) and
  // 查找等待完成超时函数调用
  isWaitForCompletionTimeout(waitCall) and
  // 检查等待函数的结果赋值给free变量
  freeAccess = waitCall.getParent().(AssignExpr).getLValue() and
  // 查找min_t或min函数调用
  isMinFunction(minCall) and
  // 检查min_t的第一个参数类型为u32
  minCall.getArgument(0).getType().getName() = "u32" and
  // 检查min_t的第三个参数为乘法操作
  multOp = minCall.getArgument(2) and
  isGspPageSizeMultiplication(multOp) and
  // 分解乘法操作：左操作数为(cnt - wptr)
  subOp = multOp.getLeftOperand() and
  isCntMinusWptr(subOp) and
  // 关键检测：在size计算中没有使用等待得到的free变量值
  not exists(VariableAccess freeUsage |
    freeUsage.getTarget() = freeAccess.getTarget() and
    freeUsage.getLocation().getStartLine() > waitCall.getLocation().getStartLine() and
    freeUsage.getLocation().getStartLine() < minCall.getLocation().getStartLine()
  )
select
  minCall,
  "Potential buffer space calculation error: free pages from wait not used in size calculation, may cause GSP command queue buffer overflow"