```markdown
### **## 根因描述**

根因在于环形命令队列可用空间计算错误。r535_gsp_cmdq_push() 在处理大 RPC 请求时会等待 GSP cmdq 中出现可用页数，但旧代码在计算本次可拷贝数据大小时，仅以“从当前写指针到缓冲区末尾的剩余页数（gsp->cmdq.cnt - wptr）”为上限，忽略了真实可用空闲页数 free 的限制。这样当剩余尾部空间大于实际空闲页数时，size 可能超过可用空间，从而覆盖 GSP 正在读取的 RPC 请求，导致请求损坏并引发 GSP 挂死和内核告警。

修复通过在回绕之前，先计算 step = min(free, gsp->cmdq.cnt - wptr)，再据此得到 size，确保单次拷贝既不超过尾部剩余空间，也不超过真实可用空闲页数。

1. 被修改的代码:
    ```c
    @@ -161,7 +161,7 @@ r535_gsp_cmdq_push(struct nvkm_gsp *gsp, void *argv)
     	u64 *end;
     	u64 csum = 0;
     	int free, time = 1000000;
    -	u32 wptr, size;
    +	u32 wptr, size, step;
     	u32 off = 0;
     
     	argc = ALIGN(GSP_MSG_HDR_SIZE + argc, GSP_PAGE_SIZE);
    @@ -195,7 +195,9 @@ r535_gsp_cmdq_push(struct nvkm_gsp *gsp, void *argv)
     		}
     
     		cqe = (void *)((u8 *)gsp->shm.cmdq.ptr + 0x1000 + wptr * 0x1000);
    -		size = min_t(u32, argc, (gsp->cmdq.cnt - wptr) * GSP_PAGE_SIZE);
    +		step = min_t(u32, free, (gsp->cmdq.cnt - wptr));
    +		size = min_t(u32, argc, step * GSP_PAGE_SIZE);
    +
     		memcpy(cqe, (u8 *)cmd + off, size);
     
     		wptr += DIV_ROUND_UP(size, 0x1000);
    ```
    - 修改原因:
        - 旧代码的缺陷:
            1. 用 (cnt - wptr) 作为上限忽略了 free，可能在尾部剩余空间大于实际可用空闲页时写超，覆盖正在被读取的数据。
            2. 在环形队列即将回绕时，拷贝长度未受“真实可用空间”约束，存在数据破坏与设备挂死风险。
        - 新代码的修复:
            1. 先计算 step = min(free, cnt - wptr)，再以 step*PAGE 约束本次拷贝长度 size，兼顾尾部空间与空闲页数两种上限。
            2. 保持后续 wptr 递增逻辑不变，保证环形队列推进与回绕的正确性。

### **## 总结**

- 漏洞类型: 环形缓冲区空间计算错误/越界写导致数据破坏与设备挂起
- 根本缺陷: 仅以“到缓冲区末尾的剩余空间”为上限，未同时受“实际空闲页数”约束，导致写入超过可用空间
- 修复原理: 在回绕前取 step = min(free, cnt - wptr)，据此限制单次拷贝 size，既不越过尾部也不超过空闲，避免覆盖正在读取的数据
```