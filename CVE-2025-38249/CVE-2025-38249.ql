import cpp

/**
 * 辅助函数：判断一个表达式是否是针对特定变量的、与 `sizeof` 相关的安全检查。
 */
predicate isSizeCheckForVar(RelationalOperation check, Variable sizeVar) {
  // 检查的一边必须是我们的目标变量 `sizeVar`
  check.getAnOperand().getAChild*().(VariableAccess).getTarget() = sizeVar and
  // 检查的另一边必须是一个 `sizeof` 表达式
  exists(SizeofExprOperator se | se = check.getAnOperand().getAChild*())
}

from
  Function func,                 // 目标函数
  Assignment source_assign,      // "源头": 形如 `wLength = le16_to_cpu(...)` 的赋值语句
  FunctionCall sink_alloc, // "汇点": 形如 `kzalloc(wLength, ...)` 的内存分配调用
  Variable sizeVar               // "连接变量": `wLength`
where
  // 步骤 1: 严格限定查询所在的函数和文件
  func.hasGlobalName("snd_usb_get_audioformat_uac3") and
  func.getFile().getAbsolutePath().matches("%/sound/usb/stream.c") and

  // 步骤 2: 在该函数内，定位“源头”赋值语句
  // - 赋值语句的右边是一个宏
  exists(MacroInvocation mi |
    source_assign.getRValue() = mi.getExpr() and
    mi.getMacro().getName() = "le16_to_cpu" and
    sizeVar = source_assign.getLValue().(VariableAccess).getTarget() and
    source_assign.getEnclosingFunction() = func // 确保此操作在目标函数内
  ) and

  // 步骤 3: 在同一个函数内，定位“汇点”内存分配调用
  // - 这是一个内存分配调用 (kzalloc, kmalloc 等)
  // - 其大小参数必须是我们在上一步中捕获的 `sizeVar`
  sink_alloc.getArgument(0).(VariableAccess).getTarget() = sizeVar and
  sink_alloc.getEnclosingFunction() = func and // 确保此操作在目标函数内

  // 步骤 4: 使用基于 BasicBlock 的 CFG 逻辑进行路径检查
  // a) 必须存在一条从 "源头"所在的基本块 到 "汇点"所在的基本块 的路径。*
  source_assign.getBasicBlock().getASuccessor*() = sink_alloc.getBasicBlock() and

  // b) 核心漏洞条件：确认这条路径上没有“安全检查点”。
  not exists(RelationalOperation check_op |
    isSizeCheckForVar(check_op, sizeVar) and
    check_op.getEnclosingFunction() = func and
    // i) 从“源头块”可以到达“检查块”
    source_assign.getBasicBlock().getASuccessor*() = check_op.getBasicBlock() and
    // ii) 从“检查块”可以到达“汇点块”
    check_op.getBasicBlock().getASuccessor*() = sink_alloc.getBasicBlock()
  )

select sink_alloc, // 将问题报告在内存分配的位置
       source_assign, // 以及相关的赋值语句
       sizeVar