/**
 * @name CVE-2025-38249
 * @description Detects an out-of-bounds read vulnerability where a length value from an untrusted
 *              USB device is used for memory allocation without prior validation. This can lead
 *              to allocating a buffer smaller than the expected structure size, causing an
 *              out-of-bounds read when accessing structure members.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/kernel/unchecked-usb-alloc-size
 * @tags security
 *       correctness
 *       memory
 *       out-of-bounds-read
 *       external/cwe/cwe-125
 *       external/cwe/cwe-131
 *       external/cwe/cwe-20
 * @patch-commit fb4e2a6e8f28a3c0ad382e363aeb9cd822007b8a
 * @source-file sound/usb/stream.c
 * @affected-function snd_usb_get_audioformat_uac3
 * @kernel-config CONFIG_SND_USB_AUDIO
 * @vulnerability-type out-of-bounds-read
 * @patch-diff |
 *     @@ -987,6 +987,8 @@ snd_usb_get_audioformat_uac3(struct snd_usb_audio *chip,
 *      	 * and request Cluster Descriptor
 *      	 *
 *      	wLength = le16_to_cpu(hc_header.wLength);
 *     +	if (wLength < sizeof(*cluster))
 *     +		return NULL;
 *      	cluster = kzalloc(wLength, GFP_KERNEL);
 *      	if (!cluster)
 *      		return ERR_PTR(-ENOMEM);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38249
 * @remediation 
 */
import cpp

/**
 * 辅助函数：判断一个表达式是否是针对特定变量的、与 `sizeof` 相关的安全检查。
 */
predicate isSizeCheckForVar(RelationalOperation check, Variable sizeVar) {
  // 检查的一边必须是我们的目标变量 `sizeVar`
  check.getAnOperand().getAChild*().(VariableAccess).getTarget() = sizeVar and
  // 检查的另一边必须是一个 `sizeof` 表达式
  exists(SizeofExprOperator se | se = check.getAnOperand().getAChild*())
}

from
  Function func,                 // 目标函数
  Assignment source_assign,      // "源头": 形如 `wLength = le16_to_cpu(...)` 的赋值语句
  FunctionCall sink_alloc, // "汇点": 形如 `kzalloc(wLength, ...)` 的内存分配调用
  Variable sizeVar               // "连接变量": `wLength`
where
  // 步骤 1: 严格限定查询所在的函数和文件
  // func.hasGlobalName("snd_usb_get_audioformat_uac3") and
  // func.getFile().getAbsolutePath().matches("%/sound/usb/stream.c") and

  // 步骤 2: 在该函数内，定位“源头”赋值语句
  // - 赋值语句的右边是一个宏
  exists(MacroInvocation mi |
    source_assign.getRValue() = mi.getExpr() and
    mi.getMacro().getName() = "le16_to_cpu" and
    sizeVar = source_assign.getLValue().(VariableAccess).getTarget() and
    source_assign.getEnclosingFunction() = func // 确保此操作在目标函数内
  ) and

  // 步骤 3: 在同一个函数内，定位“汇点”内存分配调用
  // - 这是一个内存分配调用 (kzalloc, kmalloc 等)
  // - 其大小参数必须是我们在上一步中捕获的 `sizeVar`
  sink_alloc.getArgument(0).(VariableAccess).getTarget() = sizeVar and
  sink_alloc.getEnclosingFunction() = func and // 确保此操作在目标函数内

  // 步骤 4: 使用基于 BasicBlock 的 CFG 逻辑进行路径检查
  // a) 必须存在一条从 "源头"所在的基本块 到 "汇点"所在的基本块 的路径。*
  source_assign.getBasicBlock().getASuccessor*() = sink_alloc.getBasicBlock() and

  // b) 核心漏洞条件：确认这条路径上没有“安全检查点”。
  not exists(RelationalOperation check_op |
    isSizeCheckForVar(check_op, sizeVar) and
    check_op.getEnclosingFunction() = func and
    // i) 从“源头块”可以到达“检查块”
    source_assign.getBasicBlock().getASuccessor*() = check_op.getBasicBlock() and
    // ii) 从“检查块”可以到达“汇点块”
    check_op.getBasicBlock().getASuccessor*() = sink_alloc.getBasicBlock()
  )

select sink_alloc, // 将问题报告在内存分配的位置
       "Memory allocation using unchecked size from USB device data. Size variable $@ is assigned from untrusted source $@ without validation.",
       sizeVar, sizeVar.getName(),
       source_assign, "here"