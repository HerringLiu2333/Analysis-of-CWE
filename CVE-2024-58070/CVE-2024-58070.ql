/**
 * @name CVE-2024-58070
 * @description In PREEMPT_RT, kmalloc(GFP_ATOMIC) is not safe in non-preemptible context.
 *              bpf_local_storage could allocate with kmalloc in such contexts, triggering
 *              "sleeping function called from invalid context" warnings and potential RT
 *              latency issues. The fix enforces bpf_mem_alloc for all bpf_local_storage
 *              allocations when CONFIG_PREEMPT_RT is enabled by forcing smap->bpf_ma = true.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/bpf-local-storage-preempt-rt-alloc
 * @tags
 *   reliability
 *   real-time
 *   kernel
 *   bpf
 *   memory-allocation
 *   preempt-rt
 *   sleeping-in-atomic
 * @patch-commit c1d398a3af7e59d7fef351c84fed7ebb575d1f1a
 * @source-file kernel/bpf/bpf_local_storage.c
 * @affected-function bpf_local_storage_map_alloc
 * @vulnerability-type sleep-in-atomic-context
 * @patch-diff
 *   diff --git a/kernel/bpf/bpf_local_storage.c b/kernel/bpf/bpf_local_storage.c
 *   index 7e6a0af0afc168…e94820f6b0cd38 100644
 *   --- a/kernel/bpf/bpf_local_storage.c
 *   +++ b/kernel/bpf/bpf_local_storage.c
 *   @@ -841,8 +841,12 @@ bpf_local_storage_map_alloc(union bpf_attr attr,
 *           smap->elem_size = offsetof(struct bpf_local_storage_elem,
 *                                      sdata.data[attr->value_size]);
 *
 *   -       smap->bpf_ma = bpf_ma;
 *   -       if (bpf_ma) {
 *   +       /* In PREEMPT_RT, kmalloc(GFP_ATOMIC) is still not safe in non-
 *   +        * preemptible context. Thus, enforce all storages to use
 *   +        * bpf_mem_alloc when CONFIG_PREEMPT_RT is enabled.
 *   +        &#47;
 *   +       smap->bpf_ma = IS_ENABLED(CONFIG_PREEMPT_RT) ? true : bpf_ma;
 *   +       if (smap->bpf_ma) {
 *               err = bpf_mem_alloc_init(&smap->selem_ma, smap->elem_size, false);
 *               if (err)
 *                       goto free_smap;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c1d398a3af7e59d7fef351c84fed7ebb575d1f1a
 * @remediation On PREEMPT_RT kernels, always allocate bpf_local_storage elements via
 *              bpf_mem_alloc by forcing smap->bpf_ma = true (e.g., use IS_ENABLED(CONFIG_PREEMPT_RT)
 *              ? true : bpf_ma). Avoid kmalloc(GFP_ATOMIC) in non-preemptible contexts to prevent
 *              sleeping-in-atomic violations; the verifier ensures GFP_KERNEL usage only in
 *              sleepable contexts when bpf_mem_cache is used.
 * @patch-description |
 *  bpf: bpf_local_storage: Always use bpf_mem_alloc in PREEMPT_RT
 *  [ Upstream commit 8eef6ac4d70eb1f0099fff93321d90ce8fa49ee1 ]
 *  
 *  In PREEMPT_RT, kmalloc(GFP_ATOMIC) is still not safe in non preemptible
 *  context. bpf_mem_alloc must be used in PREEMPT_RT. This patch is
 *  to enforce bpf_mem_alloc in the bpf_local_storage when CONFIG_PREEMPT_RT
 *  is enabled.
 *  
 *  [   35.118559] BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48
 *  [   35.118566] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 1832, name: test_progs
 *  [   35.118569] preempt_count: 1, expected: 0
 *  [   35.118571] RCU nest depth: 1, expected: 1
 *  [   35.118577] INFO: lockdep is turned off.
 *      ...
 *  [   35.118647]  __might_resched+0x433/0x5b0
 *  [   35.118677]  rt_spin_lock+0xc3/0x290
 *  [   35.118700]  ___slab_alloc+0x72/0xc40
 *  [   35.118723]  __kmalloc_noprof+0x13f/0x4e0
 *  [   35.118732]  bpf_map_kzalloc+0xe5/0x220
 *  [   35.118740]  bpf_selem_alloc+0x1d2/0x7b0
 *  [   35.118755]  bpf_local_storage_update+0x2fa/0x8b0
 *  [   35.118784]  bpf_sk_storage_get_tracing+0x15a/0x1d0
 *  [   35.118791]  bpf_prog_9a118d86fca78ebb_trace_inet_sock_set_state+0x44/0x66
 *  [   35.118795]  bpf_trace_run3+0x222/0x400
 *  [   35.118820]  __bpf_trace_inet_sock_set_state+0x11/0x20
 *  [   35.118824]  trace_inet_sock_set_state+0x112/0x130
 *  [   35.118830]  inet_sk_state_store+0x41/0x90
 *  [   35.118836]  tcp_set_state+0x3b3/0x640
 *  
 *  There is no need to adjust the gfp_flags passing to the
 *  bpf_mem_cache_alloc_flags() which only honors the GFP_KERNEL.
 *  The verifier has ensured GFP_KERNEL is passed only in sleepable context.
 *  
 *  It has been an old issue since the first introduction of the
 * bpf_local_storage ~5 years ago, so this patch targets the bpf-next.
 *  
 *  bpf_mem_alloc is needed to solve it, so the Fixes tag is set
 *  to the commit when bpf_mem_alloc was first used in the bpf_local_storage.
 * 
 *  Fixes: 08a7ce384e33 ("bpf: Use bpf_mem_cache_alloc/free in bpf_local_storage_elem")
 */

import cpp

/*
 * 检测BPF本地存储中的PREEMPT_RT安全问题
 * 该查询用于识别在PREEMPT_RT配置下未正确使用bpf_mem_alloc的情况
 * 在PREEMPT_RT中，kmalloc(GFP_ATOMIC)在非抢占上下文中仍然不安全，必须使用bpf_mem_alloc
 * This query identifies PREEMPT_RT safety issues where bpf_mem_alloc is not properly used
 * In PREEMPT_RT, kmalloc(GFP_ATOMIC) is not safe in non-preemptible context, bpf_mem_alloc must be used
 */

// 检查是否为bpf_local_storage_map_alloc函数
// Check if it's bpf_local_storage_map_alloc function
predicate isBpfLocalStorageMapAllocFunction(Function f) {
  f.getName() = "bpf_local_storage_map_alloc"
}

// 检查是否为bpf_ma变量赋值
// Check if it's assignment to bpf_ma variable
predicate isBpfMaAssignment(AssignExpr assign) {
  exists(VariableAccess varAccess |
    varAccess = assign.getLValue() and
    varAccess.getTarget().getName() = "bpf_ma"
  )
}

// 检查是否为IS_ENABLED(CONFIG_PREEMPT_RT)检查
// Check if it's IS_ENABLED(CONFIG_PREEMPT_RT) check
predicate isPreemptRtCheck(Expr expr) {
  expr.toString().matches("%IS_ENABLED%(CONFIG_PREEMPT_RT)%")
}

// 检查是否有PREEMPT_RT安全检查
// Check for PREEMPT_RT safety check
predicate hasPreemptRtSafetyCheck(AssignExpr assign) {
  exists(IfStmt ifStmt |
    ifStmt.getLocation().getStartLine() > assign.getLocation().getStartLine() and
    isPreemptRtCheck(ifStmt.getCondition()) and
    exists(AssignExpr safetyAssign |
      safetyAssign = ifStmt.getThen().getAChild() and
      safetyAssign.getLValue().toString() = "smap->bpf_ma"
    )
  )
}

from
  Function f,
  AssignExpr assign  // bpf_ma赋值表达式
where
  // 限制在bpf_local_storage_map_alloc函数内
  isBpfLocalStorageMapAllocFunction(f) and
  assign.getEnclosingFunction() = f and
  // 查找bpf_ma变量赋值
  isBpfMaAssignment(assign) and
  // 没有PREEMPT_RT安全检查
  not hasPreemptRtSafetyCheck(assign)
select
  assign,
  "Potential PREEMPT_RT safety issue: Missing CONFIG_PREEMPT_RT check for bpf_mem_alloc usage in bpf_local_storage_map_alloc()"
