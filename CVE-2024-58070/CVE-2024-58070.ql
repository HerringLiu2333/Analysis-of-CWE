/**
 * @name CVE-2024-58070
 * @description In PREEMPT_RT, kmalloc(GFP_ATOMIC) is not safe in non-preemptible context.
 *              bpf_local_storage could allocate with kmalloc in such contexts, triggering
 *              "sleeping function called from invalid context" warnings and potential RT
 *              latency issues. The fix enforces bpf_mem_alloc for all bpf_local_storage
 *              allocations when CONFIG_PREEMPT_RT is enabled by forcing smap->bpf_ma = true.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/bpf-local-storage-preempt-rt-alloc
 * @tags
 *   reliability
 *   real-time
 *   kernel
 *   bpf
 *   memory-allocation
 *   preempt-rt
 *   sleeping-in-atomic
 * @patch-commit c1d398a3af7e59d7fef351c84fed7ebb575d1f1a
 * @source-file kernel/bpf/bpf_local_storage.c
 * @affected-function bpf_local_storage_map_alloc
 * @vulnerability-type sleep-in-atomic-context
 * @patch-diff
 *   diff --git a/kernel/bpf/bpf_local_storage.c b/kernel/bpf/bpf_local_storage.c
 *   index 7e6a0af0afc168…e94820f6b0cd38 100644
 *   --- a/kernel/bpf/bpf_local_storage.c
 *   +++ b/kernel/bpf/bpf_local_storage.c
 *   @@ -841,8 +841,12 @@ bpf_local_storage_map_alloc(union bpf_attr attr,
 *           smap->elem_size = offsetof(struct bpf_local_storage_elem,
 *                                      sdata.data[attr->value_size]);
 *
 *   -       smap->bpf_ma = bpf_ma;
 *   -       if (bpf_ma) {
 *   +       /* In PREEMPT_RT, kmalloc(GFP_ATOMIC) is still not safe in non-
 *   +        * preemptible context. Thus, enforce all storages to use
 *   +        * bpf_mem_alloc when CONFIG_PREEMPT_RT is enabled.
 *   +        &#47;
 *   +       smap->bpf_ma = IS_ENABLED(CONFIG_PREEMPT_RT) ? true : bpf_ma;
 *   +       if (smap->bpf_ma) {
 *               err = bpf_mem_alloc_init(&smap->selem_ma, smap->elem_size, false);
 *               if (err)
 *                       goto free_smap;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=c1d398a3af7e59d7fef351c84fed7ebb575d1f1a
 * @remediation On PREEMPT_RT kernels, always allocate bpf_local_storage elements via
 *              bpf_mem_alloc by forcing smap->bpf_ma = true (e.g., use IS_ENABLED(CONFIG_PREEMPT_RT)
 *              ? true : bpf_ma). Avoid kmalloc(GFP_ATOMIC) in non-preemptible contexts to prevent
 *              sleeping-in-atomic violations; the verifier ensures GFP_KERNEL usage only in
 *              sleepable contexts when bpf_mem_cache is used.
 */

import cpp

/*
 * 检测BPF本地存储中的PREEMPT_RT安全问题
 * 该查询用于识别在PREEMPT_RT配置下未正确使用bpf_mem_alloc的情况
 * 在PREEMPT_RT中，kmalloc(GFP_ATOMIC)在非抢占上下文中仍然不安全，必须使用bpf_mem_alloc
 * This query identifies PREEMPT_RT safety issues where bpf_mem_alloc is not properly used
 * In PREEMPT_RT, kmalloc(GFP_ATOMIC) is not safe in non-preemptible context, bpf_mem_alloc must be used
 */

// 检查是否为bpf_local_storage_map_alloc函数
// Check if it's bpf_local_storage_map_alloc function
predicate isBpfLocalStorageMapAllocFunction(Function f) {
  f.getName() = "bpf_local_storage_map_alloc"
}

// 检查是否为bpf_ma变量赋值
// Check if it's assignment to bpf_ma variable
predicate isBpfMaAssignment(AssignExpr assign) {
  exists(VariableAccess varAccess |
    varAccess = assign.getLValue() and
    varAccess.getTarget().getName() = "bpf_ma"
  )
}

// 检查是否为IS_ENABLED(CONFIG_PREEMPT_RT)检查
// Check if it's IS_ENABLED(CONFIG_PREEMPT_RT) check
predicate isPreemptRtCheck(Expr expr) {
  expr.toString().matches("%IS_ENABLED%(CONFIG_PREEMPT_RT)%")
}

// 检查是否有PREEMPT_RT安全检查
// Check for PREEMPT_RT safety check
predicate hasPreemptRtSafetyCheck(AssignExpr assign) {
  exists(IfStmt ifStmt |
    ifStmt.getLocation().getStartLine() > assign.getLocation().getStartLine() and
    isPreemptRtCheck(ifStmt.getCondition()) and
    exists(AssignExpr safetyAssign |
      safetyAssign = ifStmt.getThen().getAChild() and
      safetyAssign.getLValue().toString() = "smap->bpf_ma"
    )
  )
}

from
  Function f,
  AssignExpr assign  // bpf_ma赋值表达式
where
  // 限制在bpf_local_storage_map_alloc函数内
  isBpfLocalStorageMapAllocFunction(f) and
  assign.getEnclosingFunction() = f and
  // 查找bpf_ma变量赋值
  isBpfMaAssignment(assign) and
  // 没有PREEMPT_RT安全检查
  not hasPreemptRtSafetyCheck(assign)
select
  assign,
  "Potential PREEMPT_RT safety issue: Missing CONFIG_PREEMPT_RT check for bpf_mem_alloc usage in bpf_local_storage_map_alloc()"
