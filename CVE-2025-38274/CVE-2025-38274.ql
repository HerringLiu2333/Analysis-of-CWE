/**
 * @name CVE-2025-38274
 * @description Detects a potential null pointer dereference in the fpga_mgr_test_img_load_sgt function.
 *              The function allocates memory using kunit_kzalloc but fails to check if the allocation
 *              was successful before passing the pointer to sg_alloc_table, which can lead to a crash.
 * @kind path-problem
 * @problem.severity error
 * @precision high
 * @id cpp/cve-2025-38274-null-deref-in-fpga-mgr-test
 * @tags security
 *       correctness
 *       memory
 *       null-dereference
 *       external/cwe/cwe-476
 * @patch-commit 6ebf1982038af12f3588417e4fd0417d2551da28
 * @source-file drivers/fpga/tests/fpga-mgr-test.c
 * @affected-function fpga_mgr_test_img_load_sgt
 * @kernel-config CONFIG_FPGA_MGR_TEST
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *     @@ -263,6 +263,7 @@ static void fpga_mgr_test_img_load_sgt(struct kunit *test)
 *      	img_buf = init_test_buffer(test, IMAGE_SIZE);
 *      
 *      	sgt = kunit_kzalloc(test, sizeof(*sgt), GFP_KERNEL);
 *     +	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, sgt);
 *      	ret = sg_alloc_table(sgt, 1, GFP_KERNEL);
 *      	KUNIT_ASSERT_EQ(test, ret, 0);
 *      	sg_init_one(sgt->sgl, img_buf, IMAGE_SIZE);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38274
 * @remediation
 */
import cpp
import semmle.code.cpp.dataflow.new.DataFlow
import semmle.code.cpp.dataflow.new.TaintTracking

module FpgaMgrTestConfig implements DataFlow::ConfigSig {
  /**
   * 定义污点源：`kunit_kzalloc` 函数的返回值，但仅限于特定的漏洞函数和文件。
   * 注意：在新版 API 中，谓词 (predicate) 前不再需要 'override' 关键字。
   */
  predicate isSource(DataFlow::Node source) {
    exists(FunctionCall call, Function f |
      // 源头是一个函数调用
      source.asExpr() = call and
      // 该调用是对 `kunit_kzalloc` 的调用
      call.getTarget().getName() = "kunit_kzalloc" and
      // 该调用必须位于 `fpga_mgr_test_img_load_sgt` 函数内部
      f = call.getEnclosingFunction() and
      f.getName() = "fpga_mgr_test_img_load_sgt" and
      // 该函数必须位于 `fpga-mgr-test.c` 文件中
      f.getFile().getRelativePath().matches("fpga-mgr-test.c")
    )
  }

  /**
   * 定义污点汇：即潜在的空指针被使用的位置。这里是 `sg_alloc_table` 函数的第一个参数。
   */
  predicate isSink(DataFlow::Node sink) {
    exists(FunctionCall call, Function f |
      // 汇是函数调用的第一个参数
      sink.asExpr() = call.getArgument(0) and
      // 该调用是对 `sg_alloc_table` 的调用
      call.getTarget().getName() = "sg_alloc_table" and
      // 该调用必须位于 `fpga_mgr_test_img_load_sgt` 函数内部
      f = call.getEnclosingFunction() and
      f.getName() = "fpga_mgr_test_img_load_sgt" and
      // 该函数必须位于 `fpga-mgr-test.c` 文件中
      f.getFile().getRelativePath().matches("fpga-mgr-test.c")
    )
  }

    predicate isBarrier(DataFlow::Node barrier) {
    exists(FunctionCall call |
      // 检查宏的名称是否为修复漏洞所用的宏
      call.getTarget().getName() = "KUNIT_ASSERT_NOT_ERR_OR_NULL" and
      // 屏障节点是该宏调用的第二个参数（索引为1），也就是被检查的指针
      barrier.asExpr() = call.getArgument(1)
    )
  }
}

// 2. 使用上面定义的配置模块 (FpgaMgrTestConfig) 来实例化一个全局的污点跟踪分析模块。
module FpgaMgrTestFlow = TaintTracking::Global<FpgaMgrTestConfig>;

// 7. 从我们刚刚实例化的分析模块中导入专用的 PathGraph，用于后续的路径查询。
import FpgaMgrTestFlow::PathGraph

// 8. from 子句现在直接使用我们实例化的模块中的路径节点 (PathNode)。
from FpgaMgrTestFlow::PathNode source, FpgaMgrTestFlow::PathNode sink
// 9. where 子句直接调用我们实例化的模块中的 flowPath 谓词来查找路径。
where FpgaMgrTestFlow::flowPath(source, sink)
select sink.getNode(), source, sink, source.getNode(), "源头", sink.getNode(), "汇点"