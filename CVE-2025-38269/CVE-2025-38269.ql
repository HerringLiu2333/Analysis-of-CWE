/**
 * @name CVE-2025-38269
 * @description Detects cases where an error-handling block calls a panic function
 *              after an IS_ERR check but fails to include a terminating statement like 'goto' or 'return'.
 *              This allows control flow to fall through, leading to the dereference of an error pointer,
 *              particularly when CONFIG_BUG is disabled.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id c/fallthrough-after-error-panic
 * @tags security
 *       correctness
 *       error-handling
 *       external/cwe/cwe-476
 * @patch-commit 3bf179e36da917c5d9bec71c714573ed1649b7c1
 * @source-file fs/btrfs/extent-io-tree.c
 * @affected-function btrfs_convert_extent_bit
 * @kernel-config CONFIG_BTRFS_FS
 * @vulnerability-type error-handling-fallthrough
 * @patch-diff |
 *     @@ -1439,6 +1439,7 @@ hit_next:
 *      		if (IS_ERR(inserted_state)) {
 *      			ret = PTR_ERR(inserted_state);
 *      			extent_io_tree_panic(tree, prealloc, "insert", ret);
 *     +			goto out;
 *      		}
 *      		cache_state(inserted_state, cached_state);
 *      		if (inserted_state == prealloc)
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38269
 * @patch-description |
 *     btrfs: exit after state insertion failure at btrfs_convert_extent_bit()
 *     If insert_state() state failed it returns an error pointer and we call
 *     extent_io_tree_panic() which will trigger a BUG() call. However if
 *     CONFIG_BUG is disabled, which is an uncommon and exotic scenario, then
 *     we fallthrough and call cache_state() which will dereference the error
 *     pointer, resulting in an invalid memory access.
 *     
 *     So jump to the 'out' label after calling extent_io_tree_panic(), it also
 *     makes the code more clear besides dealing with the exotic scenario where
 *     CONFIG_BUG is disabled.
 */
import cpp

/**
 * Holds if a function call `fc` is considered a "panic" or "bug" call,
 * which is expected to terminate execution.
 */
predicate isPanicCall(FunctionCall fc) {
  // Matches function names like '..._panic', '..._bug', 'BUG', etc.
  // This can be expanded based on the codebase's conventions.
  fc.getTarget().getName().regexpMatch("(?i).*(panic|bug).*")
}

/**
 * Holds if a statement `s` explicitly terminates control flow within a function.
 */
predicate isTerminator(Stmt s) {
  s instanceof ReturnStmt or
  s instanceof GotoStmt or
  s instanceof BreakStmt or
  s instanceof ContinueStmt
}

/*
 * 判断一个 FieldAccess base 是否作为其下一级字段赋值的基（写操作），
 * 例如 base.dev = ... / base.type += 1。
 * 只检查简单字段赋值：lhs 的 qualifier = base。
 */
predicate isBaseOfFieldAssignment(FieldAccess base) {
  exists(AssignExpr a, FieldAccess lhs |
    lhs = a.getLValue() and
    lhs.getQualifier() = base
  )
}

// Trivial wrapper to mark the predicate as used without affecting results.
predicate usesBaseOfFieldAssignment() { exists(FieldAccess b | isBaseOfFieldAssignment(b)) or not exists(FieldAccess b | isBaseOfFieldAssignment(b)) }

from IfStmt ifStmt, FunctionCall isErr, FunctionCall panicCall
where
  // 1. Condition is an IS_ERR call.
  isErr = ifStmt.getCondition() and
  isErr.getTarget().getName() = "IS_ERR" and

  // 2. A panic-style call exists in the then branch.
  panicCall.getEnclosingStmt().getParent*() = ifStmt.getThen() and
  isPanicCall(panicCall) and

  // 3. Then branch does NOT end with a terminator.
  exists(Stmt lastStmt |
    lastStmt = ifStmt.getThen().(BlockStmt).getLastStmt() or
    ( lastStmt = ifStmt.getThen() and not ifStmt.getThen() instanceof BlockStmt )
    |
    not isTerminator(lastStmt)
  ) and usesBaseOfFieldAssignment()
select ifStmt,
  "Missing terminating statement (goto/return) after panic in IS_ERR branch; may fall through and dereference error pointer." /* keep predicate defined: */