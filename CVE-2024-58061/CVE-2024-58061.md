```markdown
### **## 根因描述**

此问题的根本原因是调试接口对“活动链路”掩码缺乏有效性校验：debugfs 中解析 active_links 的函数允许将其设置为 0，从而尝试“停用所有链路”。内部 API 将此视为不合法状态并以 WARN_ON 警告，但仍应在外层输入解析阶段直接拒绝该无效值，避免触发内核告警与进入未定义状态。

1. 被修改的代码:
    ```c
    @@ -588,7 +588,7 @@ static ssize_t ieee80211_if_parse_active_links(struct ieee80211_sub_if_data *sda
     {
     	u16 active_links;
     
    -	if (kstrtou16(buf, 0, &active_links))
    +	if (kstrtou16(buf, 0, &active_links) || !active_links)
     		return -EINVAL;
     
     	return ieee80211_set_active_links(&sdata->vif, active_links) ?: buflen;
    ```
    - 修改原因: 在 debugfs 写入路径上阻止将活动链路掩码设置为 0，避免内部 WARN_ON 以及不受支持的“全部禁用”状态。
        - 旧代码的缺陷:
            1. 仅检查数值解析是否成功，未验证 active_links 非零。
            2. 允许通过 debugfs 将所有链路禁用，违背内部 API 的不变量并触发 WARN_ON。
            3. 可能导致状态机进入不支持/未定义状态，影响稳定性与调试体验。
        - 新代码的修复:
            1. 在解析后增加非零校验（!active_links），对 0 值直接返回 -EINVAL。
            2. 将防护提前到输入层，避免触发内部 WARN_ON，保证至少有一个链路保持活动。
            3. 保持后续逻辑不变，最小化改动风险。

### **## 总结**

- 漏洞类型: 输入校验缺失/非法状态允许（导致内部 WARN 与潜在状态机异常）
- 根本缺陷: 未对 active_links 的非零性进行约束，违背内部 API 对不变量的假设
- 修复原理: 在 debugfs 写入解析阶段增加非零校验，对 0 值拒绝处理，防止进入不支持的“全部禁用”状态
```