/**
 * @name CVE-2025-38304
 * @description Detects a NULL pointer dereference in the `eir_get_service_data` function. The optional
 *              parameter `len` is not checked for NULL before being dereferenced to calculate the
 *              offset for the next service data entry. This can lead to a kernel panic if a caller
 *              passes NULL for this parameter.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/null-pointer-dereference-eir
 * @tags security
 *       correctness
 *       external/cwe/cwe-476
 * @patch-commit 20a2aa01f5aeb6daad9aeaa7c33dd512c58d81eb
 * @source-file net/bluetooth/eir.c
 * @affected-function eir_get_service_data
 * @kernel-config CONFIG_BT
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *     @@ -366,17 +366,19 @@ u8 eir_create_scan_rsp(struct hci_dev *hdev, u8 instance, u8 *ptr)
 *      
 *      void *eir_get_service_data(u8 *eir, size_t eir_len, u16 uuid, size_t *len)
 *      {
 *     -	while ((eir = eir_get_data(eir, eir_len, EIR_SERVICE_DATA, len))) {
 *     +	size_t dlen;
 *     +
 *     +	while ((eir = eir_get_data(eir, eir_len, EIR_SERVICE_DATA, &dlen))) {
 *      		u16 value = get_unaligned_le16(eir);
 *      
 *      		if (uuid == value) {
 *      			if (len)
 *     -				*len -= 2;
 *     +				*len = dlen - 2;
 *      			return &eir[2];
 *      		}
 *      
 *     -		eir += *len;
 *     -		eir_len -= *len;
 *     +		eir += dlen;
 *     +		eir_len -= dlen;
 *      	}
 *      
 *      	return NULL;
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38304
 * @remediation 
 */

import cpp
import semmle.code.cpp.dataflow.DataFlow
import semmle.code.cpp.controlflow.Guards

// 定义目标函数
predicate isTargetFunction(Function f) {
  f.getName() = "eir_get_service_data" and
  f.getFile().getBaseName() = "eir.c"
}

// 定义可选指针参数
predicate isOptionalPointerParam(Parameter p) {
  exists(Function f | isTargetFunction(f) and p = f.getAParameter() |
    p.getType() instanceof PointerType and
    p.getName() = "len"
  )
}

from PointerDereferenceExpr deref, Parameter p
where
  // 确保我们在目标函数中
  exists(Function f | isTargetFunction(f) |
    deref.getEnclosingFunction() = f
  ) and
  // 找到对可选指针参数的解引用
  isOptionalPointerParam(p) and
  deref.getOperand().(VariableAccess).getTarget() = p and
  // 确保解引用不在空指针检查之内
  not exists(IfStmt ifStmt |
    ifStmt.getCondition().getAChild*().(VariableAccess).getTarget() = p and
    ifStmt.getAChild*() = deref.getEnclosingStmt()
  )
select deref, "可能的空指针解引用：参数 " + p.getName() + " 可能为 NULL"