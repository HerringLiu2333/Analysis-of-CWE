```markdown
### **## 根因描述**

根因在于用于保存 MBOX ICU0 中断屏蔽寄存器的数组大小计算错误。驱动在系统挂起/恢复路径中需要保存/恢复全部 4 个中断屏蔽寄存器，但结构体中将数组定义为 intr_mask[TH_1520_MBOX_CHANS - 1]。当代码按寄存器数量（4 个）访问该数组时，会访问到越界元素，造成内存破坏（memory corruption），在挂起/恢复过程中表现为错误行为或崩溃。

1. 被修改的代码:
    ```c
    @@ -41,7 +41,7 @@
     #ifdef CONFIG_PM_SLEEP
     /* store MBOX context across system-wide suspend/resume transitions */
     struct th1520_mbox_context {
    -	u32 intr_mask[TH_1520_MBOX_CHANS - 1];
    +	u32 intr_mask[TH_1520_MBOX_CHANS];
     };
     #endif
    ```
    - 修改原因:
        - 旧代码的缺陷:
            1. 将数组长度定义为 TH_1520_MBOX_CHANS - 1，少分配了一个元素；在保存 4 个寄存器值时发生数组越界写，导致内存破坏。
            2. 数组大小与硬件寄存器数量不一致，属于典型的 off-by-one 错误，风险在挂起/恢复路径中稳定复现。
        - 新代码的修复:
            1. 将数组长度更正为 TH_1520_MBOX_CHANS，确保可容纳全部 4 个中断屏蔽寄存器，消除越界访问。
            2. 与保存/恢复逻辑保持一致，避免在 suspend/resume 时破坏相邻内存，提升系统稳定性。

### **## 总结**

- 漏洞类型: 缓冲区越界写/内存破坏
- 根本缺陷: 静态数组长度计算错误（少 1，off-by-one）
- 修复原理: 将 intr_mask 数组大小改为寄存器实际数量（TH_1520_MBOX_CHANS），避免保存/恢复时的越界访问
```