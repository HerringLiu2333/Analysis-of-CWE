/**
 * @name CVE-2025-38346
 * @description In the ftrace subsystem, the `ftrace_release_mod` function would prematurely exit if the `ftrace_disabled` flag was set. This prevented the cleanup of the module's metadata (`mod_map`) from the global `ftrace_mod_maps` list. When the module was subsequently unloaded, its memory was freed, but the stale `mod_map` entry remained. A later access to `/proc/kallsyms` would traverse this list and attempt to dereference the stale pointer in the `mod_map` entry, leading to a Use-After-Free vulnerability.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/ftrace-disabled-uaf
 * @tags security
 *       correctness
 *       external/cwe/cwe-416
 * @patch-commit f914b52c379c12288b7623bb814d0508dbe7481d
 * @source-file kernel/trace/ftrace.c
 * @affected-function ftrace_release_mod
 * @kernel-config CONFIG_FTRACE
 * @vulnerability-type use-after-free
 * @patch-diff |
 *     @@ -7438,9 +7438,10 @@ void ftrace_release_mod(struct module *mod)
 *      
 *      	mutex_lock(&ftrace_lock);
 *      
 *     -	if (ftrace_disabled)
 *     -		goto out_unlock;
 *     -
 *     +	/*
 *     +	 * To avoid the UAF problem after the module is unloaded, the
 *     +	 * 'mod_map' resource needs to be released unconditionally.
 *     +	 *&#47;
 *      	list_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {
 *      		if (mod_map->mod == mod) {
 *      			list_del_rcu(&mod_map->list);
 *     @@ -7449,6 +7450,9 @@ void ftrace_release_mod(struct module *mod)
 *      		}
 *      	}
 *      
 *     +	if (ftrace_disabled)
 *     +		goto out_unlock;
 *     +
 *      	/*
 *      	 * Each module has its own ftrace_pages, remove
 *      	 * them from the list.
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38346
 * @remediation 
 */

import cpp

// 定义谓词来识别状态检查条件语句
predicate isStatusCheck(IfStmt ifStmt, Variable statusVar) {
  exists(EqualityOperation eq |
    ifStmt.getCondition() = eq and
    eq.getAnOperand() = statusVar.getAnAccess()
  ) or
  exists(RelationalOperation rel |
    ifStmt.getCondition() = rel and
    rel.getAnOperand() = statusVar.getAnAccess()
  ) or
  // 直接检查状态变量
  ifStmt.getCondition() = statusVar.getAnAccess()
}

// 定义谓词来识别提前返回语句
predicate hasEarlyReturn(IfStmt ifStmt) {
  exists(ReturnStmt ret |
    ret.getEnclosingStmt() = ifStmt.getThen()
  ) or
  exists(GotoStmt gotoStmt |
    gotoStmt.getEnclosingStmt() = ifStmt.getThen()
  )
}

// 定义谓词来识别链表遍历和资源清理操作
predicate isListTraversalAndCleanup(Stmt stmt, Variable listVar) {
  // 检查for_each_entry_safe模式的循环
  exists(ForStmt forLoop |
    stmt = forLoop and
    exists(FunctionCall call |
      call.getEnclosingStmt() = forLoop and
      call.getTarget().getName().matches("%list_%") and
      call.getAnArgument() = listVar.getAnAccess()
    )
  ) or
  // 检查while循环遍历链表
  exists(WhileStmt whileLoop |
    stmt = whileLoop and
    exists(FieldAccess fieldAccess |
      fieldAccess.getEnclosingStmt() = whileLoop and
      fieldAccess.getTarget().getName().matches("%next%") and
      fieldAccess.getQualifier() = listVar.getAnAccess()
    )
  ) or
  // 检查do-while循环遍历链表
  exists(DoStmt doLoop |
    stmt = doLoop and
    exists(FieldAccess fieldAccess |
      fieldAccess.getEnclosingStmt() = doLoop and
      fieldAccess.getTarget().getName().matches("%next%") and
      fieldAccess.getQualifier() = listVar.getAnAccess()
    )
  )
}

// 定义谓词来识别资源释放操作
predicate hasResourceCleanup(Stmt stmt) {
  exists(FunctionCall call |
    call.getEnclosingStmt() = stmt and
    (
      call.getTarget().getName().matches("%free%") or
      call.getTarget().getName().matches("%release%") or
      call.getTarget().getName().matches("%del%") or
      call.getTarget().getName().matches("%remove%") or
      call.getTarget().getName().matches("%put%") or
      call.getTarget().getName().matches("%cleanup%")
    )
  )
}

// 定义谓词来检查函数是否有锁保护
predicate hasMutexProtection(Function f) {
  exists(FunctionCall lockCall, FunctionCall unlockCall |
    lockCall.getEnclosingFunction() = f and
    unlockCall.getEnclosingFunction() = f and
    lockCall.getTarget().getName().matches("%lock%") and
    unlockCall.getTarget().getName().matches("%unlock%") and
    lockCall.getLocation().getStartLine() < unlockCall.getLocation().getStartLine()
  )
}

from Function f, IfStmt statusCheck, Stmt listTraversal, Variable statusVar, Variable listVar
where
  statusCheck.getEnclosingFunction() = f and
  listTraversal.getEnclosingFunction() = f and
  
  // 识别状态检查和提前返回模式
  isStatusCheck(statusCheck, statusVar) and
  hasEarlyReturn(statusCheck) and
  
  // 识别链表遍历和资源清理
  isListTraversalAndCleanup(listTraversal, listVar) and
  hasResourceCleanup(listTraversal) and
  
  // 关键：状态检查在资源清理之前
  statusCheck.getLocation().getStartLine() < listTraversal.getLocation().getStartLine() and
  
  // 确保函数有适当的锁保护（ftrace场景）
  hasMutexProtection(f) and
  
  // 检查状态变量名称模式（类似ftrace_disabled）
  (
    statusVar.getName().matches("%disabled%") or
    statusVar.getName().matches("%enabled%") or
    statusVar.getName().matches("%active%") or
    statusVar.getName().matches("%initialized%")
  ) and
  
  // 检查链表变量名称模式
  (
    listVar.getName().matches("%_maps") or
    listVar.getName().matches("%_list") or
    listVar.getName().matches("%_entries") or
    listVar.getName().matches("%_queue")
  )

select statusCheck, 
       "潜在的UAF漏洞: 在清理链表 '" + listVar.getName() + 
       "' 之前检查状态变量 '" + statusVar.getName() + 
       "' 并可能提前返回。这可能导致模块卸载时资源未被正确释放，" +
       "应该将状态检查移动到资源清理操作之后。"