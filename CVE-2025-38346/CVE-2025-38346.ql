/**
 * @name CVE-2025-38346
 * @description In the ftrace subsystem, the `ftrace_release_mod` function would prematurely exit if the `ftrace_disabled` flag was set. This prevented the cleanup of the module's metadata (`mod_map`) from the global `ftrace_mod_maps` list. When the module was subsequently unloaded, its memory was freed, but the stale `mod_map` entry remained. A later access to `/proc/kallsyms` would traverse this list and attempt to dereference the stale pointer in the `mod_map` entry, leading to a Use-After-Free vulnerability.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/ftrace-disabled-uaf
 * @tags security
 *       correctness
 *       external/cwe/cwe-416
 * @patch-commit f914b52c379c12288b7623bb814d0508dbe7481d
 * @source-file kernel/trace/ftrace.c
 * @affected-function ftrace_release_mod
 * @kernel-config CONFIG_FTRACE
 * @vulnerability-type use-after-free
 * @patch-diff |
 *     @@ -7438,9 +7438,10 @@ void ftrace_release_mod(struct module *mod)
 *      
 *      	mutex_lock(&ftrace_lock);
 *      
 *     -	if (ftrace_disabled)
 *     -		goto out_unlock;
 *     -
 *     +	/*
 *     +	 * To avoid the UAF problem after the module is unloaded, the
 *     +	 * 'mod_map' resource needs to be released unconditionally.
 *     +	 *&#47;
 *      	list_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {
 *      		if (mod_map->mod == mod) {
 *      			list_del_rcu(&mod_map->list);
 *     @@ -7449,6 +7450,9 @@ void ftrace_release_mod(struct module *mod)
 *      		}
 *      	}
 *      
 *     +	if (ftrace_disabled)
 *     +		goto out_unlock;
 *     +
 *      	/*
 *      	 * Each module has its own ftrace_pages, remove
 *      	 * them from the list.
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38346
 * @remediation 
 * @patch-description |
 *     ftrace: Fix UAF when lookup kallsym after ftrace disabled
 *     The following issue happens with a buggy module:
 *     
 *     BUG: unable to handle page fault for address: ffffffffc05d0218
 *     PGD 1bd66f067 P4D 1bd66f067 PUD 1bd671067 PMD 101808067 PTE 0
 *     Oops: Oops: 0000 [#1] SMP KASAN PTI
 *     Tainted: [O]=OOT_MODULE, [E]=UNSIGNED_MODULE
 *     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
 *     RIP: 0010:sized_strscpy+0x81/0x2f0
 *     RSP: 0018:ffff88812d76fa08 EFLAGS: 00010246
 *     RAX: 0000000000000000 RBX: ffffffffc0601010 RCX: dffffc0000000000
 *     RDX: 0000000000000038 RSI: dffffc0000000000 RDI: ffff88812608da2d
 *     RBP: 8080808080808080 R08: ffff88812608da2d R09: ffff88812608da68
 *     R10: ffff88812608d82d R11: ffff88812608d810 R12: 0000000000000038
 *     R13: ffff88812608da2d R14: ffffffffc05d0218 R15: fefefefefefefeff
 *     FS:  00007fef552de740(0000) GS:ffff8884251c7000(0000) knlGS:0000000000000000
 *     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 *     CR2: ffffffffc05d0218 CR3: 00000001146f0000 CR4: 00000000000006f0
 *     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
 *     DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
 *     Call Trace:
 *      <TASK>
 *      ftrace_mod_get_kallsym+0x1ac/0x590
 *      update_iter_mod+0x239/0x5b0
 *      s_next+0x5b/0xa0
 *      seq_read_iter+0x8c9/0x1070
 *      seq_read+0x249/0x3b0
 *      proc_reg_read+0x1b0/0x280
 *      vfs_read+0x17f/0x920
 *      ksys_read+0xf3/0x1c0
 *      do_syscall_64+0x5f/0x2e0
 *      entry_SYSCALL_64_after_hwframe+0x76/0x7e
 *     
 *     The above issue may happen as follows:
 *     (1) Add kprobe tracepoint;
 *     (2) insmod test.ko;
 *     (3)  Module triggers ftrace disabled;
 *     (4) rmmod test.ko;
 *     (5) cat /proc/kallsyms; --> Will trigger UAF as test.ko already removed;
 *     ftrace_mod_get_kallsym()
 *     ...
 *     strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);
 *     ...
 *     
 *     The problem is when a module triggers an issue with ftrace and
 *     sets ftrace_disable. The ftrace_disable is set when an anomaly is
 *     discovered and to prevent any more damage, ftrace stops all text
 *     modification. The issue that happened was that the ftrace_disable stops
 *     more than just the text modification.
 *     
 *     When a module is loaded, its init functions can also be traced. Because
 *     kallsyms deletes the init functions after a module has loaded, ftrace
 *     saves them when the module is loaded and function tracing is enabled. This
 *     allows the output of the function trace to show the init function names
 *     instead of just their raw memory addresses.
 *     
 *     When a module is removed, ftrace_release_mod() is called, and if
 *     ftrace_disable is set, it just returns without doing anything more. The
 *     problem here is that it leaves the mod_list still around and if kallsyms
 * is called, it will call into this code and access the module memory that
 *     has already been freed as it will return:
 *     
 *       strscpy(module_name, mod_map->mod->name, MODULE_NAME_LEN);
 *     
 *     Where the "mod" no longer exists and triggers a UAF bug.
 */

import cpp

// 定义谓词来识别状态检查条件语句
predicate isStatusCheck(IfStmt ifStmt, Variable statusVar) {
  exists(EqualityOperation eq |
    ifStmt.getCondition() = eq and
    eq.getAnOperand() = statusVar.getAnAccess()
  ) or
  exists(RelationalOperation rel |
    ifStmt.getCondition() = rel and
    rel.getAnOperand() = statusVar.getAnAccess()
  ) or
  // 直接检查状态变量
  ifStmt.getCondition() = statusVar.getAnAccess()
}

// 定义谓词来识别提前返回语句
predicate hasEarlyReturn(IfStmt ifStmt) {
  exists(ReturnStmt ret |
    ret.getEnclosingStmt() = ifStmt.getThen()
  ) or
  exists(GotoStmt gotoStmt |
    gotoStmt.getEnclosingStmt() = ifStmt.getThen()
  )
}

// 定义谓词来识别链表遍历和资源清理操作
predicate isListTraversalAndCleanup(Stmt stmt, Variable listVar) {
  // 检查for_each_entry_safe模式的循环
  exists(ForStmt forLoop |
    stmt = forLoop and
    exists(FunctionCall call |
      call.getEnclosingStmt() = forLoop and
      call.getTarget().getName().matches("%list_%") and
      call.getAnArgument() = listVar.getAnAccess()
    )
  ) or
  // 检查while循环遍历链表
  exists(WhileStmt whileLoop |
    stmt = whileLoop and
    exists(FieldAccess fieldAccess |
      fieldAccess.getEnclosingStmt() = whileLoop and
      fieldAccess.getTarget().getName().matches("%next%") and
      fieldAccess.getQualifier() = listVar.getAnAccess()
    )
  ) or
  // 检查do-while循环遍历链表
  exists(DoStmt doLoop |
    stmt = doLoop and
    exists(FieldAccess fieldAccess |
      fieldAccess.getEnclosingStmt() = doLoop and
      fieldAccess.getTarget().getName().matches("%next%") and
      fieldAccess.getQualifier() = listVar.getAnAccess()
    )
  )
}

// 定义谓词来识别资源释放操作
predicate hasResourceCleanup(Stmt stmt) {
  exists(FunctionCall call |
    call.getEnclosingStmt() = stmt and
    (
      call.getTarget().getName().matches("%free%") or
      call.getTarget().getName().matches("%release%") or
      call.getTarget().getName().matches("%del%") or
      call.getTarget().getName().matches("%remove%") or
      call.getTarget().getName().matches("%put%") or
      call.getTarget().getName().matches("%cleanup%")
    )
  )
}

// 定义谓词来检查函数是否有锁保护
predicate hasMutexProtection(Function f) {
  exists(FunctionCall lockCall, FunctionCall unlockCall |
    lockCall.getEnclosingFunction() = f and
    unlockCall.getEnclosingFunction() = f and
    lockCall.getTarget().getName().matches("%lock%") and
    unlockCall.getTarget().getName().matches("%unlock%") and
    lockCall.getLocation().getStartLine() < unlockCall.getLocation().getStartLine()
  )
}

from Function f, IfStmt statusCheck, Stmt listTraversal, Variable statusVar, Variable listVar
where
  statusCheck.getEnclosingFunction() = f and
  listTraversal.getEnclosingFunction() = f and
  
  // 识别状态检查和提前返回模式
  isStatusCheck(statusCheck, statusVar) and
  hasEarlyReturn(statusCheck) and
  
  // 识别链表遍历和资源清理
  isListTraversalAndCleanup(listTraversal, listVar) and
  hasResourceCleanup(listTraversal) and
  
  // 关键：状态检查在资源清理之前
  statusCheck.getLocation().getStartLine() < listTraversal.getLocation().getStartLine() and
  
  // 确保函数有适当的锁保护（ftrace场景）
  hasMutexProtection(f) and
  
  // 检查状态变量名称模式（类似ftrace_disabled）
  (
    statusVar.getName().matches("%disabled%") or
    statusVar.getName().matches("%enabled%") or
    statusVar.getName().matches("%active%") or
    statusVar.getName().matches("%initialized%")
  ) and
  
  // 检查链表变量名称模式
  (
    listVar.getName().matches("%_maps") or
    listVar.getName().matches("%_list") or
    listVar.getName().matches("%_entries") or
    listVar.getName().matches("%_queue")
  )

select statusCheck, 
       "潜在的UAF漏洞: 在清理链表 '" + listVar.getName() + 
       "' 之前检查状态变量 '" + statusVar.getName() + 
       "' 并可能提前返回。这可能导致模块卸载时资源未被正确释放，" +
       "应该将状态检查移动到资源清理操作之后。"