/**
 * @name 资源清理前的状态检查导致UAF漏洞
 * @description 检测在资源清理操作之前进行状态检查并可能提前返回的代码模式，
 *              这可能导致资源未被正确释放，从而引发Use-After-Free漏洞
 * @kind problem
 * @problem.severity error
 * @precision medium
 * @id cpp/resource-cleanup-before-status-check
 * @tags security
 *       reliability
 *       correctness
 *       external/cwe/cwe-416
 *       external/cwe/cwe-459
 */

import cpp

// 定义谓词来识别状态检查条件语句
predicate isStatusCheck(IfStmt ifStmt, Variable statusVar) {
  exists(EqualityOperation eq |
    ifStmt.getCondition() = eq and
    eq.getAnOperand() = statusVar.getAnAccess()
  ) or
  exists(RelationalOperation rel |
    ifStmt.getCondition() = rel and
    rel.getAnOperand() = statusVar.getAnAccess()
  ) or
  // 直接检查状态变量
  ifStmt.getCondition() = statusVar.getAnAccess()
}

// 定义谓词来识别提前返回语句
predicate hasEarlyReturn(IfStmt ifStmt) {
  exists(ReturnStmt ret |
    ret.getEnclosingStmt() = ifStmt.getThen()
  ) or
  exists(GotoStmt gotoStmt |
    gotoStmt.getEnclosingStmt() = ifStmt.getThen()
  )
}

// 定义谓词来识别链表遍历和资源清理操作
predicate isListTraversalAndCleanup(Stmt stmt, Variable listVar) {
  // 检查for_each_entry_safe模式的循环
  exists(ForStmt forLoop |
    stmt = forLoop and
    exists(FunctionCall call |
      call.getEnclosingStmt() = forLoop and
      call.getTarget().getName().matches("%list_%") and
      call.getAnArgument() = listVar.getAnAccess()
    )
  ) or
  // 检查while循环遍历链表
  exists(WhileStmt whileLoop |
    stmt = whileLoop and
    exists(FieldAccess fieldAccess |
      fieldAccess.getEnclosingStmt() = whileLoop and
      fieldAccess.getTarget().getName().matches("%next%") and
      fieldAccess.getQualifier() = listVar.getAnAccess()
    )
  ) or
  // 检查do-while循环遍历链表
  exists(DoStmt doLoop |
    stmt = doLoop and
    exists(FieldAccess fieldAccess |
      fieldAccess.getEnclosingStmt() = doLoop and
      fieldAccess.getTarget().getName().matches("%next%") and
      fieldAccess.getQualifier() = listVar.getAnAccess()
    )
  )
}

// 定义谓词来识别资源释放操作
predicate hasResourceCleanup(Stmt stmt) {
  exists(FunctionCall call |
    call.getEnclosingStmt() = stmt and
    (
      call.getTarget().getName().matches("%free%") or
      call.getTarget().getName().matches("%release%") or
      call.getTarget().getName().matches("%del%") or
      call.getTarget().getName().matches("%remove%") or
      call.getTarget().getName().matches("%put%") or
      call.getTarget().getName().matches("%cleanup%")
    )
  )
}

// 定义谓词来检查函数是否有锁保护
predicate hasMutexProtection(Function f) {
  exists(FunctionCall lockCall, FunctionCall unlockCall |
    lockCall.getEnclosingFunction() = f and
    unlockCall.getEnclosingFunction() = f and
    lockCall.getTarget().getName().matches("%lock%") and
    unlockCall.getTarget().getName().matches("%unlock%") and
    lockCall.getLocation().getStartLine() < unlockCall.getLocation().getStartLine()
  )
}

from Function f, IfStmt statusCheck, Stmt listTraversal, Variable statusVar, Variable listVar
where
  statusCheck.getEnclosingFunction() = f and
  listTraversal.getEnclosingFunction() = f and
  
  // 识别状态检查和提前返回模式
  isStatusCheck(statusCheck, statusVar) and
  hasEarlyReturn(statusCheck) and
  
  // 识别链表遍历和资源清理
  isListTraversalAndCleanup(listTraversal, listVar) and
  hasResourceCleanup(listTraversal) and
  
  // 关键：状态检查在资源清理之前
  statusCheck.getLocation().getStartLine() < listTraversal.getLocation().getStartLine() and
  
  // 确保函数有适当的锁保护（ftrace场景）
  hasMutexProtection(f) and
  
  // 检查状态变量名称模式（类似ftrace_disabled）
  (
    statusVar.getName().matches("%disabled%") or
    statusVar.getName().matches("%enabled%") or
    statusVar.getName().matches("%active%") or
    statusVar.getName().matches("%initialized%")
  ) and
  
  // 检查链表变量名称模式
  (
    listVar.getName().matches("%_maps") or
    listVar.getName().matches("%_list") or
    listVar.getName().matches("%_entries") or
    listVar.getName().matches("%_queue")
  )

select statusCheck, 
       "潜在的UAF漏洞: 在清理链表 '" + listVar.getName() + 
       "' 之前检查状态变量 '" + statusVar.getName() + 
       "' 并可能提前返回。这可能导致模块卸载时资源未被正确释放，" +
       "应该将状态检查移动到资源清理操作之后。"