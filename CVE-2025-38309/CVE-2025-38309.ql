/**
 * @name CVE-2025-38309
 * @description Detects cases where a resource cleanup function is called in an error-handling path
 *              without the corresponding initialization function having been called. This can lead
 *              to null pointer dereferences and system crashes.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/improper-error-path-cleanup
 * @tags security
 *       correctness
 *       reliability
 *       external/cwe/cwe-476
 * @patch-commit 8cf8cde41ad01150afbd1327ad1942387787f7fd
 * @source-file drivers/gpu/drm/xe/xe_vm.c
 * @affected-function xe_vm_create
 * @kernel-config CONFIG_DRM_XE
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *      @@ -1683,10 +1683,16 @@ struct xe_vm *xe_vm_create(struct xe_device *xe, u32 flags)
 *      		xe_pm_runtime_get_noresume(xe);
 *      	}
 *      
 *      +	if (flags & XE_VM_FLAG_FAULT_MODE) {
 *      +		err = xe_svm_init(vm);
 *      +		if (err)
 *      +			goto err_no_resv;
 *      +	}
 *      +
 *      	vm_resv_obj = drm_gpuvm_resv_object_alloc(&xe->drm);
 *      	if (!vm_resv_obj) {
 *      		err = -ENOMEM;
 *      -		goto err_no_resv;
 *      +		goto err_svm_fini;
 *      	}
 *      
 *      	drm_gpuvm_init(&vm->gpuvm, "Xe VM", DRM_GPUVM_RESV_PROTECTED, &xe->drm,
 *      @@ -1757,12 +1763,6 @@ struct xe_vm *xe_vm_create(struct xe_device *xe, u32 flags)
 *      		}
 *      	}
 *      
 *      -	if (flags & XE_VM_FLAG_FAULT_MODE) {
 *      -		err = xe_svm_init(vm);
 *      -		if (err)
 *      -			goto err_close;
 *      -	}
 *      -
 *      	if (number_tiles > 1)
 *      		vm->composite_fence_ctx = dma_fence_context_alloc(1);
 *      
 *      @@ -1776,6 +1776,11 @@ err_close:
 *      	xe_vm_close_and_put(vm);
 *      	return ERR_PTR(err);
 *      
 *      +err_svm_fini:
 *      +	if (flags & XE_VM_FLAG_FAULT_MODE) {
 *      +		vm->size = 0; /* close the vm *&#47;
 *      +		xe_svm_fini(vm);
 *      +	}
 *       err_no_resv:
 *      	mutex_destroy(&vm->snap_mutex);
 *      	for_each_tile(tile, xe, id)
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38309
 * @remediation
 */

import cpp

from Function vmCreateFunc, FunctionCall allocCall, FunctionCall svmInitCall, FunctionCall closeCall
where
  // 查找xe_vm_create函数
  vmCreateFunc.getName() = "xe_vm_create" and
  
  // 查找相关的函数调用
  allocCall.getEnclosingFunction() = vmCreateFunc and
  allocCall.getTarget().getName() = "drm_gpuvm_resv_object_alloc" and
  
  svmInitCall.getEnclosingFunction() = vmCreateFunc and
  svmInitCall.getTarget().getName() = "xe_svm_init" and
  
  closeCall.getEnclosingFunction() = vmCreateFunc and
  closeCall.getTarget().getName() = "xe_vm_close_and_put" and
  
  // 漏洞模式：内存分配在SVM初始化之前
  allocCall.getLocation().getStartLine() < svmInitCall.getLocation().getStartLine() and
  
  // 确保存在FAULT_MODE相关的条件判断
//   exists(IfStmt ifStmt |
//     ifStmt.getEnclosingFunction() = vmCreateFunc and
//     ifStmt.getCondition().toString().matches("%FAULT_MODE%")
//   )
  
  // 确保存在错误处理标签和goto语句
  exists(GotoStmt gotoStmt, LabelStmt errorLabel |
    gotoStmt.getEnclosingFunction() = vmCreateFunc and
    errorLabel.getEnclosingFunction() = vmCreateFunc and
    gotoStmt.getTarget() = errorLabel and
    errorLabel.getName().matches("err%") and
    gotoStmt.getLocation().getStartLine() > allocCall.getLocation().getStartLine() and
    gotoStmt.getLocation().getStartLine() < svmInitCall.getLocation().getStartLine()
  )

select allocCall, svmInitCall, closeCall