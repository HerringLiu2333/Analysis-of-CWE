/**
 * @name CVE-2025-38489
 * @description In the s390 BPF JIT compiler, a race condition can occur during the patching of BPF calls.
 *              When `bpf_arch_text_poke()` is used to make a BPF call a no-op by setting its target to NULL,
 *              another CPU core might concurrently execute the corresponding PLT entry before the patch is complete.
 *              This can lead to the PLT's target address being set to NULL. If the other core jumps to this
 *              PLT entry, it will attempt to jump to a NULL address, causing a kernel panic. The vulnerability
 *              stems from not safely handling the `target == NULL` case during PLT setup, making the system
 *              vulnerable to a crash under specific concurrent execution scenarios.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/s390-bpf-jit-race-condition
 * @tags security
 *       correctness
 *       concurrency
 *       race-condition
 *       external/cwe/cwe-362
 *       external/cwe/cwe-476
 * @patch-commit 6a5abf8cf182f577c7ae6c62f14debc9754ec986
 * @source-file arch/s390/net/bpf_jit_comp.c
 * @affected-function bpf_jit_plt
 * @kernel-config CONFIG_BPF_JIT
 * @vulnerability-type race-condition
 * @patch-diff |
 *     @@ -566,7 +566,15 @@ static void bpf_jit_plt(struct bpf_plt *plt, void *ret, void *target)
 *      {
 *      	memcpy(plt, &bpf_plt, sizeof(*plt));
 *      	plt->ret = ret;
 *     -	plt->target = target;
 *     +	/*
 *     +	 * (target == NULL) implies that the branch to this PLT entry was
 *     +	 * patched and became a no-op. However, some CPU could have jumped
 *     +	 * to this PLT entry before patching and may be still executing it.
 *     +	 *
 *     +	 * Since the intention in this case is to make the PLT entry a no-op,
 *     +	 * make the target point to the return label instead of NULL.
 *     +	 *&#47;
 *     +	plt->target = target ?: ret;
 *      }
 *      
 *      /*
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38489
 * @patch-description |
 *     s390/bpf: Fix bpf_arch_text_poke() with new_addr == NULL again
 *     Commit 7ded842b356d ("s390/bpf: Fix bpf_plt pointer arithmetic") has
 *     accidentally removed the critical piece of commit c730fce7c70c
 *     ("s390/bpf: Fix bpf_arch_text_poke() with new_addr == NULL"), causing
 *     intermittent kernel panics in e.g. perf's on_switch() prog to reappear.
 *     
 *     Restore the fix and add a comment.
 */

import cpp

/**
 * 表示bpf_plt结构体类型
 */
class BpfPltStruct extends Struct {
  BpfPltStruct() {
    this.getName() = "bpf_plt"
  }
}

/**
 * 表示PLT条目中的target字段
 */
class PltTargetField extends Field {
  PltTargetField() {
    this.getName() = "target" and
    this.getDeclaringType() instanceof BpfPltStruct
  }
}

/**
 * 表示bpf_jit_plt函数
 */
class BpfJitPltFunction extends Function {
  BpfJitPltFunction() {
    this.getName() = "bpf_jit_plt" and
    this.getFile().getBaseName() = "bpf_jit_comp.c"
  }
}

/**
 * 表示对PLT target字段的赋值操作
 */
class PltTargetAssignment extends AssignExpr {
  PltTargetAssignment() {
    exists(FieldAccess fa |
      fa = this.getLValue() and
      fa.getTarget() instanceof PltTargetField
    )
  }
  
  /**
   * 获取赋值的右值表达式
   */
  Expr getAssignedValue() {
    result = this.getRValue()
  }
}

/**
 * 检查表达式是否可能为NULL
 */
predicate maybeNull(Expr e) {
  // 直接的NULL字面量
  e instanceof NullValue
  or
  // 变量可能为NULL（简化的启发式检查）
  exists(Variable v |
    v.getAnAccess() = e and
    (
      // 函数参数，可能从外部传入NULL
      v instanceof Parameter
      or
      // 指针类型的变量
      v.getType() instanceof PointerType
    )
  )
}

/**
 * 检查是否存在NULL检查保护
 */
predicate hasNullCheck(PltTargetAssignment assignment, Expr checkedExpr) {
  exists(IfStmt ifStmt, Expr condition |
    // 赋值操作在if语句内部
    ifStmt.getThen().getAChild*() = assignment and
    condition = ifStmt.getCondition() and
    (
      // 直接的NULL检查: if (target != NULL)
      exists(NEExpr neq |
        neq = condition and
        neq.getAnOperand() = checkedExpr and
        neq.getAnOperand() instanceof NullValue
      )
      or
      // 简单的真值检查: if (target)
      condition = checkedExpr
      or
      // 逻辑非的NULL检查: if (!target) ... else
      exists(NotExpr notExpr |
        notExpr = condition and
        notExpr.getOperand() = checkedExpr and
        ifStmt.getElse().getAChild*() = assignment
      )
    )
  )
}

/**
 * 检查是否使用了三元运算符进行NULL安全处理
 */
predicate hasTernaryNullHandling(PltTargetAssignment assignment) {
  exists(ConditionalExpr ternary |
    ternary = assignment.getAssignedValue() and
    (
      // target ?: ret 形式
      exists(Expr condition, Expr elseExpr |
        condition = ternary.getCondition() and
        elseExpr = ternary.getElse() and
        // 条件是某个可能为NULL的表达式
        maybeNull(condition) and
        // else分支不是NULL
        not elseExpr instanceof NullValue
      )
      or
      // target != NULL ? target : ret 形式
      exists(NEExpr neq, Expr thenExpr, Expr elseExpr |
        neq = ternary.getCondition() and
        thenExpr = ternary.getThen() and
        elseExpr = ternary.getElse() and
        neq.getAnOperand() instanceof NullValue and
        not elseExpr instanceof NullValue
      )
    )
  )
}

from PltTargetAssignment assignment, Expr assignedValue
where
  // 赋值发生在bpf_jit_plt函数中
  assignment.getEnclosingFunction() instanceof BpfJitPltFunction and
  assignedValue = assignment.getAssignedValue() and
  // 被赋值的表达式可能为NULL
  maybeNull(assignedValue) and
  // 没有适当的NULL检查保护
  not hasNullCheck(assignment, assignedValue) and
  // 没有使用三元运算符进行NULL安全处理
  not hasTernaryNullHandling(assignment) and
  // 排除已经使用安全模式的直接赋值（如 target ?: ret）
  not exists(ConditionalExpr ternary |
    ternary = assignedValue and
    ternary.getCondition() = assignedValue
  )
select assignment,
  "在s390 BPF JIT中，PLT target字段的直接赋值可能导致竞态条件。当target参数为NULL时，" +
  "应使用安全的赋值方式（如 'target ?: ret'）以避免NULL指针跳转导致的内核崩溃。" +
  "这个问题可能在多CPU并发环境下，当一个CPU正在修补代码而另一个CPU尝试执行PLT跳转时发生。"