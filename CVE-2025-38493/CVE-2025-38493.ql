/**
 * @name CVE-2025-38493
 * @description Detects an unsafe memory copy operation where the destination buffer's size field is initialized after the copy operation. When FORTIFY_SOURCE is enabled, this leads to a buffer overflow check against an uninitialized garbage value, potentially causing a kernel panic.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/uninitialized-size-field-for-memcpy
 * @tags security
 *       correctness
 *       uninitialized-variable
 *       denial-of-service
 *       external/cwe/cwe-457
 * @patch-commit 85a3bce695b361d85fc528e6fbb33e4c8089c806
 * @source-file kernel/trace/trace_osnoise.c
 * @affected-function __timerlat_dump_stack
 * @kernel-config CONFIG_TRACER_OSNOISE
 * @kernel-config CONFIG_TIMERLAT_TRACER
 * @vulnerability-type use-of-uninitialized-variable
 * @patch-diff |
 *      @@ -637,8 +637,8 @@ __timerlat_dump_stack(struct trace_buffer *buffer, struct trace_stack *fstack, u
 *       
 *       	entry = ring_buffer_event_data(event);
 *       
 *      -	memcpy(&entry->caller, fstack->calls, size);
 *       	entry->size = fstack->nr_entries;
 *      +	memcpy(&entry->caller, fstack->calls, size);
 *       
 *       	trace_buffer_unlock_commit_nostack(buffer, event);
 *       }
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38493
 * @remediation 
 * @patch-description |
 *     tracing/osnoise: Fix crash in timerlat_dump_stack()
 *     We have observed kernel panics when using timerlat with stack saving,
 *     with the following dmesg output:
 *     
 *     memcpy: detected buffer overflow: 88 byte write of buffer size 0
 *     WARNING: CPU: 2 PID: 8153 at lib/string_helpers.c:1032 __fortify_report+0x55/0xa0
 *     CPU: 2 UID: 0 PID: 8153 Comm: timerlatu/2 Kdump: loaded Not tainted 6.15.3-200.fc42.x86_64 #1 PREEMPT(lazy)
 *     Call Trace:
 *      <TASK>
 *      ? trace_buffer_lock_reserve+0x2a/0x60
 *      __fortify_panic+0xd/0xf
 *      __timerlat_dump_stack.cold+0xd/0xd
 *      timerlat_dump_stack.part.0+0x47/0x80
 *      timerlat_fd_read+0x36d/0x390
 *      vfs_read+0xe2/0x390
 *      ? syscall_exit_to_user_mode+0x1d5/0x210
 *      ksys_read+0x73/0xe0
 *      do_syscall_64+0x7b/0x160
 *      ? exc_page_fault+0x7e/0x1a0
 *      entry_SYSCALL_64_after_hwframe+0x76/0x7e
 *     
 *     __timerlat_dump_stack() constructs the ftrace stack entry like this:
 *     
 *     struct stack_entry *entry;
 *     ...
 *     memcpy(&entry->caller, fstack->calls, size);
 *     entry->size = fstack->nr_entries;
 *     
 *     Since commit e7186af7fb26 ("tracing: Add back FORTIFY_SOURCE logic to
 *     kernel_stack event structure"), struct stack_entry marks its caller
 *     field with __counted_by(size). At the time of the memcpy, entry->size
 *     contains garbage from the ringbuffer, which under some circumstances is
 *     zero, triggering a kernel panic by buffer overflow.
 *     
 *     Populate the size field before the memcpy so that the out-of-bounds
 *     check knows the correct size. This is analogous to
 *     __ftrace_trace_stack().
 */

import cpp

/**
 * 表示对结构体成员的memcpy操作
 */
class MemcpyCall extends FunctionCall {
  MemcpyCall() {
    this.getTarget().getName() = "memcpy"
  }
}

/**
 * 表示对size字段的赋值操作
 */
class SizeFieldAssignment extends AssignExpr {
  SizeFieldAssignment() {
    exists(FieldAccess fa |
      fa = this.getLValue() and
      fa.getTarget().getName() = "size"
    )
  }
}

from MemcpyCall memcpy, SizeFieldAssignment sizeAssign
where
  // 1. 两个操作在同一个函数中
  memcpy.getEnclosingFunction() = sizeAssign.getEnclosingFunction() and
  
  // 2. memcpy在size字段赋值之前执行（根据行号判断）
  memcpy.getLocation().getStartLine() < sizeAssign.getLocation().getStartLine()

select memcpy, 
       "memcpy操作在 $@ 之前执行，可能导致FORTIFY_SOURCE机制基于未初始化的size字段进行错误的边界检查。建议先设置size字段再进行内存拷贝。",
       sizeAssign, "size字段赋值"