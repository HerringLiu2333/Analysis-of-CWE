/**
 * @name CVE-2025-38493
 * @description Detects an unsafe memory copy operation where the destination buffer's size field is initialized after the copy operation. When FORTIFY_SOURCE is enabled, this leads to a buffer overflow check against an uninitialized garbage value, potentially causing a kernel panic.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/uninitialized-size-field-for-memcpy
 * @tags security
 *       correctness
 *       uninitialized-variable
 *       denial-of-service
 *       external/cwe/cwe-457
 * @patch-commit 85a3bce695b361d85fc528e6fbb33e4c8089c806
 * @source-file kernel/trace/trace_osnoise.c
 * @affected-function __timerlat_dump_stack
 * @kernel-config CONFIG_TRACER_OSNOISE
 * @kernel-config CONFIG_TIMERLAT_TRACER
 * @vulnerability-type use-of-uninitialized-variable
 * @patch-diff |
 *      @@ -637,8 +637,8 @@ __timerlat_dump_stack(struct trace_buffer *buffer, struct trace_stack *fstack, u
 *       
 *       	entry = ring_buffer_event_data(event);
 *       
 *      -	memcpy(&entry->caller, fstack->calls, size);
 *       	entry->size = fstack->nr_entries;
 *      +	memcpy(&entry->caller, fstack->calls, size);
 *       
 *       	trace_buffer_unlock_commit_nostack(buffer, event);
 *       }
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38493
 * @remediation 
 */

import cpp

/**
 * 表示对结构体成员的memcpy操作
 */
class MemcpyCall extends FunctionCall {
  MemcpyCall() {
    this.getTarget().getName() = "memcpy"
  }
}

/**
 * 表示对size字段的赋值操作
 */
class SizeFieldAssignment extends AssignExpr {
  SizeFieldAssignment() {
    exists(FieldAccess fa |
      fa = this.getLValue() and
      fa.getTarget().getName() = "size"
    )
  }
}

from MemcpyCall memcpy, SizeFieldAssignment sizeAssign
where
  // 1. 两个操作在同一个函数中
  memcpy.getEnclosingFunction() = sizeAssign.getEnclosingFunction() and
  
  // 2. memcpy在size字段赋值之前执行（根据行号判断）
  memcpy.getLocation().getStartLine() < sizeAssign.getLocation().getStartLine()

select memcpy, 
       "memcpy操作在 $@ 之前执行，可能导致FORTIFY_SOURCE机制基于未初始化的size字段进行错误的边界检查。建议先设置size字段再进行内存拷贝。",
       sizeAssign, "size字段赋值"