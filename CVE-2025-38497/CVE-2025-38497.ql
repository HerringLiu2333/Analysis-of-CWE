/**
 * @name CVE-2025-38497
 * @description Detects an out-of-bounds read vulnerability in the configfs USB gadget driver when handling empty string writes.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/usb-gadget-configfs-oob-read
 * @tags security
 *       correctness
 *       denial-of-service
 *       external&#47;cwe&#47;cwe-125
 * @patch-commit 3014168731b7930300aab656085af784edc861f6
 * @source-file drivers/usb/gadget/configfs.c
 * @affected-function os_desc_qw_sign_store
 * @affected-function webusb_landingPage_store
 * @kernel-config CONFIG_USB_CONFIGFS
 * @vulnerability-type out-of-bounds-read
 * @patch-diff |
 *     @@ -1065,6 +1065,8 @@ static ssize_t webusb_landingPage_store(struct config_item *item, const char *pa
 *  	unsigned int bytes_to_strip = 0;
 *  	int l = len;
 *
 * +	if (!len)
 * +		return len;
 *  	if (page[l - 1] == '\n') {
 *  		--l;
 *  		++bytes_to_strip;
 *     @@ -1188,6 +1190,8 @@ static ssize_t os_desc_qw_sign_store(struct config_item *item, const char *page,
 *  	struct gadget_info *gi = os_desc_item_to_gadget_info(item);
 *  	int res, l;
 *
 * +	if (!len)
 * +		return len;
 *  	l = min_t(int, len, OS_STRING_QW_SIGN_LEN >> 1);
 *  	if (page[l - 1] == '\n')
 *  		--l;
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38497
 * @patch-description |
 *     usb: gadget: configfs: Fix OOB read on empty string write
 *     When writing an an empty string to either 'qw_sign' or 'landingPage'
 *     sysfs attributes, the store functions attempt to access page[l - 1]
 *     before validating that the length 'l' is greater than zero.
 *     
 *     This patch fixes the vulnerability by adding a check at the beginning
 *     of os_desc_qw_sign_store() and webusb_landingPage_store() to handle
 *     the zero-length input case gracefully by returning immediately.
 */

import cpp

class VulnerableStoreFunction extends Function {
	VulnerableStoreFunction() {
		(this.getName() = "os_desc_qw_sign_store" or this.getName() = "webusb_landingPage_store")
		and this.getFile().getRelativePath().matches("%drivers/usb/gadget/configfs.c")
	}
}

// 检查是否存在未检查len为0就访问page[l-1]的代码
from VulnerableStoreFunction f, Parameter len, LocalVariable l, Parameter page, ArrayExpr indexAccess
where
	// 查找len和l变量
	len = f.getAParameter() and len.getName() = "len" and
	l.getName() = "l" and l.getFunction() = f and
	page = f.getAParameter() and page.getName() = "page" and
	// 查找page[l-1]的访问 - 查找数组访问表达式
	indexAccess.getArrayBase() = page.getAnAccess() and
	exists(SubExpr sub | 
		sub = indexAccess.getArrayOffset() and
		sub.getLeftOperand() = l.getAnAccess() and
		sub.getRightOperand().getValue() = "1"
	) and
	indexAccess.getEnclosingFunction() = f and
	// 检查是否在访问前没有if (!len) return len;的保护
	not exists(IfStmt ifs | 
		exists(UnaryLogicalOperation unary |
			unary = ifs.getCondition() and
			unary.getOperator() = "!" and
			unary.getOperand() = len.getAnAccess()
		) and 
		ifs.getEnclosingFunction() = f and
		ifs.getLocation().getStartLine() < indexAccess.getLocation().getStartLine()
	)
select f, indexAccess, "可能存在未检查len为0就访问page[l-1]的越界读取漏洞。"
