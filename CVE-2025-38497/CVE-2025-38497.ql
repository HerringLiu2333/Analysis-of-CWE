/**
 * 查询drivers/usb/gadget/configfs.c文件中，os_desc_qw_sign_store和webusb_landingPage_store函数是否存在越界读取漏洞。
 * 漏洞场景：未检查len为0就访问page[l-1]，导致page[-1]越界读取。
 * 修复方式：补丁添加了if (!len) return len;，防止越界。
 */
import cpp

class VulnerableStoreFunction extends Function {
	VulnerableStoreFunction() {
		(this.getName() = "os_desc_qw_sign_store" or this.getName() = "webusb_landingPage_store")
		and this.getFile().getRelativePath().matches("%drivers/usb/gadget/configfs.c")
	}
}

// 检查是否存在未检查len为0就访问page[l-1]的代码
from VulnerableStoreFunction f, Parameter len, LocalVariable l, Parameter page, ArrayExpr indexAccess
where
	// 查找len和l变量
	len = f.getAParameter() and len.getName() = "len" and
	l.getName() = "l" and l.getFunction() = f and
	page = f.getAParameter() and page.getName() = "page" and
	// 查找page[l-1]的访问 - 查找数组访问表达式
	indexAccess.getArrayBase() = page.getAnAccess() and
	exists(SubExpr sub | 
		sub = indexAccess.getArrayOffset() and
		sub.getLeftOperand() = l.getAnAccess() and
		sub.getRightOperand().getValue() = "1"
	) and
	indexAccess.getEnclosingFunction() = f and
	// 检查是否在访问前没有if (!len) return len;的保护
	not exists(IfStmt ifs | 
		exists(UnaryLogicalOperation unary |
			unary = ifs.getCondition() and
			unary.getOperator() = "!" and
			unary.getOperand() = len.getAnAccess()
		) and 
		ifs.getEnclosingFunction() = f and
		ifs.getLocation().getStartLine() < indexAccess.getLocation().getStartLine()
	)
select f, indexAccess, "可能存在未检查len为0就访问page[l-1]的越界读取漏洞。"
