/**
 * @name CVE-2025-38495
 * @description In the Linux kernel's HID core, the hid_alloc_report_buf function fails to account for an extra byte required for the report ID when the ID is 0. This leads to the allocation of a buffer that is one byte too small. Subsequent operations that rely on a specific buffer size can write past the allocated boundary, causing a heap-based buffer overflow.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/insufficient-hid-report-buffer
 * @tags security
 *       correctness
 *       memory
 *       external/cwe/cwe-131
 *       external/cwe/cwe-120
 * @patch-commit 4f15ee98304b96e164ff2340e1dfd6181c3f42aa
 * @source-file drivers/hid/hid-core.c
 * @affected-function hid_alloc_report_buf
 * @kernel-config CONFIG_HID
 * @vulnerability-type buffer-overflow
 * @patch-diff |
 *     @@ -1883,9 +1883,12 @@ u8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags)
 *      	/*
 *      	 * 7 extra bytes are necessary to achieve proper functionality
 *      	 * of implement() working on 8 byte chunks
 * +	 * 1 extra byte for the report ID if it is null (not used) so
 * +	 * we can reserve that extra byte in the first position of the buffer
 * +	 * when sending it to .raw_request()
 *      	 *&#47;
 *      
 * -	u32 len = hid_report_len(report) + 7;
 * +	u32 len = hid_report_len(report) + 7 + (report->id == 0);
 *      
 *      	return kzalloc(len, flags);
 *      }
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38495
 * @remediation 
 */

import cpp

/**
 * 表示对hid_report_len函数的调用
 */
class HidReportLenCall extends FunctionCall {
  HidReportLenCall() {
    this.getTarget().getName() = "hid_report_len"
  }
}

/**
 * 表示访问report->id字段的表达式
 */
class ReportIdAccess extends FieldAccess {
  ReportIdAccess() {
    this.getTarget().getName() = "id"
  }
}

/**
 * 检测变量声明赋值语句中缺少report->id == 0条件的情况
 */
predicate isVulnerableVariableDeclaration(Variable lenVar, HidReportLenCall reportLenCall, Literal constant) {
  // 变量是u32类型且名称包含"len"
  lenVar.getType().getName() = "u32" and
  lenVar.getName().toLowerCase().matches("%len%") and
  
  // 变量的初始化表达式是加法运算
  exists(AddExpr addExpr |
    addExpr = lenVar.getInitializer().getExpr() and
    
    // 加法的一个操作数是hid_report_len调用
    addExpr.getAnOperand() = reportLenCall and
    
    // 加法的另一个操作数是常数7
    addExpr.getAnOperand() = constant and
    constant.getValue() = "7"
  ) and
  
  // 确认在同一函数中没有检查report->id == 0的条件
  not exists(EqualityOperation eqOp, ReportIdAccess idAccess |
    eqOp.getAnOperand() = idAccess and
    eqOp.getAnOperand().getValue() = "0"
  )
}

/**
 * 检测赋值语句中缺少report->id == 0条件的情况
 */
predicate isVulnerableAssignment(AssignExpr assignExpr, HidReportLenCall reportLenCall, Literal constant) {
  // 赋值表达式的右侧是加法运算
  exists(AddExpr addExpr |
    addExpr = assignExpr.getRValue() and
    
    // 加法的一个操作数是hid_report_len调用
    addExpr.getAnOperand() = reportLenCall and
    
    // 加法的另一个操作数是常数7
    addExpr.getAnOperand() = constant and
    constant.getValue() = "7"
  ) and
  
  // 左侧变量名包含"len"
  exists(Variable v |
    assignExpr.getLValue() = v.getAnAccess() and
    v.getName().toLowerCase().matches("%len%")
  ) and
  
  // 确认在同一函数中没有检查report->id == 0的条件
  not exists(EqualityOperation eqOp, ReportIdAccess idAccess |
    eqOp.getEnclosingFunction() = assignExpr.getEnclosingFunction() and
    eqOp.getAnOperand() = idAccess and
    eqOp.getAnOperand().getValue() = "0"
  )
}

from Expr vulnerableExpr, HidReportLenCall reportLenCall, Literal constant, string message
where 
  (
    // 检测变量声明中的漏洞
    exists(Variable lenVar |
      isVulnerableVariableDeclaration(lenVar, reportLenCall, constant) and
      vulnerableExpr = lenVar.getInitializer().getExpr() and
      message = "变量 '" + lenVar.getName() + "' 的初始化表达式 'hid_report_len(report) + 7' 缺少对 '(report->id == 0)' 条件的处理，可能导致当报告ID为0时缓冲区分配不足一个字节。"
    )
    or
    // 检测赋值表达式中的漏洞  
    (
      isVulnerableAssignment(vulnerableExpr, reportLenCall, constant) and
      message = "赋值表达式 'hid_report_len(report) + 7' 缺少对 '(report->id == 0)' 条件的处理，可能导致当报告ID为0时缓冲区分配不足一个字节。"
    )
  )
select vulnerableExpr, message