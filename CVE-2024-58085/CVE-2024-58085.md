```markdown
### **## 根因描述**

此问题的根本原因在于 tomoyo_write_control() 对输入行长度缺乏上限与约束，导致在用户向控制接口连续写入极长且无换行的字符串时，缓冲区按倍数扩容并触发大块内存分配尝试；旧实现使用普通 GFP 标志进行 kzalloc，当申请尺寸过大而失败时，内存分配器会打印“过大分配”告警，造成噪声并被 syzbot 报警。

1. **被修改的代码:**
    ```c
    @@ -2665,7 +2665,7 @@ ssize_t tomoyo_write_control(struct tomoyo_io_buffer *head,
     
             if (head->w.avail >= head->writebuf_size - 1) {
                 const int len = head->writebuf_size * 2;
    -            char *cp = kzalloc(len, GFP_NOFS);
    +            char *cp = kzalloc(len, GFP_NOFS | __GFP_NOWARN);
     
                 if (!cp) {
                     error = -ENOMEM;
    ```
    *   **修改原因:** 抑制在极端长输入导致的大块内存分配失败时的分配器告警，避免无意义的告警噪声；实际有效控制行通常远小于 32KB，超过该规模时直接以 -ENOMEM 失败更为合理，无需再区分超过 32KB 与超过 KMALLOC_MAX_SIZE 的不同返回路径。

        *   **旧代码的缺陷:**
            1. 未对输入行长度设置合理上限，导致缓冲按倍数扩容并尝试超大分配。
            2. 使用 kzalloc(len, GFP_NOFS) 在超大分配失败时触发内存分配器“过大分配”告警，造成日志噪声（被 syzbot 报告）。
            3. 逻辑上区分“超过 32KB”与“超过 KMALLOC_MAX_SIZE”并无实际必要，复杂化错误处理（根据提交说明）。

        *   **新代码的修复:**
            1. 在扩容分配时添加 __GFP_NOWARN 标志，失败时不再打印分配器告警。
            2. 对于过长输入导致的扩容失败，统一返回 -ENOMEM，避免无谓的 -EINVAL 区分与告警噪声。
            3. 保持现有功能语义不变，仅优化异常路径的稳健性与日志洁净度。

### **## 总结**

*   **漏洞类型:** 内存分配错误处理/日志噪声问题（鲁棒性问题）
*   **根本缺陷:** 对异常长输入缺乏上限控制且使用默认分配标志，导致超大分配失败时产生无谓告警
*   **修复原理:** 在可能发生超大分配的扩容路径上使用 __GFP_NOWARN 抑制告警，并统一以 -ENOMEM 处理失败，避免区分不必要的错误类别与告警噪声
```