/**
 * @name CVE-2024-58093
 * @description PCIe ASPM parent link state was freed at the wrong time during device removal.
 *              Freeing on any function removal could tear down a link state still used as a
 *              parent for downstream ports (e.g., switch upstream port), leading to GPF/UAF.
 *              The fix only frees the parent link state when function 0 (link->downstream) is
 *              being removed; for non-zero functions, it skips freeing and exits early.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/pci-aspm-parent-link-free-timing
 * @tags
 *       correctness
 *       reliability
 *       pci
 *       pcie
 *       aspm
 *       use-after-free
 *       hotplug
 * @patch-commit cbf937dcadfd571a434f8074d057b32cd14fbea5
 * @source-file drivers/pci/pcie/aspm.c
 * @affected-function pcie_aspm_exit_link_state
 * @vulnerability-type use-after-free
 * @patch-diff |
 *     diff --git a/drivers/pci/pcie/aspm.c b/drivers/pci/pcie/aspm.c
 *     index e0bc90597dcadf..25954cc89bf342 100644
 *     --- a/drivers/pci/pcie/aspm.c
 *     +++ b/drivers/pci/pcie/aspm.c
 *     @@ -1273,16 +1273,16 @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)
 *      	parent_link = link->parent;
 *      
 *      	/*
 *     -	 * link->downstream is a pointer to the pci_dev of function 0.  If
 *     -	 * we remove that function, the pci_dev is about to be deallocated,
 *     -	 * so we can't use link->downstream again.  Free the link state to
 *     -	 * avoid this.
 *     +	 * Free the parent link state, no later than function 0 (i.e.
 *     +	 * link->downstream) being removed.
 *      	 *
 *     -	 * If we're removing a non-0 function, it's possible we could
 *     -	 * retain the link state, but PCIe r6.0, sec 7.5.3.7, recommends
 *     -	 * programming the same ASPM Control value for all functions of
 *     -	 * multi-function devices, so disable ASPM for all of them.
 *     +	 * Do not free the link state any earlier. If function 0 is a
 *     +	 * switch upstream port, this link state is parent_link to all
 *     +	 * subordinate ones.
 *      	 &#47;
 *     +	if (pdev != link->downstream)
 *     +		goto out;
 *      	pcie_config_aspm_link(link, 0);
 *      	list_del(&link->sibling);
 *      	free_link_state(link);
 *     @@ -1293,6 +1293,7 @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)
 *      		pcie_config_aspm_path(parent_link);
 *      	}
 *      
 *     + out:
 *      	mutex_unlock(&aspm_lock);
 *      	up_read(&pci_bus_sem);
 *      }
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cbf937dcadfd571a434f8074d057b32cd14fbea5
 * @remediation Only tear down the ASPM parent link state when function 0 (link->downstream)
 *              is being removed. For non-zero functions, skip freeing and exit early to avoid
 *              invalidating a link state still referenced by subordinate links (common on
 *              switch upstream ports), preventing GPF/use-after-free during hot-unplug.
 * @patch-description |
 *  PCI/ASPM: Fix link state exit during switch upstream function removal
 *  Before 456d8aa37d0f ("PCI/ASPM: Disable ASPM on MFD function removal to
 *  avoid use-after-free"), we would free the ASPM link only after the last
 *  function on the bus pertaining to the given link was removed.
 *  
 *  That was too late. If function 0 is removed before sibling function,
 *  link->downstream would point to free'd memory after.
 *  
 *  After above change, we freed the ASPM parent link state upon any function
 *  removal on the bus pertaining to a given link.
 *  
 *  That is too early. If the link is to a PCIe switch with MFD on the upstream
 *  port, then removing functions other than 0 first would free a link which
 *  still remains parent_link to the remaining downstream ports.
 *
 *  The resulting GPFs are especially frequent during hot-unplug, because
 *  pciehp removes devices on the link bus in reverse order.
 *
 *  On that switch, function 0 is the virtual P2P bridge to the internal bus.
 *  Free exactly when function 0 is removed -- before the parent link is
 *  obsolete, but after all subordinate links are gone.
 *
 *  Link: https://lore.kernel.org/r/e12898835f25234561c9d7de4435590d957b85d9.1734924854.git.dns@arista.com
 *  Fixes: 456d8aa37d0f ("PCI/ASPM: Disable ASPM on MFD function removal to avoid use-after-free")
 */

import cpp

/*
 * 检测PCI ASPM中的链接状态退出问题
 * 该查询用于识别在pcie_aspm_exit_link_state函数中未正确处理函数0移除的情况
 * 这可能导致在移除多功能设备时过早释放父链接状态，造成GPF错误
 * This query identifies issues in pcie_aspm_exit_link_state function where
 * function 0 removal is not handled properly, may cause premature parent link state freeing
 */

// 检查是否为pcie_aspm_exit_link_state函数
// Check if it's pcie_aspm_exit_link_state function
predicate isPcieAspmExitLinkStateFunction(Function f) {
  f.getName() = "pcie_aspm_exit_link_state"
}

// 检查是否为函数0检查
// Check for function 0 check
predicate hasFunction0Check(Function f) {
  exists(IfStmt ifStmt |
    ifStmt.getEnclosingFunction() = f and
    ifStmt.getCondition().toString().matches("%pdev != link->downstream%") and
    ifStmt.getThen().toString().matches("%goto out%")
  )
}

// 检查是否有过早的链接状态释放
// Check for premature link state freeing
predicate hasPrematureLinkStateFreeing(Function f) {
  exists(FunctionCall freeCall |
    freeCall.getEnclosingFunction() = f and
    freeCall.getTarget().getName() = "free_link_state" and
    not exists(IfStmt ifStmt |
      ifStmt.getEnclosingFunction() = f and
      ifStmt.getCondition().toString().matches("%pdev != link->downstream%") and
      ifStmt.getLocation().getStartLine() < freeCall.getLocation().getStartLine()
    )
  )
}

from
  Function f
where
  // 限制在pcie_aspm_exit_link_state函数内
  isPcieAspmExitLinkStateFunction(f) and
  // 没有函数0检查或者有过早的链接状态释放
  (not hasFunction0Check(f) or hasPrematureLinkStateFreeing(f))
select
  f,
  "Potential stability issue: Missing or incorrect function 0 check in pcie_aspm_exit_link_state(), may cause premature parent link state freeing and GPF errors"