/**
 * @name CVE-2025-38251
 * @description Detects a NULL pointer dereference in the clip_push function where a pointer
 *              is used before it is checked for nullness. This occurs due to an incorrect
 *              order of validation checks, leading to a system crash (DoS).
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/cve-2025-38251-improper-null-check-order
 * @tags security
 *       correctness
 *       denial-of-service
 *       external/cwe/cwe-476
 * @patch-commit b993ea46b3b601915ceaaf3c802adf11e7d6bac6
 * @source-file net/atm/clip.c
 * @affected-function clip_push
 * @kernel-config CONFIG_ATM_CLIP
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *     @@ -193,12 +193,6 @@ static void clip_push(struct atm_vcc *vcc, struct sk_buff *skb)
 *      
 *      	pr_debug("\n");
 *      
 *     -	if (!clip_devs) {
 *     -		atm_return(vcc, skb->truesize);
 *     -		kfree_skb(skb);
 *     -		return;
 *     -	}
 *     -
 *      	if (!skb) {
 *      		pr_debug("removing VCC %p\n", clip_vcc);
 *      		if (clip_vcc->entry)
 *     @@ -208,6 +202,11 @@ static void clip_push(struct atm_vcc *vcc, struct sk_buff *skb)
 *      		return;
 *      	}
 *      	atm_return(vcc, skb->truesize);
 *     +	if (!clip_devs) {
 *     +		kfree_skb(skb);
 *     +		return;
 *     +	}
 *     +
 *      	skb->dev = clip_vcc->entry ? clip_vcc->entry->neigh->dev : clip_devs;
 *      	if (!skb->dev) {
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38251
 * @remediation 
 */
import cpp
import semmle.code.cpp.controlflow.ControlFlowGraph
import semmle.code.cpp.controlflow.Guards

/** 是否是一个针对参数的 NULL 检查条件 */
predicate isNullCheckOn(Parameter p, GuardCondition gc) {
  gc.getEnclosingFunction() = p.getFunction() and
  gc.ensuresEq(p.getAnAccess(), 0, _, true)
}

/** 参数是否在其所在函数中出现过任何 NULL 检查 */
predicate hasAnyNullCheck(Parameter p) { exists(GuardCondition gc | isNullCheckOn(p, gc)) }

/** 近似支配：NULL 检查基本块可达使用基本块 */
predicate dominatedBySomeNullCheck(Expr e, Parameter p) {
  exists(GuardCondition gc |
    isNullCheckOn(p, gc) and
    gc.getBasicBlock().getASuccessor*() = e.getBasicBlock()
  )
}

/** 使用不被任何 NULL 检查支配（存在检查但不在其可达前驱路径上） */
predicate unsafeUse(Expr e, Parameter p) { hasAnyNullCheck(p) and not dominatedBySomeNullCheck(e, p) }

// 使用形态
predicate isFieldAccessUse(Expr e, Parameter p) { 
    e instanceof PointerFieldAccess and 
    e.(PointerFieldAccess).getQualifier().(VariableAccess).getTarget() = p 
}
predicate isCallQualifierUse(Expr e, Parameter p) { 
    e instanceof FunctionCall and 
    e.(FunctionCall).getQualifier().(VariableAccess).getTarget() = p 
}
predicate isArrayIndexUse(Expr e, Parameter p) { 
    e instanceof ArrayExpr and 
    e.(ArrayExpr).getArrayBase().(VariableAccess).getTarget() = p 
}

from Function func, Parameter param, Expr use, string useType
where
  param = func.getAParameter() and param.getType() instanceof PointerType and
  use.getEnclosingFunction() = func and
  (
    (isFieldAccessUse(use, param) and useType = "field access") or
    (isCallQualifierUse(use, param) and useType = "function call") or
    (isArrayIndexUse(use, param) and useType = "array access")
  ) and
  unsafeUse(use, param) and
  not use.getParent*() instanceof ConditionalExpr and
  not use.getParent*() instanceof SizeofExprOperator
select use,
  "Potential NULL pointer dereference: parameter '$@' is used via $@ on a path not dominated by any existing NULL check in function '$@'.",
  param, param.getName(), use, useType, func, func.getName()