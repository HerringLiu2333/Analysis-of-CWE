/**
 * @name CVE-2024-57981
 * @description Detects potential NULL pointer dereference in xhci_handle_stopped_cmd_ring()
 *  when handling aborted commands: xhci_mod_cmd_timer() may be called with
 *  cur_cmd == NULL if the ring appears non-empty but no current command exists.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/unchecked-null-call
 * @tags 
 *  security
 *  correctness
 *  reliability
 *  null-dereference
 *  external/cwe/cwe-476
 * @patch-commit fd8bfaeba4a85b14427899adec0efb3954300653
 * @source-file drivers/usb/host/xhci-ring.c
 * @affected-function xhci_handle_stopped_cmd_ring
 * @kernel-config N/A
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *  diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
 *  index a37b55b2e31f47…08b016864fc088 100644
 *  --- a/drivers/usb/host/xhci-ring.c
 *  +++ b/drivers/usb/host/xhci-ring.c
 *  @@ -332,7 +332,8 @@ static void xhci_handle_stopped_cmd_ring(struct xhci_hcd *xhci,
 *  if ((xhci->cmd_ring->dequeue != xhci->cmd_ring->enqueue) &&
 *  !(xhci->xhc_state & XHCI_STATE_DYING)) {
 *    xhci->current_cmd = cur_cmd;
 *  - xhci_mod_cmd_timer(xhci);
 *  + if (cur_cmd)
 *  + xhci_mod_cmd_timer(xhci);
 *  xhci_ring_cmd_db(xhci);
 *  }
 *  }
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=fd8bfaeba4a85b14427899adec0efb3954300653
 * @remediation Guard calls which rely on possibly NULL pointers (e.g., cur_cmd) with explicit
 *  NULL checks before use; only arm timers and ring doorbells when a valid current
 *  command is present to prevent NULL dereference on abort paths.
 * @patch-description |
 *  usb: xhci: Fix NULL pointer dereference on certain command aborts
 *  [ Upstream commit 1e0a19912adb68a4b2b74fd77001c96cd83eb073 ]
 *  
 *  If a command is queued to the final usable TRB of a ring segment, the
 *  enqueue pointer is advanced to the subsequent link TRB and no further.
 *  If the command is later aborted, when the abort completion is handled
 *  the dequeue pointer is advanced to the first TRB of the next segment.
 *
 *  If no further commands are queued, xhci_handle_stopped_cmd_ring() sees
 *  the ring pointers unequal and assumes that there is a pending command,
 *  so it calls xhci_mod_cmd_timer() which crashes if cur_cmd was NULL.
 *  
 *  Don't attempt timer setup if cur_cmd is NULL. The subsequent doorbell
 *  ring likely is unnecessary too, but it's harmless. Leave it alone.
 * 
 *  This is probably Bug 219532, but no confirmation has been received.
 *
 *  The issue has been independently reproduced and confirmed fixed using
 *  a USB MCU programmed to NAK the Status stage of SET_ADDRESS forever.
 *  Everything continued working normally after several prevented crashes.
 *  
 *  Link: https://bugzilla.kernel.org/show_bug.cgi?id=219532
 *  Fixes: c311e391a7ef ("xhci: rework command timeout and cancellation,")
 */




import cpp

// 查找可能包含NULL指针检查的函数
predicate isNullCheckFunction(FunctionCall fc) {
  fc.getTarget().getName() = "xhci_mod_cmd_timer" 
}

// 查找指针变量可能为NULL的赋值
predicate mayBeNullPointer(AssignExpr assign) {
  assign.getRValue().getType().toString().matches("%*%") and
  assign.getRValue().toString().matches("cur_cmd") and
  assign.getLValue().toString().matches("current_cmd")
}


from
  FunctionCall dangerousCall, AssignExpr assign
where
  isNullCheckFunction(dangerousCall) and
  mayBeNullPointer(assign) and
  dangerousCall.getEnclosingFunction() = assign.getEnclosingFunction() and
  not exists(IfStmt ifStmt |
      ifStmt.getCondition().toString().matches("%" + assign.getRValue().toString() + "%") and
      ifStmt.getLocation().getStartLine() > assign.getLocation().getStartLine() and
      ifStmt.getLocation().getStartLine() < dangerousCall.getLocation().getStartLine()
  )
select
  dangerousCall,
  "Potential NULL pointer dereference: " + dangerousCall.getTarget().getName() +
  " called without NULL check at line " + dangerousCall.getLocation().getStartLine() +
  ". Variable '" + dangerousCall.getArgument(0).toString() + "' may be NULL.",
  dangerousCall.getEnclosingFunction(),
  "Function: " + dangerousCall.getEnclosingFunction().getName()