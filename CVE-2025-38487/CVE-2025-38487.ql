/**
 * @name 缺少状态检查导致对未初始化资源进行释放
 * @description 检测在释放或反初始化资源前缺少状态检查，可能导致对未初始化资源的非法操作
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/uninitialized-resource-deallocation
 * @tags security
 *       reliability
 *       external/cwe/cwe-824
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow
import semmle.code.cpp.controlflow.ControlFlowGraph

/**
 * 数据流配置：跟踪状态字段到资源释放函数的数据流
 */
module StateCheckDataFlowConfig implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    exists(FieldAccess fa |
      fa = source.asExpr() and
      fa.getTarget().getName().regexpMatch(".*(?i)(enable|init|valid|active|used|allocated).*")
    )
  }

  predicate isSink(DataFlow::Node sink) {
    exists(ResourceDeallocationFunction dealloc |
      sink.asExpr() = dealloc.getAnArgument()
    )
  }
}

module StateCheckDataFlow = DataFlow::Global<StateCheckDataFlowConfig>;

/**
 * 表示可能未初始化就被释放的资源相关函数调用
 */
class ResourceDeallocationFunction extends FunctionCall {
  ResourceDeallocationFunction() {
    // 检测各种资源释放函数
    this.getTarget().getName() in [
      "misc_deregister",    // 设备注销
      "kfifo_free",         // 内核FIFO释放
      "free",               // 通用内存释放
      "kfree",              // 内核内存释放
      "iounmap",            // 内存映射解除
      "release_region",     // 释放I/O区域
      "device_unregister",  // 设备注销
      "class_destroy",      // 类销毁
      "cdev_del",           // 字符设备删除
      "unregister_chrdev"   // 字符设备注销
    ]
  }
}

/**
 * 表示状态检查相关的表达式
 */
class StateCheckExpression extends Expr {
  StateCheckExpression() {
    // 检测直接的布尔字段访问 (如 obj->enabled, obj.enabled)
    exists(FieldAccess fa |
      fa = this and
      fa.getTarget().getName().regexpMatch(".*(?i)(enable|init|valid|active|used|allocated).*")
    )
    or
    // 检测对状态字段的比较操作
    exists(ComparisonOperation comp, FieldAccess fa |
      comp = this and
      fa = comp.getAnOperand() and
      fa.getTarget().getName().regexpMatch(".*(?i)(enable|init|valid|active|used|allocated).*")
    )
    or
    // 检测对状态字段的逻辑操作
    exists(UnaryLogicalOperation unary, FieldAccess fa |
      unary = this and
      fa = unary.getOperand() and
      fa.getTarget().getName().regexpMatch(".*(?i)(enable|init|valid|active|used|allocated).*")
    )
  }
}

/**
 * 表示包含资源释放操作的函数
 */
class ResourceCleanupFunction extends Function {
  ResourceCleanupFunction() {
    exists(ResourceDeallocationFunction dealloc |
      dealloc.getEnclosingFunction() = this
    ) and
    // 函数名包含清理、释放、禁用等关键词
    this.getName().regexpMatch(".*(?i)(cleanup|free|release|disable|remove|destroy|exit|deinit).*")
  }
}

/**
 * 检查函数是否在给定的资源释放调用之前包含状态检查
 */
predicate hasStateCheckBefore(ResourceDeallocationFunction dealloc) {
  exists(StateCheckExpression check |
    // 检查状态检查表达式和资源释放函数在同一个函数内
    check.getEnclosingFunction() = dealloc.getEnclosingFunction() and
    // 检查状态检查在资源释放之前（基于源码位置）
    check.getLocation().getEndLine() < dealloc.getLocation().getStartLine()
  )
}

/**
 * 检查是否存在早期返回模式（状态检查后直接返回）
 */
predicate hasEarlyReturnAfterCheck(StateCheckExpression check, ResourceDeallocationFunction dealloc) {
  exists(IfStmt ifstmt, ReturnStmt ret |
    // if语句的条件包含状态检查
    ifstmt.getCondition().getAChild*() = check and
    // if语句的then分支包含return
    ret.getParent*() = ifstmt.getThen() and
    // 资源释放操作在if语句之后
    ifstmt.getLocation().getEndLine() < dealloc.getLocation().getStartLine() and
    // 在同一个函数内
    ifstmt.getEnclosingFunction() = dealloc.getEnclosingFunction()
  )
}

/**
 * 检查结构体是否包含状态相关字段
 */
predicate hasStateField(Struct s) {
  exists(Field f |
    f.getDeclaringType() = s and
    f.getName().regexpMatch(".*(?i)(enable|init|valid|active|used|allocated).*")
  )
}

/**
 * 检查资源释放函数是否操作包含状态字段的结构体
 */
predicate operatesOnStatefulStruct(ResourceDeallocationFunction dealloc) {
  exists(Struct s, FieldAccess fa |
    hasStateField(s) and
    fa.getTarget().getDeclaringType() = s and
    fa.getEnclosingFunction() = dealloc.getEnclosingFunction() and
    // 确保字段访问在资源释放调用附近
    (
      fa.getLocation().getEndLine() >= dealloc.getLocation().getStartLine() - 10 and
      fa.getLocation().getStartLine() <= dealloc.getLocation().getEndLine() + 10
    )
  )
}

/**
 * 检查是否在错误处理路径中（通过goto标签识别）
 */
predicate inErrorHandlingPath(ResourceDeallocationFunction dealloc) {
  exists(GotoStmt goto, LabelStmt labelStmt |
    labelStmt.getName().regexpMatch(".*(?i)(err|error|fail|cleanup).*") and
    goto.getEnclosingFunction() = dealloc.getEnclosingFunction() and
    labelStmt.getEnclosingFunction() = dealloc.getEnclosingFunction() and
    // 资源释放在错误标签之后
    labelStmt.getLocation().getEndLine() < dealloc.getLocation().getStartLine()
  )
}

from ResourceDeallocationFunction dealloc, ResourceCleanupFunction cleanup
where
  // 资源释放函数在清理函数中被调用
  dealloc.getEnclosingFunction() = cleanup and
  
  // 操作的结构体包含状态字段
  operatesOnStatefulStruct(dealloc) and
  
  // 在资源释放前没有进行状态检查
  not hasStateCheckBefore(dealloc) and
  
  // 也没有使用早期返回模式进行状态检查
  not exists(StateCheckExpression check |
    hasEarlyReturnAfterCheck(check, dealloc) and
    check.getEnclosingFunction() = cleanup
  ) and
  
  // 排除明显安全的情况：函数名包含force或者在错误处理路径中
  not cleanup.getName().regexpMatch(".*(?i)force.*") and
  not inErrorHandlingPath(dealloc)

select dealloc, 
  "在函数 '" + cleanup.getName() + "' 中，对 '" + dealloc.getTarget().getName() + 
  "' 的调用缺少状态检查，可能导致对未初始化资源的非法操作。建议在调用前检查资源是否已被正确初始化。"