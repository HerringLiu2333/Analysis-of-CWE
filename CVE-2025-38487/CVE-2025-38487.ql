/**
 * @name CVE-2025-38487
 * @description Detects cleanup functions that operate on resources without first checking if those resources have been initialized. In `aspeed_lpc_disable_snoop`, the driver attempts to deregister a misc device and free a kfifo buffer for a channel that may not have been enabled. This leads to a NULL pointer dereference when `misc_deregister` is called on an uninitialized structure during the driver's remove &#47; unbind process.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/improper-resource-shutdown
 * @tags security
 *       correctness
 *       external/cwe/cwe-476
 *       external/cwe/cwe-399
 * @patch-commit 56448e78a6bb4e1a8528a0e2efe94eff0400c247
 * @source-file drivers/soc/aspeed/aspeed-lpc-snoop.c
 * @affected-function aspeed_lpc_disable_snoop
 * @kernel-config CONFIG_ASPEED_LPC_SNOOP
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *      @@ -58,6 +58,7 @@ struct aspeed_lpc_snoop_model_data {
 *       };
 *       
 *       struct aspeed_lpc_snoop_channel {
 *      +	bool enabled;
 *       	struct kfifo		fifo;
 *       	wait_queue_head_t	wq;
 *       	struct miscdevice	miscdev;
 *      @@ -190,6 +191,9 @@ static int aspeed_lpc_enable_snoop(struct aspeed_lpc_snoop *lpc_snoop,
 *       	const struct aspeed_lpc_snoop_model_data *model_data =
 *       		of_device_get_match_data(dev);
 *       
 *      +	if (WARN_ON(lpc_snoop->chan[channel].enabled))
 *      +		return -EBUSY;
 *      +
 *       	init_waitqueue_head(&lpc_snoop->chan[channel].wq);
 *       	/* Create FIFO datastructure *&#47;
 *       	rc = kfifo_alloc(&lpc_snoop->chan[channel].fifo,
 *      @@ -236,6 +240,8 @@ static int aspeed_lpc_enable_snoop(struct aspeed_lpc_snoop *lpc_snoop,
 *       		regmap_update_bits(lpc_snoop->regmap, HICRB,
 *       				hicrb_en, hicrb_en);
 *       
 *      +	lpc_snoop->chan[channel].enabled = true;
 *      +
 *       	return 0;
 *       
 *       err_misc_deregister:
 *      @@ -248,6 +254,9 @@ err_free_fifo:
 *       static void aspeed_lpc_disable_snoop(struct aspeed_lpc_snoop *lpc_snoop,
 *       				     int channel)
 *       {
 *      +	if (!lpc_snoop->chan[channel].enabled)
 *      +		return;
 *      +
 *       	switch (channel) {
 *       	case 0:
 *       		regmap_update_bits(lpc_snoop->regmap, HICR5,
 *      @@ -263,6 +272,8 @@ static void aspeed_lpc_disable_snoop(struct aspeed_lpc_snoop *lpc_snoop,
 *       		return;
 *       	}
 *       
 *      +	lpc_snoop->chan[channel].enabled = false;
 *      +	/* Consider improving safety wrt concurrent reader(s) *&#47;
 *       	misc_deregister(&lpc_snoop->chan[channel].miscdev);
 *       	kfifo_free(&lpc_snoop->chan[channel].fifo);
 *       }
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38487
 * @remediation
 * @patch-description |
 *     soc: aspeed: lpc-snoop: Don't disable channels that aren't enabled
 *     Mitigate e.g. the following:
 *     
 *         # echo 1e789080.lpc-snoop > /sys/bus/platform/drivers/aspeed-lpc-snoop/unbind
 *         ...
 *         [  120.363594] Unable to handle kernel NULL pointer dereference at virtual address 00000004 when write
 *         [  120.373866] [00000004] *pgd=00000000
 *         [  120.377910] Internal error: Oops: 805 [#1] SMP ARM
 *         [  120.383306] CPU: 1 UID: 0 PID: 315 Comm: sh Not tainted 6.15.0-rc1-00009-g926217bc7d7d-dirty #20 NONE
 *         ...
 *         [  120.679543] Call trace:
 *         [  120.679559]  misc_deregister from aspeed_lpc_snoop_remove+0x84/0xac
 *         [  120.692462]  aspeed_lpc_snoop_remove from platform_remove+0x28/0x38
 *         [  120.700996]  platform_remove from device_release_driver_internal+0x188/0x200
 *         ...
 */

import cpp
import semmle.code.cpp.dataflow.new.DataFlow
import semmle.code.cpp.controlflow.ControlFlowGraph

/**
 * 数据流配置：跟踪状态字段到资源释放函数的数据流
 */
module StateCheckDataFlowConfig implements DataFlow::ConfigSig {
  predicate isSource(DataFlow::Node source) {
    exists(FieldAccess fa |
      fa = source.asExpr() and
      fa.getTarget().getName().regexpMatch(".*(?i)(enable|init|valid|active|used|allocated).*")
    )
  }

  predicate isSink(DataFlow::Node sink) {
    exists(ResourceDeallocationFunction dealloc |
      sink.asExpr() = dealloc.getAnArgument()
    )
  }
}

module StateCheckDataFlow = DataFlow::Global<StateCheckDataFlowConfig>;

/**
 * 表示可能未初始化就被释放的资源相关函数调用
 */
class ResourceDeallocationFunction extends FunctionCall {
  ResourceDeallocationFunction() {
    // 检测各种资源释放函数
    this.getTarget().getName() in [
      "misc_deregister",    // 设备注销
      "kfifo_free",         // 内核FIFO释放
      "free",               // 通用内存释放
      "kfree",              // 内核内存释放
      "iounmap",            // 内存映射解除
      "release_region",     // 释放I/O区域
      "device_unregister",  // 设备注销
      "class_destroy",      // 类销毁
      "cdev_del",           // 字符设备删除
      "unregister_chrdev"   // 字符设备注销
    ]
  }
}

/**
 * 表示状态检查相关的表达式
 */
class StateCheckExpression extends Expr {
  StateCheckExpression() {
    // 检测直接的布尔字段访问 (如 obj->enabled, obj.enabled)
    exists(FieldAccess fa |
      fa = this and
      fa.getTarget().getName().regexpMatch(".*(?i)(enable|init|valid|active|used|allocated).*")
    )
    or
    // 检测对状态字段的比较操作
    exists(ComparisonOperation comp, FieldAccess fa |
      comp = this and
      fa = comp.getAnOperand() and
      fa.getTarget().getName().regexpMatch(".*(?i)(enable|init|valid|active|used|allocated).*")
    )
    or
    // 检测对状态字段的逻辑操作
    exists(UnaryLogicalOperation unary, FieldAccess fa |
      unary = this and
      fa = unary.getOperand() and
      fa.getTarget().getName().regexpMatch(".*(?i)(enable|init|valid|active|used|allocated).*")
    )
  }
}

/**
 * 表示包含资源释放操作的函数
 */
class ResourceCleanupFunction extends Function {
  ResourceCleanupFunction() {
    exists(ResourceDeallocationFunction dealloc |
      dealloc.getEnclosingFunction() = this
    ) and
    // 函数名包含清理、释放、禁用等关键词
    this.getName().regexpMatch(".*(?i)(cleanup|free|release|disable|remove|destroy|exit|deinit).*")
  }
}

/**
 * 检查函数是否在给定的资源释放调用之前包含状态检查
 */
predicate hasStateCheckBefore(ResourceDeallocationFunction dealloc) {
  exists(StateCheckExpression check |
    // 检查状态检查表达式和资源释放函数在同一个函数内
    check.getEnclosingFunction() = dealloc.getEnclosingFunction() and
    // 检查状态检查在资源释放之前（基于源码位置）
    check.getLocation().getEndLine() < dealloc.getLocation().getStartLine()
  )
}

/**
 * 检查是否存在早期返回模式（状态检查后直接返回）
 */
predicate hasEarlyReturnAfterCheck(StateCheckExpression check, ResourceDeallocationFunction dealloc) {
  exists(IfStmt ifstmt, ReturnStmt ret |
    // if语句的条件包含状态检查
    ifstmt.getCondition().getAChild*() = check and
    // if语句的then分支包含return
    ret.getParent*() = ifstmt.getThen() and
    // 资源释放操作在if语句之后
    ifstmt.getLocation().getEndLine() < dealloc.getLocation().getStartLine() and
    // 在同一个函数内
    ifstmt.getEnclosingFunction() = dealloc.getEnclosingFunction()
  )
}

/**
 * 检查结构体是否包含状态相关字段
 */
predicate hasStateField(Struct s) {
  exists(Field f |
    f.getDeclaringType() = s and
    f.getName().regexpMatch(".*(?i)(enable|init|valid|active|used|allocated).*")
  )
}

/**
 * 检查资源释放函数是否操作包含状态字段的结构体
 */
predicate operatesOnStatefulStruct(ResourceDeallocationFunction dealloc) {
  exists(Struct s, FieldAccess fa |
    hasStateField(s) and
    fa.getTarget().getDeclaringType() = s and
    fa.getEnclosingFunction() = dealloc.getEnclosingFunction() and
    // 确保字段访问在资源释放调用附近
    (
      fa.getLocation().getEndLine() >= dealloc.getLocation().getStartLine() - 10 and
      fa.getLocation().getStartLine() <= dealloc.getLocation().getEndLine() + 10
    )
  )
}

/**
 * 检查是否在错误处理路径中（通过goto标签识别）
 */
predicate inErrorHandlingPath(ResourceDeallocationFunction dealloc) {
  exists(GotoStmt goto, LabelStmt labelStmt |
    labelStmt.getName().regexpMatch(".*(?i)(err|error|fail|cleanup).*") and
    goto.getEnclosingFunction() = dealloc.getEnclosingFunction() and
    labelStmt.getEnclosingFunction() = dealloc.getEnclosingFunction() and
    // 资源释放在错误标签之后
    labelStmt.getLocation().getEndLine() < dealloc.getLocation().getStartLine()
  )
}

from ResourceDeallocationFunction dealloc, ResourceCleanupFunction cleanup
where
  // 资源释放函数在清理函数中被调用
  dealloc.getEnclosingFunction() = cleanup and
  
  // 操作的结构体包含状态字段
  operatesOnStatefulStruct(dealloc) and
  
  // 在资源释放前没有进行状态检查
  not hasStateCheckBefore(dealloc) and
  
  // 也没有使用早期返回模式进行状态检查
  not exists(StateCheckExpression check |
    hasEarlyReturnAfterCheck(check, dealloc) and
    check.getEnclosingFunction() = cleanup
  ) and
  
  // 排除明显安全的情况：函数名包含force或者在错误处理路径中
  not cleanup.getName().regexpMatch(".*(?i)force.*") and
  not inErrorHandlingPath(dealloc)

select dealloc, 
  "在函数 '" + cleanup.getName() + "' 中，对 '" + dealloc.getTarget().getName() + 
  "' 的调用缺少状态检查，可能导致对未初始化资源的非法操作。建议在调用前检查资源是否已被正确初始化。"