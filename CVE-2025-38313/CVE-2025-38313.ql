import cpp

/**
 * 表示kfree函数调用
 */
class KfreeCall extends FunctionCall {
  KfreeCall() {
    this.getTarget().getName() = "kfree"
  }
  
  /** 获取被释放的变量 */
  Variable getFreedVariable() {
    result = this.getArgument(0).(VariableAccess).getTarget()
  }
}

/**
 * 表示结构体成员指针赋值，特别是mc_dev指向mc_bus内部成员的情况
 */
class StructMemberPointerAssignment extends AssignExpr {
  StructMemberPointerAssignment() {
    // 检查赋值的右侧是否为结构体成员访问（如&mc_bus->mc_dev）
    this.getRValue() instanceof AddressOfExpr and
    this.getRValue().(AddressOfExpr).getOperand() instanceof FieldAccess
  }
  
  /** 获取指向的结构体变量 */
  Variable getPointedStructVariable() {
    exists(FieldAccess fa, VariableAccess va |
      fa = this.getRValue().(AddressOfExpr).getOperand() and
      va = fa.getQualifier() and
      result = va.getTarget()
    )
  }
  
  /** 获取被赋值的指针变量 */
  Variable getPointerVariable() {
    result = this.getLValue().(VariableAccess).getTarget()
  }
}

/**
 * 表示fsl_mc_device_add函数
 */
class FslMcDeviceAddFunction extends Function {
  FslMcDeviceAddFunction() {
    this.getName() = "fsl_mc_device_add"
  }
}

/**
 * 检测可能的双重释放路径
 */
predicate possibleDoubleFree(
  KfreeCall structFree,    // 释放结构体的kfree调用
  KfreeCall memberFree,    // 释放成员指针的kfree调用
  Variable structVar,      // 结构体变量
  Variable memberVar,      // 指向结构体成员的指针变量
  StructMemberPointerAssignment assignment  // 指针赋值语句
) {
  // 确保在fsl_mc_device_add函数中
  exists(FslMcDeviceAddFunction func |
    structFree.getEnclosingFunction() = func and
    memberFree.getEnclosingFunction() = func and
    assignment.getEnclosingFunction() = func
  ) and
  
  // 指针变量指向结构体变量的成员
  assignment.getPointerVariable() = memberVar and
  assignment.getPointedStructVariable() = structVar and
  
  // 两个kfree调用分别释放结构体和成员指针
  structFree.getFreedVariable() = structVar and
  memberFree.getFreedVariable() = memberVar and
  
  // 确保两个释放操作在控制流中可能都被执行
  exists(ControlFlowNode cfn1, ControlFlowNode cfn2 |
    cfn1.getASuccessor*() = cfn2 and
    structFree = cfn1 and
    memberFree = cfn2
  ) and
  
  // 检查是否没有适当的条件保护来避免双重释放
  not exists(IfStmt guardStmt, ControlFlowNode guard |
    guard = guardStmt.getCondition().getAChild*() and
    guard.getASuccessor*() = structFree and
    guard.getASuccessor*() = memberFree and
    // 检查条件是否能够确保两个释放不会同时执行
    guardStmt.getThen().getAChild*() = structFree and
    guardStmt.getElse().getAChild*() = memberFree
  )
}

/**
 * 查找错误处理标签附近的双重释放
 */
predicate inErrorHandlingPath(KfreeCall kfreeCall) {
  exists(LabelStmt label |
    // 查找以"error"开头的标签
    label.getName().matches("error%") and
    // kfree调用在标签之后
    label.getASuccessor*() = kfreeCall
  )
}

/**
 * 检测特定的mc_bus和mc_dev双重释放模式
 */
predicate mcBusMcDevDoubleFree(
  KfreeCall mcBusFree,
  KfreeCall mcDevFree,
  Variable mcBusVar,
  Variable mcDevVar
) {
  // 变量名符合模式
  mcBusVar.getName().matches("%mc_bus%") and
  mcDevVar.getName().matches("%mc_dev%") and
  
  // 两个kfree调用
  mcBusFree.getFreedVariable() = mcBusVar and
  mcDevFree.getFreedVariable() = mcDevVar and
  
  // 在错误处理路径中
  inErrorHandlingPath(mcBusFree) and
  inErrorHandlingPath(mcDevFree) and
  
  // 在同一个函数中
  mcBusFree.getEnclosingFunction() = mcDevFree.getEnclosingFunction() and
  
  // mc_bus的释放在mc_dev释放之前或在同一个基本块中
  (mcBusFree.getBasicBlock() = mcDevFree.getBasicBlock() or
   mcBusFree.getASuccessor*() = mcDevFree) and
   
  // 确保存在mc_dev指向mc_bus成员的赋值
  exists(StructMemberPointerAssignment assignment |
    assignment.getPointerVariable() = mcDevVar and
    assignment.getPointedStructVariable() = mcBusVar and
    assignment.getEnclosingFunction() = mcBusFree.getEnclosingFunction()
  )
}

from KfreeCall structFree, KfreeCall memberFree, Variable structVar, Variable memberVar
where 
  // 检测一般的双重释放模式
  exists(StructMemberPointerAssignment assignment |
    possibleDoubleFree(structFree, memberFree, structVar, memberVar, assignment)
  ) or
  // 检测特定的mc_bus/mc_dev双重释放模式
  mcBusMcDevDoubleFree(structFree, memberFree, structVar, memberVar)

select memberFree, 
  memberVar, memberVar.getName(),
  structVar, structVar.getName(), 
  structFree