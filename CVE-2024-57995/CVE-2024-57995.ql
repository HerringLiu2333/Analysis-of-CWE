/**
 * @name CVE-2024-57995
 * @description In ath12k_mac_assign_vif_to_vdev(), when an arvif was previously created on a
 *              different radio, ath12k_mac_unassign_link_vif() freed the arvif pointer. The
 *              code then immediately checked arvif->is_created, causing a read-after-free.
 *              The fix moves the is_created check to occur only after arvif is re-assigned
 *              via ath12k_mac_assign_link_vif().
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/ath12k-assign-vif-read-after-free
 * @tags
 *       wifi
 *       ath12k
 *       lifecycle
 *       read-after-free
 *       memory-safety
 * @patch-commit f3a95a312419e4f1e992525917da9dbcd247038f
 * @source-file drivers/net/wireless/ath/ath12k/mac.c
 * @affected-function ath12k_mac_assign_vif_to_vdev
 * @vulnerability-type use-after-free
 * @patch-diff |
 *     diff --git a/drivers/net/wireless/ath/ath12k/mac.c b/drivers/net/wireless/ath/ath12k/mac.c
 *     index d493ec812055f8..cf4f4245f6068b 100644
 *     --- a/drivers/net/wireless/ath/ath12k/mac.c
 *     +++ b/drivers/net/wireless/ath/ath12k/mac.c
 *     @@ -7173,9 +7173,6 @@ static struct ath12k *ath12k_mac_assign_vif_to_vdev(struct ieee80211_hw *hw,
 *      
 *      	ab = ar->ab;
 *      
 *     -	if (arvif->is_created)
 *     -		goto flush;
 *     -
 *      	/* Assign arvif again here since previous radio switch block
 *      	 * would've unassigned and cleared it.
 *      	 &#47;
 *     @@ -7186,6 +7183,9 @@ static struct ath12k *ath12k_mac_assign_vif_to_vdev(struct ieee80211_hw *hw,
 *      		goto unlock;
 *      	}
 *      
 *     +	if (arvif->is_created)
 *     +		goto flush;
 *     +
 *      	if (ar->num_created_vdevs > (TARGET_NUM_VDEVS - 1)) {
 *      		ath12k_warn(ab, "failed to create vdev, reached max vdev limit %d\n",
 *      			    TARGET_NUM_VDEVS);
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f3a95a312419e4f1e992525917da9dbcd247038f 
 * @remediation Do not access arvif after it may have been freed by unassignment. Re-assign the
 *              arvif with ath12k_mac_assign_link_vif() first, then perform checks like
 *              arvif->is_created. This prevents read-after-free and ensures valid pointer usage.
 */



import cpp

from Function func, Call unassignCall, Call assignCall, Call isCreatedAccessCall
where func.getName() = "ath12k_mac_assign_vif_to_vdev"
  and unassignCall.getEnclosingFunction() = func
  and assignCall.getEnclosingFunction() = func
  and isCreatedAccessCall.getEnclosingFunction() = func
  and unassignCall.getTarget().getName() = "ath12k_mac_unassign_link_vif"
  and assignCall.getTarget().getName() = "ath12k_mac_assign_link_vif"
  and isCreatedAccessCall.getArgument(0).toString() = "arvif"
  and isCreatedAccessCall.getTarget().getName().indexOf("is_created") >= 0
  and unassignCall.getLocation().getFile() = assignCall.getLocation().getFile()
  and assignCall.getLocation().getFile() = isCreatedAccessCall.getLocation().getFile()
  // 检查调用顺序：unassign -> assign -> is_created访问
  and unassignCall.getLocation().getStartLine() < assignCall.getLocation().getStartLine()
  and assignCall.getLocation().getStartLine() < isCreatedAccessCall.getLocation().getStartLine()
select isCreatedAccessCall, 
  "Potential read-after-free: is_created accessed after unassign/assign calls",
  unassignCall, "Unassign call at line " + unassignCall.getLocation().getStartLine().toString(),
  assignCall, "Assign call at line " + assignCall.getLocation().getStartLine().toString()