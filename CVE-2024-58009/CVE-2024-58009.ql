/**
 * @name CVE-2024-58009
 * @description Detects potential NULL pointer dereference in l2cap_sock_alloc() error path,
 *  where sock may be NULL when called from l2cap_sock_new_connection_cb(), but
 *  the code unconditionally assigns sock->sk = NULL on failure.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/unchecked-null-dereference
 * @tags 
 *  security
 *  correctness
 *  reliability
 *  null-dereference
 *  external/cwe/cwe-476
 * @patch-commit cf601a24120c674cd7c907ea695f92617af6abd0
 * @source-file net/bluetooth/l2cap_sock.c
 * @affected-function l2cap_sock_alloc
 * @kernel-config N/A
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *  diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
 *  index 57035e46f71518…4a0e73d3996056 100644
 *  --- a/net/bluetooth/l2cap_sock.c
 *  +++ b/net/bluetooth/l2cap_sock.c
 *  @@ -1876,7 +1876,8 @@ static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
 *    chan = l2cap_chan_create();
 *    if (!chan) {
 *    sk_free(sk);
 *  - sock->sk = NULL;
 *  + if (sock)
 *  + sock->sk = NULL;
 *    return NULL;
 *    }
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cf601a24120c674cd7c907ea695f92617af6abd0
 * @remediation In error paths, guard accesses to potentially NULL parameters. Specifically,
 *  check sock for NULL before assigning to sock->sk. Avoid reordering bt_sock_alloc()
 *  and l2cap_chan_create() if it would expose partially initialized channels via
 *  global lists; prefer minimal NULL checks to keep lifecycle consistent.
 * @patch-description |
 *  Bluetooth: L2CAP: handle NULL sock pointer in l2cap_sock_alloc
 *  commit 5f397409f8ee5bc82901eeaf799e1cbc4f8edcf1 upstream.
 *  
 *  A NULL sock pointer is passed into l2cap_sock_alloc() when it is called
 *  from l2cap_sock_new_connection_cb() and the error handling paths should
 *  also be aware of it.
 *
 *  Seemingly a more elegant solution would be to swap bt_sock_alloc() and
 *  l2cap_chan_create() calls since they are not interdependent to that moment
 *  but then l2cap_chan_create() adds the soon to be deallocated and still
 *  dummy-initialized channel to the global list accessible by many L2CAP
 *  paths. The channel would be removed from the list in short period of time
 *  but be a bit more straight-forward here and just check for NULL instead of
 *  changing the order of function calls.
 *  
 *  Found by Linux Verification Center (linuxtesting.org) with SVACE static
 *  analysis tool.
 *  
 *  Fixes: 7c4f78cdb8e7 ("Bluetooth: L2CAP: do not leave dangling sk pointer on error in l2cap_sock_create()")
 */


import cpp

from FunctionCall sk_free
where
  // 查找函数调用sk_free
  sk_free.getTarget().getName() = "sk_free" and
  not sk_free.getASuccessor().getPrimaryQlClasses().toString() = "ReturnStmt" and
  not exists(IfStmt ifstmt |
      sk_free.getASuccessor() = ifstmt and
      ifstmt.getCondition().toString() = "sock"
  )
select sk_free, "Potential NULL pointer dereference: parameter 'sock' may be NULL in error path"