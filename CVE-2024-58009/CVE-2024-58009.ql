/**
 * @name CVE-2024-58009
 * @description Detects potential NULL pointer dereference in l2cap_sock_alloc() error path,
 *  where sock may be NULL when called from l2cap_sock_new_connection_cb(), but
 *  the code unconditionally assigns sock->sk = NULL on failure.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/unchecked-null-dereference
 * @tags 
 *  security
 *  correctness
 *  reliability
 *  null-dereference
 *  external/cwe/cwe-476
 * @patch-commit cf601a24120c674cd7c907ea695f92617af6abd0
 * @source-file net/bluetooth/l2cap_sock.c
 * @affected-function l2cap_sock_alloc
 * @kernel-config N/A
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *  diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
 *  index 57035e46f71518…4a0e73d3996056 100644
 *  --- a/net/bluetooth/l2cap_sock.c
 *  +++ b/net/bluetooth/l2cap_sock.c
 *  @@ -1876,7 +1876,8 @@ static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
 *    chan = l2cap_chan_create();
 *    if (!chan) {
 *    sk_free(sk);
 *  - sock->sk = NULL;
 *  + if (sock)
 *  + sock->sk = NULL;
 *    return NULL;
 *    }
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=cf601a24120c674cd7c907ea695f92617af6abd0
 * @remediation In error paths, guard accesses to potentially NULL parameters. Specifically,
 *  check sock for NULL before assigning to sock->sk. Avoid reordering bt_sock_alloc()
 *  and l2cap_chan_create() if it would expose partially initialized channels via
 *  global lists; prefer minimal NULL checks to keep lifecycle consistent.
 */


import cpp

from FunctionCall sk_free
where
  // 查找函数调用sk_free
  sk_free.getTarget().getName() = "sk_free" and
  not sk_free.getASuccessor().getPrimaryQlClasses().toString() = "ReturnStmt" and
  not exists(IfStmt ifstmt |
      sk_free.getASuccessor() = ifstmt and
      ifstmt.getCondition().toString() = "sock"
  )
select sk_free, "Potential NULL pointer dereference: parameter 'sock' may be NULL in error path"