/**
 * @name CVE-2024-58007
 * @description Detects incorrect bounds checking when validating presence of struct fields in
 *  Qualcomm socinfo, where offsetof() was used instead of offsetofend() to gate
 *  access to serial_num. On SoCs exposing older socinfo versions without the
 *  serial_num field, this allows reading past the end of the socinfo struct from
 *  SMEM, exposing a bogus constant serial number (out-of-bounds read).
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/incorrect-bounds-check-struct-field-end
 * @tags 
 *  security
 *  correctness
 *  reliability
 *  out-of-bounds-read
 *  information-disclosure
 *  external/cwe/cwe-125
 * @patch-commit 9c88b3a3fae4d60641c3a45be66269d00eff33cd
 * @source-file drivers/soc/qcom/socinfo.c
 * @affected-function qcom_socinfo_probe
 * @kernel-config N/A
 * @vulnerability-type out-of-bounds-read
 * @patch-diff |
 *  diff --git a/drivers/soc/qcom/socinfo.c b/drivers/soc/qcom/socinfo.c
 *  index 5401b075840b8e…e5f14202618829 100644
 *  --- a/drivers/soc/qcom/socinfo.c
 *  +++ b/drivers/soc/qcom/socinfo.c
 *  @@ -652,7 +652,7 @@ static int qcom_socinfo_probe(struct platform_device *pdev)
 *    if (!qs->attr.soc_id || !qs->attr.revision)
 *    return -ENOMEM;
 *
 *  - if (offsetof(struct socinfo, serial_num) <= item_size) {
 *  + if (offsetofend(struct socinfo, serial_num) <= item_size) {
 *    qs->attr.serial_number = devm_kasprintf(&pdev->dev, GFP_KERNEL,
 *    "%u",
 *    le32_to_cpu(info->serial_num));
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=9c88b3a3fae4d60641c3a45be66269d00eff33cd
 * @remediation When checking for presence of trailing struct fields provided by firmware or
 *  shared memory, validate that the end of the field lies within the available
 *  item size using offsetofend(), not just the start offset via offsetof().
 *  Do not expose or access fields for socinfo versions that do not include them.
 */



import cpp

from FunctionCall offsetofCall, IfStmt ifstmt, BinaryOperation bo
where
  // 查找offsetof调用
  offsetofCall.getTarget().getName() = "offsetof" and
  // 检查是否在条件语句中使用offsetof进行边界检查
  bo.getOperator() = "<=" and
  bo.getLeftOperand() = offsetofCall and
  bo.getRightOperand().toString() = "item_size" and
  ifstmt.getCondition() = bo
select offsetofCall, "Potential bounds check error: consider using offsetofend instead of offsetof for complete field boundary check"