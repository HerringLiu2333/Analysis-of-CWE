/**
 * @name CVE-2025-38247
 * @description Detects a resource leak where an allocated resource is not freed due to a
 *              premature return in an error handling path. This can lead to a denial-of-service
 *              vulnerability by exhausting kernel memory.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/linux/cve-2025-38247-premature-return-leak
 * @tags security
 *       correctness
 *       resource-leak
 *       external/cwe/cwe-404
 *       external/cwe/cwe-772
 * @patch-commit 0748e553df0225754c316a92af3a77fdc057b358
 * @source-file fs/namespace.c
 * @affected-function __do_sys_open_tree_attr
 * @kernel-config Always Enabled (Core Kernel Functionality)
 * @vulnerability-type resource-leak
 * @patch-diff |
 *     @@ -5307,16 +5307,12 @@ SYSCALL_DEFINE5(open_tree_attr, int, dfd, const char __user *, filename,
 *      			kattr.kflags |= MOUNT_KATTR_RECURSE;
 *      
 *      		ret = wants_mount_setattr(uattr, usize, &kattr);
 *     -		if (ret < 0)
 *     -			return ret;
 *     -
 *     -		if (ret) {
 *     +		if (ret > 0) {
 *      			ret = do_mount_setattr(&file->f_path, &kattr);
 *     -			if (ret)
 *     -				return ret;
 *     -
 *      			finish_mount_kattr(&kattr);
 *      		}
 *     +		if (ret)
 *     +			return ret;
 *      	}
 *      
 *      	fd = get_unused_fd_flags(flags & O_CLOEXEC);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38247
 * @remediation 
 * @patch-description |
 *     userns and mnt_idmap leak in open_tree_attr(2)
 *     Once want_mount_setattr() has returned a positive, it does require
 *     finish_mount_kattr() to release ->mnt_userns.  Failing do_mount_setattr()
 *     does not change that.
 *     
 *     As the result, we can end up leaking userns and possibly mnt_idmap as
 *     well.
 *     
 *     Fixes: c4a16820d901 ("fs: add open_tree_attr()")
 */
import cpp
import semmle.code.cpp.controlflow.BasicBlocks

from Function f, FunctionCall alloc_call, ReturnStmt early_return
where
  // 确定“分配点”和它所在的函数
  alloc_call.getTarget().hasGlobalName("wants_mount_setattr") and
  f = alloc_call.getEnclosingFunction() and
  // 确定同一个函数内的“退出点”
  early_return.getEnclosingFunction() = f and
  // 检查从“分配点”到“退出点”是否存在一条执行路径
  alloc_call.getBasicBlock().getASuccessor+() = early_return.getBasicBlock() and
  // 核心逻辑：确认这条路径上没有“释放点”
  // 不存在任何一个“释放点”，它位于“分配点”和“退出点”之间
  not exists(FunctionCall free_call |
    free_call.getTarget().hasGlobalName("finish_mount_kattr") and
    free_call.getEnclosingFunction() = f and
    // “位于之间”的定义是：
    // a) 从“分配点”可以到达“释放点”
    alloc_call.getBasicBlock().getASuccessor*() = free_call.getBasicBlock() and
    // b) 从“释放点”可以到达“退出点”
    free_call.getBasicBlock().getASuccessor*() = early_return.getBasicBlock()
  )
select early_return, alloc_call