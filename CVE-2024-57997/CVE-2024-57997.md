```markdown
### **## 根因描述**

根因在于通道统计数组的内存分配尺寸计算错误。代码将 wcn->chan_survey 作为“每个信道一个 struct wcn36xx_chan_survey”的数组来使用，但旧实现用 devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL) 仅按“元素个数”字节数分配（n_channels 字节），而非“元素个数 × 结构体大小”。这会导致严重的内存欠分配，后续按数组下标访问并写入 struct 字段时发生越界访问（OOB），被 KASAN 报告。

此外，旧分配未进行零初始化，在某些信道没有帧的情况下，可能读取未初始化的字段，导致不确定行为。

### 被修改的代码

```c
@@ -1586,7 +1586,10 @@ static int wcn36xx_probe(struct platform_device *pdev)
 	}
 
 	n_channels = wcn_band_2ghz.n_channels + wcn_band_5ghz.n_channels;
-	wcn->chan_survey = devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);
+	wcn->chan_survey = devm_kcalloc(wcn->dev,
+					n_channels,
+					sizeof(struct wcn36xx_chan_survey),
+					GFP_KERNEL);
 	if (!wcn->chan_survey) {
 		ret = -ENOMEM;
 		goto out_wq;
```

- 修改原因:
  - 旧代码的缺陷:
    1. 将元素个数误当作字节数，仅分配 n_channels 字节，未乘以 sizeof(struct wcn36xx_chan_survey)，导致内存欠分配并引发缓冲区越界读写。
    2. 未进行零初始化，可能在“无帧信道”场景下读取未初始化值。
  - 新代码的修复:
    1. 使用 devm_kcalloc(wcn->dev, n_channels, sizeof(struct wcn36xx_chan_survey), GFP_KERNEL) 按“个数 × 大小”正确分配，并自动清零内存。
    2. 保持分配失败判空处理，正确返回 -ENOMEM，提升健壮性。

### **## 总结**

- 漏洞类型: 内存分配大小错误/缓冲区越界访问；未初始化内存读取
- 根本缺陷: 把元素个数当作字节数进行分配，未乘以结构体大小；未对分配内存进行初始化
- 修复原理: 改用 devm_kcalloc 按元素个数与结构体大小正确分配并清零，避免越界和未初始化读取
```