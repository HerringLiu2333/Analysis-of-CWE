/**
 * @name CVE-2024-58073
 * @description drm/msm DPU plane state printing unconditionally dereferenced pipe->sspp,
 *              which may be NULL when state is dumped without a prior atomic_check()
 *              (that assigns pipe->sspp). This could cause a NULL pointer dereference
 *              during dpu_plane_atomic_print_state(). The fix guards all accesses to
 *              pipe->sspp with a NULL check, similar to the existing r_pipe->sspp guard.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/drm-msm-dpu-plane-print-null-sspp-check
 * @tags
 *   correctness
 *   reliability
 *   gpu
 *   drm
 *   msm
 *   dpu
 *   diagnostics
 *   null-dereference
 * @patch-commit 789384eb1437aed94155dc0eac8a8a6ba1baf578
 * @source-file drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c
 * @affected-function dpu_plane_atomic_print_state
 * @vulnerability-type null-pointer-dereference
 * @patch-diff
 *   diff --git a/drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c b/drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c
 *   index 3ffac24333a2a5…703e58901d53f2 100644
 *   --- a/drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c
 *   +++ b/drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c
 *   @@ -1335,12 +1335,15 @@ static void dpu_plane_atomic_print_state(struct drm_printer *p,
 *
 *        drm_printf(p, "\tstage=%d\n", pstate->stage);
 *
 *   -    drm_printf(p, "\tsspp[0]=%s\n", pipe->sspp->cap->name);
 *   -    drm_printf(p, "\tmultirect_mode[0]=%s\n", dpu_get_multirect_mode(pipe->multirect_mode));
 *   -    drm_printf(p, "\tmultirect_index[0]=%s\n",
 *   -               dpu_get_multirect_index(pipe->multirect_index));
 *   -    drm_printf(p, "\tsrc[0]=" DRM_RECT_FMT "\n", DRM_RECT_ARG(&pipe_cfg->src_rect));
 *   -    drm_printf(p, "\tdst[0]=" DRM_RECT_FMT "\n", DRM_RECT_ARG(&pipe_cfg->dst_rect));
 *   +    if (pipe->sspp) {
 *   +        drm_printf(p, "\tsspp[0]=%s\n", pipe->sspp->cap->name);
 *   +        drm_printf(p, "\tmultirect_mode[0]=%s\n",
 *   +                   dpu_get_multirect_mode(pipe->multirect_mode));
 *   +        drm_printf(p, "\tmultirect_index[0]=%s\n",
 *   +                   dpu_get_multirect_index(pipe->multirect_index));
 *   +        drm_printf(p, "\tsrc[0]=" DRM_RECT_FMT "\n", DRM_RECT_ARG(&pipe_cfg->src_rect));
 *   +        drm_printf(p, "\tdst[0]=" DRM_RECT_FMT "\n", DRM_RECT_ARG(&pipe_cfg->dst_rect));
 *   +    }
 *
 *        if (r_pipe->sspp) {
 *            drm_printf(p, "\tsspp[1]=%s\n", r_pipe->sspp->cap->name);
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=789384eb1437aed94155dc0eac8a8a6ba1baf578
 * @remediation In dpu_plane_atomic_print_state(), guard all dereferences of pipe->sspp with a
 *              NULL check before printing fields derived from it. Alternatively ensure that
 *              atomic_check() is performed to initialize pipe->sspp prior to state dumping.
 * @patch-description |
 *  drm/msm/dpu: check dpu_plane_atomic_print_state() for valid sspp
 *  Similar to the r_pipe sspp protect, add a check to protect
 *  the pipe state prints to avoid NULL ptr dereference for cases when
 *  the state is dumped without a corresponding atomic_check() where the
 *  pipe->sspp is assigned.
 *
 *  Fixes: 31f7148fd370 ("drm/msm/dpu: move pstate->pipe initialization to dpu_plane_atomic_check")
 */

import cpp

/*
 * 检测MSM DPU驱动中的NULL指针解引用漏洞
 * 该查询用于识别在dpu_plane_atomic_print_state函数中访问pipe->sspp之前未进行NULL检查的情况
 * 这可能导致在没有atomic_check()的情况下转储状态时出现空指针解引用错误
 * This query identifies NULL pointer dereference vulnerabilities where
 * pipe->sspp is accessed without NULL check in dpu_plane_atomic_print_state function
 */

// 检查是否为dpu_plane_atomic_print_state函数
// Check if it's dpu_plane_atomic_print_state function
predicate isDpuPlaneAtomicPrintStateFunction(Function f) {
  f.getName() = "dpu_plane_atomic_print_state"
}

// 检查是否为pipe->sspp字段访问
// Check if it's pipe->sspp field access
predicate isPipeSsppAccess(Expr expr) {
  exists(FieldAccess fa |
    fa = expr and
    fa.getTarget().getName() = "sspp" and
    exists(VariableAccess pipeAccess |
      pipeAccess = fa.getQualifier() and
      pipeAccess.getTarget().getName() = "pipe"
    )
  )
}

// 检查是否为drm_printf函数调用且包含pipe->sspp访问
// Check if it's drm_printf function call containing pipe->sspp access
predicate isDrmPrintfWithPipeSspp(FunctionCall fc) {
  fc.getTarget().getName() = "drm_printf" and
  exists(Expr arg |
    arg = fc.getArgument(1) and
    isPipeSsppAccess(arg)
  )
}

// 检查是否有NULL检查
// Check for NULL check
predicate hasNullCheckBeforeAccess(FunctionCall printfCall) {
  exists(IfStmt ifStmt |
    ifStmt.getLocation().getStartLine() < printfCall.getLocation().getStartLine() and
    ifStmt.getCondition().toString().matches("%pipe->sspp%") and
    ifStmt.getCondition().toString().matches("%!= NULL%")
  )
}

from
  Function f,
  FunctionCall printfCall  // drm_printf调用
where
  // 限制在dpu_plane_atomic_print_state函数内
  isDpuPlaneAtomicPrintStateFunction(f) and
  printfCall.getEnclosingFunction() = f and
  // 查找包含pipe->sspp访问的drm_printf调用
  isDrmPrintfWithPipeSspp(printfCall) and
  // 在访问之前没有NULL检查
  not hasNullCheckBeforeAccess(printfCall)
select
  printfCall,
  "Potential NULL pointer dereference: pipe->sspp accessed without NULL check in dpu_plane_atomic_print_state()"