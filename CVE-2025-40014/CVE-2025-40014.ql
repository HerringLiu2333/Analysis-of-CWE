/**
 * @name CVE-2025-40014
 * @description Detects an out-of-bounds read in the `amd_set_spi_freq` function. If the input `speed_hz`
 *              is smaller than all predefined frequency values in the `amd_spi_freq` array, the lookup
 *              loop iterates one step too far due to an off-by-one error. The resulting out-of-bounds
 *              index is then used to access the array, leading to a stack-based out-of-bounds read.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/amd-spi-out-of-bounds-read
 * @tags security
 *       correctness
 *       external/cwe/cwe-125
 *       external/cwe/cwe-193
 * @patch-commit 76e51db43fe4aaaebcc5ddda67b0807f7c9bdecc
 * @source-file drivers/spi/spi-amd.c
 * @affected-function amd_set_spi_freq
 * @kernel-config CONFIG_SPI_AMD
 * @vulnerability-type out-of-bounds-read
 * @patch-diff |
 *     @@ -302,7 +302,7 @@ static void amd_set_spi_freq(struct amd_spi *amd_spi, u32 speed_hz)
 *      {
 *      	unsigned int i, spd7_val, alt_spd;
 *      
 *     -	for (i = 0; i < ARRAY_SIZE(amd_spi_freq); i++)
 *     +	for (i = 0; i < ARRAY_SIZE(amd_spi_freq)-1; i++)
 *      		if (speed_hz >= amd_spi_freq[i].speed_hz)
 *      			break;
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-40014
 * @remediation 
 * @patch-description |
 *     objtool, spi: amd: Fix out-of-bounds stack access in amd_set_spi_freq()
 *     If speed_hz < AMD_SPI_MIN_HZ, amd_set_spi_freq() iterates over the
 *     entire amd_spi_freq array without breaking out early, causing 'i' to go
 *     beyond the array bounds.
 *     
 *     Fix that by stopping the loop when it gets to the last entry, so the low
 *     speed_hz value gets clamped up to AMD_SPI_MIN_HZ.
 *     
 *     Fixes the following warning with an UBSAN kernel:
 *     
 *       drivers/spi/spi-amd.o: error: objtool: amd_set_spi_freq() falls through to next function amd_spi_set_opcode()
 */

import cpp

// 检测潜在的数组越界访问
from ForStmt forLoop, Variable loopVar, ArrayExpr arrayAccess, LTExpr ltExpr,
     VariableAccess indexVar, Variable arrayVar, DivExpr divExpr
where
  // 获取循环变量
  exists(ExprStmt declStmt, AssignExpr vde |
    declStmt = forLoop.getInitialization() and
    vde = declStmt.getExpr() and
    loopVar = vde.getLValue().(VariableAccess).getTarget()
  ) and
  
  // 循环条件是小于比较 (i < something)
  ltExpr = forLoop.getCondition() and
  ltExpr.getLeftOperand().(VariableAccess).getTarget() = loopVar and
  
  // 检测ARRAY_SIZE宏展开后的模式: sizeof(array)/sizeof(array[0])
  divExpr = ltExpr.getRightOperand().(AddExpr).getLeftOperand() and
  exists(SizeofExprOperator sizeofArray, SizeofExprOperator sizeofElement |
    sizeofArray = divExpr.getLeftOperand() and
    sizeofElement = divExpr.getRightOperand() and
    // sizeof(array)
    sizeofArray.getExprOperand().(VariableAccess).getTarget() = arrayVar and
    // sizeof(array[0]) 或 sizeof(*array)
    (
      sizeofElement.getExprOperand().(ArrayExpr).getArrayBase().(VariableAccess).getTarget() = arrayVar
      or
      sizeofElement.getExprOperand().(PointerDereferenceExpr).getOperand().(VariableAccess).getTarget() = arrayVar
    )
  ) and
  
  // 在循环体内存在数组访问
//   arrayAccess.getParent*() = forLoop.getStmt() and
  strictlyDominates(forLoop.getBasicBlock(), arrayAccess.getBasicBlock()) and
  
  // 数组访问使用循环变量作为索引
  indexVar = arrayAccess.getArrayOffset() and
  indexVar.getTarget() = loopVar and
  
  // 数组访问的是同一个数组变量
  arrayAccess.getArrayBase().(VariableAccess).getTarget() = arrayVar

select arrayAccess, 
       "潜在的数组越界访问：循环变量 $@ 可能超出数组边界。当循环条件为 'i < ARRAY_SIZE(array)' 且没有break语句时，在某些条件下索引可能越界访问数组。建议改为 'i < ARRAY_SIZE(array) - 1' 或添加适当的边界检查。",
       loopVar, loopVar.getName()