/**
 * @name CVE-2024-58015
 * @description wifi: ath12k debugfs selfgen stats used an oversized array length when calling
 *              print_array_to_buf_index(), causing a potential out-of-bounds access. The fix
 *              reduces the element count by one to match the valid index range and prevent OOB.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/ath12k-selfgen-stats-array-oob
 * @tags
 *   wifi
 *   ath12k
 *   bounds
 *   out-of-bounds
 *   robustness
 *   debugging
 * @patch-commit eb8c0534713865d190856f10bfc97cf0b88475b1
 * @source-file drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
 * @affected-function ath12k_htt_print_tx_selfgen_ac_stats_tlv
 * @affected-function ath12k_htt_print_tx_selfgen_ax_stats_tlv
 * @vulnerability-type out-of-bounds-access
 * @patch-diff
 *   diff --git a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
 *   index c9980c0193d1d7..43ea87e981f421 100644
 *   --- a/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
 *   +++ b/drivers/net/wireless/ath/ath12k/debugfs_htt_stats.c
 *   @@ -1562,7 +1562,8 @@ ath12k_htt_print_tx_selfgen_ac_stats_tlv(const void *tag_buf, u16 tag_len,
 *                           le32_to_cpu(htt_stats_buf->ac_mu_mimo_ndp));
 *           len += print_array_to_buf_index(buf, len, "ac_mu_mimo_brpollX_tried = ", 1,
 *                                           htt_stats_buf->ac_mu_mimo_brpoll,
 *   -                                       ATH12K_HTT_TX_NUM_AC_MUMIMO_USER_STATS, "\n\n");
 *   +                                       ATH12K_HTT_TX_NUM_AC_MUMIMO_USER_STATS - 1,
 *   +                                       "\n\n");
 *   
 *           stats_req->buf_len = len;
 *    }
 *   @@ -1590,7 +1591,7 @@ ath12k_htt_print_tx_selfgen_ax_stats_tlv(const void *tag_buf, u16 tag_len,
 *                           le32_to_cpu(htt_stats_buf->ax_mu_mimo_ndp));
 *           len += print_array_to_buf_index(buf, len, "ax_mu_mimo_brpollX_tried = ", 1,
 *                                           htt_stats_buf->ax_mu_mimo_brpoll,
 *   -                                       ATH12K_HTT_TX_NUM_AX_MUMIMO_USER_STATS, "\n");
 *   +                                       ATH12K_HTT_TX_NUM_AX_MUMIMO_USER_STATS - 1, "\n");
 *           len += scnprintf(buf + len, buf_len - len, "ax_basic_trigger = %u\n",
 *                            le32_to_cpu(htt_stats_buf->ax_basic_trigger));
 *           len += scnprintf(buf + len, buf_len - len, "ax_ulmumimo_total_trigger = %u\n",
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=eb8c0534713865d190856f10bfc97cf0b88475b1
 * @remediation Pass the correct array length to print_array_to_buf_index(), reducing the count
 *              by one to avoid off-by-one and out-of-bounds access when printing selfgen stats.
 */

import cpp

from FunctionCall funcCall, Expr arraySizeArg
where
  // 查找print_array_to_buf_index或类似函数调用
  funcCall.getTarget().getName().matches("%print_array%") or
  funcCall.getTarget().getName().matches("%memcpy%") or
  funcCall.getTarget().getName().matches("%memmove%") or
  funcCall.getTarget().getName().matches("%strncpy%") and
  // 获取数组大小参数（通常是第4或第5个参数）
  arraySizeArg = funcCall.getArgument(3) or arraySizeArg = funcCall.getArgument(4) and
  // 检查数组大小参数是常量或宏定义
  arraySizeArg instanceof Literal or
  arraySizeArg.toString().matches("%[A-Z_][A-Z0-9_]*%") and
  // 检查是否应该使用array_size - 1而不是array_size
  not arraySizeArg.toString().matches("%- 1%") and
  not arraySizeArg.toString().matches("%_SIZE - 1%") and
  // 检查函数调用中使用了数组参数
  exists(Expr arrayArg |
    arrayArg = funcCall.getArgument(2) or arrayArg = funcCall.getArgument(3) and
    arrayArg.getType() instanceof ArrayType
  )
select funcCall, "Potential out-of-bounds access: array size parameter might need to be decreased by 1"