/**
 * @name CVE-2025-38337
 * @description Detects a data-race on `jh->b_modified` and a potential null-pointer-dereference
 *              of `handle->h_transaction`. In concurrent scenarios, `jh->b_modified` could be
 *              read and written without proper locking, leading to a race condition. Additionally,
 *              `handle->h_transaction` could be dereferenced before being checked for validity
 *              (e.g., via `is_handle_aborted`), leading to a null-pointer-dereference and a system crash.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/jbd2-transaction-race-and-null-deref
 * @tags security
 *       correctness
 *       concurrency
 *       race-condition
 *       null-pointer-dereference
 *       external/cwe/cwe-362
 *       external/cwe/cwe-476
 * @patch-commit af98b0157adf6504fade79b3e6cb260c4ff68e37
 * @source-file fs/jbd2/transaction.c
 * @affected-function jbd2_journal_dirty_metadata
 * @kernel-config CONFIG_JBD2
 * @vulnerability-type race-condition, null-pointer-dereference
 * @patch-diff |
 *     @@ -1509,7 +1509,7 @@ int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)
 *      				jh->b_next_transaction == transaction);
 *      		spin_unlock(&jh->b_state_lock);
 *      	}
 *     -	if (jh->b_modified == 1) {
 *     +	if (data_race(jh->b_modified == 1)) {
 *      		/* If it's in our transaction it must be in BJ_Metadata list. *&#47;
 *      		if (data_race(jh->b_transaction == transaction &&
 *      		    jh->b_jlist != BJ_Metadata)) {
 *     @@ -1528,7 +1528,6 @@ int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)
 *      		goto out;
 *      	}
 *      
 *     -	journal = transaction->t_journal;
 *      	spin_lock(&jh->b_state_lock);
 *      
 *      	if (is_handle_aborted(handle)) {
 *     @@ -1543,6 +1542,8 @@ int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)
 *      		goto out_unlock_bh;
 *      	}
 *      
 *     +	journal = transaction->t_journal;
 *     +
 *      	if (jh->b_modified == 0) {
 *      		/*
 *      		 * This buffer's got modified and becoming part
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38337
 * @remediation 
 */

import cpp

/**
 * 检测空指针解引用：在调用is_handle_aborted()之前对handle->h_transaction的解引用
 */
class HandleTransactionNullPointerDereference extends Expr {
  HandleTransactionNullPointerDereference() {
    // 查找handle->h_transaction的解引用操作
    exists(PointerFieldAccess pfa, Function func |
      func.hasName("jbd2_journal_dirty_metadata") and
      pfa.getEnclosingFunction() = func and
      pfa.getTarget().getName() = "t_journal" and
      pfa.getQualifier().(VariableAccess).getTarget().hasName("transaction") and
      this = pfa
    )
  }
}

/**
 * 检测数据竞争：对jh->b_modified字段的未保护并发访问
 */
class UnsafeModifiedFieldAccess extends Expr {
  UnsafeModifiedFieldAccess() {
    // 查找对jh->b_modified == 1的比较操作
    exists(EQExpr eq, FieldAccess fa, Function func |
      func.hasName("jbd2_journal_dirty_metadata") and
      eq.getEnclosingFunction() = func and
      eq.getLeftOperand() = fa and
      fa.getTarget().hasName("b_modified") and
      fa.getQualifier().(VariableAccess).getTarget().hasName("jh") and
      eq.getRightOperand().(Literal).getValue() = "1" and
      this = eq and
      // 检查这个访问是否没有被data_race()包装或适当的锁保护
      not exists(FunctionCall dataRaceCall |
        dataRaceCall.getTarget().hasName("data_race") and
        dataRaceCall.getAnArgument() = eq
      )
    )
  }
}

from HandleTransactionNullPointerDereference nullDeref, UnsafeModifiedFieldAccess raceAccess
select nullDeref, "潜在的空指针解引用:在调用is_handle_aborted()检查之前访问handle->h_transaction,可能导致内核崩溃",
       raceAccess, "数据竞争风险:对jh->b_modified字段的并发访问未使用data_race()注解或适当的锁保护,可能导致内存损坏"