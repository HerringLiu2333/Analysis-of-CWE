/**
 * @name CVE-2025-38337
 * @description Detects a data-race on `jh->b_modified` and a potential null-pointer-dereference
 *              of `handle->h_transaction`. In concurrent scenarios, `jh->b_modified` could be
 *              read and written without proper locking, leading to a race condition. Additionally,
 *              `handle->h_transaction` could be dereferenced before being checked for validity
 *              (e.g., via `is_handle_aborted`), leading to a null-pointer-dereference and a system crash.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/jbd2-transaction-race-and-null-deref
 * @tags security
 *       correctness
 *       concurrency
 *       race-condition
 *       null-pointer-dereference
 *       external/cwe/cwe-362
 *       external/cwe/cwe-476
 * @patch-commit af98b0157adf6504fade79b3e6cb260c4ff68e37
 * @source-file fs/jbd2/transaction.c
 * @affected-function jbd2_journal_dirty_metadata
 * @kernel-config CONFIG_JBD2
 * @vulnerability-type race-condition, null-pointer-dereference
 * @patch-diff |
 *     @@ -1509,7 +1509,7 @@ int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)
 *      				jh->b_next_transaction == transaction);
 *      		spin_unlock(&jh->b_state_lock);
 *      	}
 *     -	if (jh->b_modified == 1) {
 *     +	if (data_race(jh->b_modified == 1)) {
 *      		/* If it's in our transaction it must be in BJ_Metadata list. *&#47;
 *      		if (data_race(jh->b_transaction == transaction &&
 *      		    jh->b_jlist != BJ_Metadata)) {
 *     @@ -1528,7 +1528,6 @@ int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)
 *      		goto out;
 *      	}
 *      
 *     -	journal = transaction->t_journal;
 *      	spin_lock(&jh->b_state_lock);
 *      
 *      	if (is_handle_aborted(handle)) {
 *     @@ -1543,6 +1542,8 @@ int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)
 *      		goto out_unlock_bh;
 *      	}
 *      
 *     +	journal = transaction->t_journal;
 *     +
 *      	if (jh->b_modified == 0) {
 *      		/*
 *      		 * This buffer's got modified and becoming part
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38337
 * @remediation 
 * @patch-description |
 *     jbd2: fix data-race and null-ptr-deref in jbd2_journal_dirty_metadata()
 *     Since handle->h_transaction may be a NULL pointer, so we should change it
 *     to call is_handle_aborted(handle) first before dereferencing it.
 *     
 *     And the following data-race was reported in my fuzzer:
 *     
 *     ==================================================================
 *     BUG: KCSAN: data-race in jbd2_journal_dirty_metadata / jbd2_journal_dirty_metadata
 *     
 *     write to 0xffff888011024104 of 4 bytes by task 10881 on cpu 1:
 *      jbd2_journal_dirty_metadata+0x2a5/0x770 fs/jbd2/transaction.c:1556
 *      __ext4_handle_dirty_metadata+0xe7/0x4b0 fs/ext4/ext4_jbd2.c:358
 *      ext4_do_update_inode fs/ext4/inode.c:5220 [inline]
 *      ext4_mark_iloc_dirty+0x32c/0xd50 fs/ext4/inode.c:5869
 *      __ext4_mark_inode_dirty+0xe1/0x450 fs/ext4/inode.c:6074
 *      ext4_dirty_inode+0x98/0xc0 fs/ext4/inode.c:6103
 *     ....
 *     
 *     read to 0xffff888011024104 of 4 bytes by task 10880 on cpu 0:
 *      jbd2_journal_dirty_metadata+0xf2/0x770 fs/jbd2/transaction.c:1512
 *      __ext4_handle_dirty_metadata+0xe7/0x4b0 fs/ext4/ext4_jbd2.c:358
 *      ext4_do_update_inode fs/ext4/inode.c:5220 [inline]
 *      ext4_mark_iloc_dirty+0x32c/0xd50 fs/ext4/inode.c:5869
 *      __ext4_mark_inode_dirty+0xe1/0x450 fs/ext4/inode.c:6074
 *      ext4_dirty_inode+0x98/0xc0 fs/ext4/inode.c:6103
 *     ....
 *     
 *     value changed: 0x00000000 -> 0x00000001
 *     ==================================================================
 *     
 *     This issue is caused by missing data-race annotation for jh->b_modified.
 *     Therefore, the missing annotation needs to be added.
 */

import cpp

/**
 * 检测空指针解引用：在调用is_handle_aborted()之前对handle->h_transaction的解引用
 */
class HandleTransactionNullPointerDereference extends Expr {
  HandleTransactionNullPointerDereference() {
    // 查找handle->h_transaction的解引用操作
    exists(PointerFieldAccess pfa, Function func |
      func.hasName("jbd2_journal_dirty_metadata") and
      pfa.getEnclosingFunction() = func and
      pfa.getTarget().getName() = "t_journal" and
      pfa.getQualifier().(VariableAccess).getTarget().hasName("transaction") and
      this = pfa
    )
  }
}

/**
 * 检测数据竞争：对jh->b_modified字段的未保护并发访问
 */
class UnsafeModifiedFieldAccess extends Expr {
  UnsafeModifiedFieldAccess() {
    // 查找对jh->b_modified == 1的比较操作
    exists(EQExpr eq, FieldAccess fa, Function func |
      func.hasName("jbd2_journal_dirty_metadata") and
      eq.getEnclosingFunction() = func and
      eq.getLeftOperand() = fa and
      fa.getTarget().hasName("b_modified") and
      fa.getQualifier().(VariableAccess).getTarget().hasName("jh") and
      eq.getRightOperand().(Literal).getValue() = "1" and
      this = eq and
      // 检查这个访问是否没有被data_race()包装或适当的锁保护
      not exists(FunctionCall dataRaceCall |
        dataRaceCall.getTarget().hasName("data_race") and
        dataRaceCall.getAnArgument() = eq
      )
    )
  }
}

from HandleTransactionNullPointerDereference nullDeref, UnsafeModifiedFieldAccess raceAccess
select nullDeref, "潜在的空指针解引用:在调用is_handle_aborted()检查之前访问handle->h_transaction,可能导致内核崩溃",
       raceAccess, "数据竞争风险:对jh->b_modified字段的并发访问未使用data_race()注解或适当的锁保护,可能导致内存损坏"