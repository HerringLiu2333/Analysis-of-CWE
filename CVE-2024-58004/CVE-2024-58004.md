```markdown
### **## 根因描述**

根因在于错误路径未从 CPU 延迟 QoS 全局列表中移除已注册的请求对象，导致悬挂的链表节点指向已释放内存，从而引发链表损坏。isys_probe() 过程中在出错回退时释放了相关资源，但遗漏了对 isys->pm_qos 的 cpu_latency_qos_remove_request() 调用。由于 pm_qos 的请求节点仍留在全局 plist 中，后续任意对 CPU 延迟 QoS 的更新（例如其他子系统调用 cpu_latency_qos_update_request()）都会在该损坏节点处触发链表一致性检查告警，表现为 list_add corruption。

1. 被修改的代码:
    ```c
    @@ -1133,6 +1133,7 @@ static int isys_probe(struct auxiliary_device *auxdev,
     free_fw_msg_bufs:
     	free_fw_msg_bufs(isys);
     out_remove_pkg_dir_shared_buffer:
    +	cpu_latency_qos_remove_request(&isys->pm_qos);
     	if (!isp->secure_mode)
     		ipu6_cpd_free_pkg_dir(adev);
     remove_shared_buffer:
    ```
    - 修改原因:
        - 旧代码的缺陷:
            1. 错误路径未调用 cpu_latency_qos_remove_request() 将请求从全局 QoS 列表移除。
            2. 之后释放 isys 结构导致 QoS 列表中遗留悬挂节点，触发链表损坏（list_add corruption）和告警。
        - 新代码的修复:
            1. 在错误回退路径添加 cpu_latency_qos_remove_request(&isys->pm_qos)，先从全局列表安全摘除请求。
            2. 避免对已释放内存的后续访问，消除链表损坏与潜在崩溃风险。

### **## 总结**

- 漏洞类型: 资源清理不完整/链表状态破坏（悬挂节点导致的 list corruption）
- 根本缺陷: 错误路径遗漏 QoS 请求移除，导致已释放对象仍在全局列表中
- 修复原理: 在回退路径补充 cpu_latency_qos_remove_request()，确保在释放内存前从全局 QoS 列表删除请求，防止后续更新触发链表损坏
```