/**
 * @name CVE-2024-58086
 * @description In drm/v3d, destroying a performance monitor that is currently active
 *              (v3d->active_perfmon) did not stop it first. This left a stale
 *              active_perfmon pointer and could lead to undefined behavior/instability.
 *              The fix stops the active perfmon before it is destroyed in
 *              v3d_perfmon_destroy_ioctl().
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/drm-v3d-active-perfmon-stop-before-destroy
 * @tags
 *       correctness
 *       reliability
 *       gpu
 *       drm
 *       v3d
 *       resource-lifecycle
 *       stale-pointer
 * @patch-commit f8805b12f477bd964e2820a87921c7b58cc2dee3
 * @source-file drivers/gpu/drm/v3d/v3d_perfmon.c
 * @affected-function v3d_perfmon_destroy_ioctl
 * @vulnerability-type lifecycle-stale-pointer
 * @patch-diff |
 *     diff --git a/drivers/gpu/drm/v3d/v3d_perfmon.c b/drivers/gpu/drm/v3d/v3d_perfmon.c
 *     index ecf06e8e9fbccb..c49abb90954d49 100644
 *     --- a/drivers/gpu/drm/v3d/v3d_perfmon.c
 *     +++ b/drivers/gpu/drm/v3d/v3d_perfmon.c
 *     @@ -384,6 +384,7 @@ int v3d_perfmon_destroy_ioctl(struct drm_device *dev, void *data,
 *      {
 *      	struct v3d_file_priv *v3d_priv = file_priv->driver_priv;
 *      	struct drm_v3d_perfmon_destroy *req = data;
 *     +	struct v3d_dev *v3d = v3d_priv->v3d;
 *      	struct v3d_perfmon *perfmon;
 *      
 *      	mutex_lock(&v3d_priv->perfmon.lock);
 *     @@ -393,6 +394,10 @@ int v3d_perfmon_destroy_ioctl(struct drm_device *dev, void *data,
 *      	if (!perfmon)
 *      		return -EINVAL;
 *      
 *     +	/* If the active perfmon is being destroyed, stop it first &#47;
 *     +	if (perfmon == v3d->active_perfmon)
 *     +		v3d_perfmon_stop(v3d, perfmon, false);
 *     +
 *      	v3d_perfmon_put(perfmon);
 *      
 *      	return 0;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f8805b12f477bd964e2820a87921c7b58cc2dee3
 * @remediation When destroying a perfmon, check if it is the active one and stop it first
 *              (e.g., call v3d_perfmon_stop()), ensuring the active pointer is cleared and
 *              hardware is quiesced before releasing the object to avoid stale references.
 */

import cpp

/*
 * 检测V3D驱动中的性能监视器销毁问题
 * 该查询用于识别在销毁性能监视器时未停止活动性能监视器的情况
 * 这可能导致v3d->active_perfmon指针悬空，引发未定义行为和不稳定问题
 * This query identifies issues where active performance monitor is not stopped during destruction
 * which may leave v3d->active_perfmon pointer stale, causing undefined behavior and instability
 */

// 检查是否为v3d_perfmon_destroy_ioctl函数
// Check if it's v3d_perfmon_destroy_ioctl function
predicate isV3dPerfmonDestroyIoctlFunction(Function f) {
  f.getName() = "v3d_perfmon_destroy_ioctl"
}

// 检查是否为v3d_perfmon_stop函数调用
// Check if it's v3d_perfmon_stop function call
predicate isV3dPerfmonStopCall(FunctionCall fc) {
  fc.getTarget().getName() = "v3d_perfmon_stop"
}

// 检查是否为活动性能监视器检查
// Check for active performance monitor check
predicate hasActivePerfmonCheck(Function f) {
  exists(IfStmt ifStmt |
    ifStmt.getEnclosingFunction() = f and
    ifStmt.getCondition().toString().matches("%perfmon == v3d->active_perfmon%") and
    exists(FunctionCall stopCall |
      stopCall = ifStmt.getThen().getAChild() and
      isV3dPerfmonStopCall(stopCall)
    )
  )
}

from
  Function f
where
  // 限制在v3d_perfmon_destroy_ioctl函数内
  isV3dPerfmonDestroyIoctlFunction(f) and
  // 没有活动性能监视器检查
  not hasActivePerfmonCheck(f)
select
  f,
  "Potential stability issue: Missing active performance monitor check in v3d_perfmon_destroy_ioctl(), may leave stale active_perfmon pointer"