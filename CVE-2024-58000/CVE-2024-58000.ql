/**
 * @name CVE-2024-58000
 * @description io_uring reg-wait used a user-controlled offset to index into a kernel
 *              array of registered wait arguments. Without speculation barriers, this
 *              creates a Spectre-v1 gadget where a malicious offset could transiently
 *              access data beyond bounds. The fix clamps the offset with
 *              array_index_nospec(offset, ctx->cq_wait_size - size), i.e., truncates
 *              the usable region by the struct size and blocks speculative out-of-bounds
 *              indexing.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/io-uring-reg-wait-nospec
 * @tags
 *       io_uring
 *       spectre-v1
 *       speculation
 *       hardening
 *       bounds-check
 * @patch-commit 2a6de94df7bfa76d9850443547e7b3333f63a16a
 * @source-file io_uring/io_uring.c
 * @affected-function io_get_ext_arg_reg
 * @vulnerability-type speculative-out-of-bounds
 * @patch-diff |
 *     diff --git a/io_uring/io_uring.c b/io_uring/io_uring.c
 *     index 4758f1ba902b94..d062c5c69211ba 100644
 *     --- a/io_uring/io_uring.c
 *     +++ b/io_uring/io_uring.c
 *     @@ -3233,6 +3233,7 @@ static struct io_uring_reg_wait *io_get_ext_arg_reg(struct io_ring_ctx *ctx,
 *      		     end > ctx->cq_wait_size))
 *      		return ERR_PTR(-EFAULT);
 *      
 *     +	offset = array_index_nospec(offset, ctx->cq_wait_size - size);
 *      	return ctx->cq_wait_arg + offset;
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=2a6de94df7bfa76d9850443547e7b3333f63a16a  
 * @remediation Use array_index_nospec() to clamp user-supplied indices and prevent speculative
 *              out-of-bounds accesses. Ensure the limit accounts for the structure size
 *              (ctx->cq_wait_size - sizeof(struct io_uring_reg_wait)) so that the computed
 *              end offset cannot exceed the region bounds.
 * @patch-description |
 *  io_uring: prevent reg-wait speculations
 *  [ Upstream commit 29b95ac917927ce9f95bf38797e16333ecb489b1 ]
 *  
 *  With *ENTER_EXT_ARG_REG instead of passing a user pointer with arguments
 *  for the waiting loop the user can specify an offset into a pre-mapped
 *  region of memory, in which case the
 *  [offset, offset + sizeof(io_uring_reg_wait)) will be intepreted as the
 *  argument.
 *
 *  As we address a kernel array using a user given index, it'd be a subject
 *  to speculation type of exploits. Use array_index_nospec() to prevent
 *  that. Make sure to pass not the full region size but truncate by the
 *  maximum offset allowed considering the structure size.
 *
 *  Fixes: d617b3147d54c ("io_uring: restore back registered wait arguments")
 *  Fixes: aa00f67adc2c0 ("io_uring: add support for fixed wait regions")
 */


import cpp
to speculation type of exploits. Use array_index_nospec() to prevent
that. Make sure to pass not the full region size but truncate by the
maximum offset allowed considering the structure size.

Fixes: d617b3147d54c ("io_uring: restore back registered wait arguments")
Fixes: aa00f67adc2c0 ("io_uring: add support for fixed wait regions")
 */


import cpp

from ArrayExpr arrayAccess, Expr indexExpr, Expr arrayBase
where
  // 查找数组访问操作
  arrayAccess.getArrayBase() = arrayBase and
  arrayAccess.getArrayOffset() = indexExpr and
  // 检查索引表达式类型是否为整数类型
  indexExpr.getType().getUnderlyingType() instanceof IntegralType and
  // 检查是否缺少array_index_nospec保护
  not exists(FunctionCall nospecCall |
    nospecCall.getTarget().getName() = "array_index_nospec" and
    nospecCall.getArgument(0) = indexExpr and
    nospecCall.getEnclosingStmt().getParent*() = arrayAccess.getEnclosingStmt().getParent*()
  ) and
  // 确保这是内核代码（可选过滤）
  arrayAccess.getFile().getBaseName().matches("%.c")
select arrayAccess, "Potential speculation vulnerability: missing array_index_nospec protection for user-controlled index"