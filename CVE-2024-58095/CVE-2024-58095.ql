/**
 * @name CVE-2024-58095
 * @description JFS extent paths extAlloc() and extRecord() missed a read-only check and could
 *  call txBeginAnon() on a read-only mounted filesystem. This may start transactional
 *  paths without a valid log, leading to errors or crashes (e.g., NULL dereference in
 *  transaction end paths). The fix adds isReadOnly(ip) checks before txBeginAnon() and
 *  returns -EIO with a jfs_error() message to prevent writes on RO mounts.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/jfs-extent-missing-ro-check
 * @tags
 *  correctness
 *  reliability
 *  filesystem
 *  jfs
 *  read-only
 *  null-dereference
 *  external/cwe/cwe-476
 *  external/cwe/cwe-754
 * @patch-commit 15469c408af2d7a52fb186a92f2f091b0f13b1fb
 * @source-file fs/jfs/jfs_extent.c
 * @affected-function extAlloc
 * @affected-function extRecord
 * @vulnerability-type missing-state-check
 * @patch-diff |
 *  diff --git a/fs/jfs/jfs_extent.c b/fs/jfs/jfs_extent.c
 *  index 63d21822d309be…46529bcc8297ea 100644
 *  --- a/fs/jfs/jfs_extent.c
 *  +++ b/fs/jfs/jfs_extent.c
 *  @@ -74,6 +74,11 @@ extAlloc(struct inode ip, s64 xlen, s64 pno, xad_t * xp, bool abnr)
 *    int rc;
 *    int xflag;
 *
 *  + if (isReadOnly(ip)) {
 *  + jfs_error(ip->i_sb, “read-only filesystem\n”);
 *  + return -EIO;
 *  + }
 *  +
 *    / This blocks if we are low on resources &#47;
 *    txBeginAnon(ip->i_sb);
 *
 *  @@ -253,6 +258,11 @@ int extRecord(struct inode *ip, xad_t * xp)
 *    {
 *    int rc;
 *
 *  + if (isReadOnly(ip)) {
 *  + jfs_error(ip->i_sb, “read-only filesystem\n”);
 *  + return -EIO;
 *  + }
 *  +
 *    txBeginAnon(ip->i_sb);
 *
 *    mutex_lock(&JFS_IP(ip)->commit_mutex);
 * @references https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=15469c408af2d7a52fb186a92f2f091b0f13b1fb
 * @remediation Before starting any transaction (e.g., txBeginAnon) in JFS extent operations,
 *  check the inode/filesystem read-only state with isReadOnly(ip) and bail out via
 *  an error path (e.g., return -EIO and log with jfs_error). Avoid initiating write
 *  transactions on read-only mounts to prevent NULL log dereferences and data structure
 *  corruption.
 * @patch-description |
 *  jfs: add check read-only before txBeginAnon() call
 *  [ Upstream commit 0176e69743ecc02961f2ae1ea42439cd2bf9ed58 ]
 *  
 *  Added a read-only check before calling `txBeginAnon` in `extAlloc`
 *  and `extRecord`. This prevents modification attempts on a read-only
 *  mounted filesystem, avoiding potential errors or crashes.
 *  
 *  Call trace:
 *   txBeginAnon+0xac/0x154
 *   extAlloc+0xe8/0xdec fs/jfs/jfs_extent.c:78
 *   jfs_get_block+0x340/0xb98 fs/jfs/inode.c:248
 *   __block_write_begin_int+0x580/0x166c fs/buffer.c:2128
 *   __block_write_begin fs/buffer.c:2177 [inline]
 *   block_write_begin+0x98/0x11c fs/buffer.c:2236
 *   jfs_write_begin+0x44/0x88 fs/jfs/inode.c:299
 *  
 *  Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
 */

import cpp

/*
 * 检测JFS文件系统中的只读检查漏洞
 * 该查询用于识别在extAlloc和extRecord函数中调用txBeginAnon之前未检查只读模式的情况
 * 这可能导致在只读文件系统上进行事务操作，引发错误或崩溃
 * This query identifies missing read-only check before txBeginAnon calls in extAlloc and extRecord functions
 * which may cause transaction operations on read-only filesystem, leading to errors or crashes
 */

// 检查是否为extAlloc或extRecord函数
// Check if it's extAlloc or extRecord function
predicate isTargetFunction(Function f) {
  f.getName() = "extAlloc" or
  f.getName() = "extRecord"
}

// 检查是否为txBeginAnon函数调用
// Check if it's txBeginAnon function call
predicate isTxBeginAnonCall(FunctionCall fc) {
  fc.getTarget().getName() = "txBeginAnon"
}

// 检查是否为isReadOnly函数调用
// Check if it's isReadOnly function call
predicate isIsReadOnlyCall(FunctionCall fc) {
  fc.getTarget().getName() = "isReadOnly"
}

// 检查是否有只读检查
// Check for read-only check
predicate hasReadOnlyCheckBeforeTxBegin(FunctionCall txCall) {
  exists(IfStmt ifStmt |
    ifStmt.getEnclosingFunction() = txCall.getEnclosingFunction() and
    ifStmt.getLocation().getStartLine() < txCall.getLocation().getStartLine() and
    isIsReadOnlyCall(ifStmt.getCondition().(FunctionCall)) and
    exists(ReturnStmt returnStmt |
      returnStmt = ifStmt.getThen().getAChild() and
      returnStmt.getExpr().getValue().toInt() = -5
    )
  )
}

from
  Function f,
  FunctionCall txCall  // txBeginAnon调用
where
  // 限制在目标函数内
  isTargetFunction(f) and
  txCall.getEnclosingFunction() = f and
  // 查找txBeginAnon调用
  isTxBeginAnonCall(txCall) and
  // 在txBeginAnon调用之前没有只读检查
  not hasReadOnlyCheckBeforeTxBegin(txCall)
select
  txCall,
  "Potential read-only filesystem issue: Missing isReadOnly(ip) check before txBeginAnon() call, may cause transaction operations on read-only filesystem"
