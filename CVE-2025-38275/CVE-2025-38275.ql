/**
 * @name CVE-2025-38275
 * @description The function `devm_ioremap` can return a NULL pointer on failure. This value is
 *              returned directly by `qmp_usb_iomap`. The caller only checks for error pointers using
 *              `IS_ERR()`, which does not detect NULL. This allows the NULL pointer to bypass the
 *              error check, leading to a potential NULL pointer dereference.
 * @kind path-problem
 * @problem.severity error
 * @precision high
 * @id cpp/improper-null-check-qmp-usb
 * @tags security
 *       correctness
 *       error-handling
 *       external/cwe/cwe-476
 * @patch-commit d14402a38c2d868cacb1facaf9be908ca6558e59
 * @source-file drivers/phy/qualcomm/phy-qcom-qmp-usb.c
 * @affected-function qmp_usb_iomap
 * @kernel-config CONFIG_PHY_QCOM_QMP_USB
 * @vulnerability-type null-pointer-dereference
 * @patch-diff |
 *      @@ -2106,12 +2106,16 @@ static void __iomem *qmp_usb_iomap(struct device *dev, struct device_node *np,
 *      					int index, bool exclusive)
 *      {
 *      	struct resource res;
 *     +	void __iomem *mem;
 *      
 *      	if (!exclusive) {
 *      		if (of_address_to_resource(np, index, &res))
 *      			return IOMEM_ERR_PTR(-EINVAL);
 *      
 *     -		return devm_ioremap(dev, res.start, resource_size(&res));
 *     +		mem = devm_ioremap(dev, res.start, resource_size(&res));
 *     +		if (!mem)
 *     +			return IOMEM_ERR_PTR(-ENOMEM);
 *     +		return mem;
 *      	}
 *      
 *      	return devm_of_iomap(dev, np, index, NULL);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38275
 * @remediation
 * @patch-description |
 *     phy: qcom-qmp-usb: Fix an NULL vs IS_ERR() bug
 *     The qmp_usb_iomap() helper function currently returns the raw result of
 *     devm_ioremap() for non-exclusive mappings. Since devm_ioremap() may return
 *     a NULL pointer and the caller only checks error pointers with IS_ERR(),
 *     NULL could bypass the check and lead to an invalid dereference.
 *     
 *     Fix the issue by checking if devm_ioremap() returns NULL. When it does,
 *     qmp_usb_iomap() now returns an error pointer via IOMEM_ERR_PTR(-ENOMEM),
 *     ensuring safe and consistent error handling.
 */
import cpp
import semmle.code.cpp.dataflow.new.DataFlow

/**
 * 定义一个数据流分析的配置模块。
 * 它描述了数据流的起点 (source)、终点 (sink) 和净化器 (sanitizer)。
 */
module QcomPhyUsbConfig implements DataFlow::ConfigSig {
  /**
   * 定义数据流的源头 (Source):`devm_ioremap` 函数的返回值。
   */
  predicate isSource(DataFlow::Node source) {
    exists(FunctionCall call |
      call.getTarget().hasGlobalOrStdName("devm_ioremap") and
      source.asExpr() = call
    )
  }

  /**
   * 定义数据流的汇点 (Sink)：漏洞函数 `qmp_usb_iomap` 的 return 语句。
   */
  predicate isSink(DataFlow::Node sink) {
    exists(ReturnStmt ret, Function func |
      func.getName() = "qmp_usb_iomap" and
      func.getFile().getRelativePath() = "phy-qcom-qmp-usb.c" and
      ret.getEnclosingFunction() = func and
      sink.asExpr() = ret.getExpr()
    )
  }

//   /**
//    * 定义净化器 (Sanitizer)：任何形式的空指针检查。
//    * 如果数据流经过了净化器，它就被认为是安全的，数据流会在此处停止。
//    */
//   predicate isBarrier(DataFlow::Node sanitizer) {
//     exists(Expr e | e = sanitizer.asExpr() |
//       // 模式 1: 指针被用作控制流的条件，例如 `if (ptr)` 或 `while (!ptr)`
//       // `ControlCondition` 抽象了所有这类用法。
//       e.getAUse() instanceof ControlCondition
//       or
//       // 模式 2: 指针与 NULL (常量 0) 进行比较，例如 `ptr == NULL` 或 `ptr != 0`
//       exists(EqualityOperation eq |
//         eq.getAnOperand() = e and
//         eq.getAnOperand().isConstantZero()
//       )
//     )
//   }
}

// 实例化一个全局数据流分析模块
module QcomPhyUsbFlow = DataFlow::Global<QcomPhyUsbConfig>;

// 导入路径图以进行查询
import QcomPhyUsbFlow::PathGraph

// from-where-select 子句，用于查找从源头到汇点的所有未被净化的路径
from QcomPhyUsbFlow::PathNode source, QcomPhyUsbFlow::PathNode sink
where QcomPhyUsbFlow::flowPath(source, sink)
select sink.getNode(), source, sink,
  source.getNode(), "devm_ioremap 调用"