import cpp
import semmle.code.cpp.dataflow.new.DataFlow

/**
 * 定义一个数据流分析的配置模块。
 * 它描述了数据流的起点 (source)、终点 (sink) 和净化器 (sanitizer)。
 */
module QcomPhyUsbConfig implements DataFlow::ConfigSig {
  /**
   * 定义数据流的源头 (Source):`devm_ioremap` 函数的返回值。
   */
  predicate isSource(DataFlow::Node source) {
    exists(FunctionCall call |
      call.getTarget().hasGlobalOrStdName("devm_ioremap") and
      source.asExpr() = call
    )
  }

  /**
   * 定义数据流的汇点 (Sink)：漏洞函数 `qmp_usb_iomap` 的 return 语句。
   */
  predicate isSink(DataFlow::Node sink) {
    exists(ReturnStmt ret, Function func |
      func.getName() = "qmp_usb_iomap" and
      func.getFile().getRelativePath() = "phy-qcom-qmp-usb.c" and
      ret.getEnclosingFunction() = func and
      sink.asExpr() = ret.getExpr()
    )
  }

//   /**
//    * 定义净化器 (Sanitizer)：任何形式的空指针检查。
//    * 如果数据流经过了净化器，它就被认为是安全的，数据流会在此处停止。
//    */
//   predicate isBarrier(DataFlow::Node sanitizer) {
//     exists(Expr e | e = sanitizer.asExpr() |
//       // 模式 1: 指针被用作控制流的条件，例如 `if (ptr)` 或 `while (!ptr)`
//       // `ControlCondition` 抽象了所有这类用法。
//       e.getAUse() instanceof ControlCondition
//       or
//       // 模式 2: 指针与 NULL (常量 0) 进行比较，例如 `ptr == NULL` 或 `ptr != 0`
//       exists(EqualityOperation eq |
//         eq.getAnOperand() = e and
//         eq.getAnOperand().isConstantZero()
//       )
//     )
//   }
}

// 实例化一个全局数据流分析模块
module QcomPhyUsbFlow = DataFlow::Global<QcomPhyUsbConfig>;

// 导入路径图以进行查询
import QcomPhyUsbFlow::PathGraph

// from-where-select 子句，用于查找从源头到汇点的所有未被净化的路径
from QcomPhyUsbFlow::PathNode source, QcomPhyUsbFlow::PathNode sink
where QcomPhyUsbFlow::flowPath(source, sink)
select sink.getNode(), source, sink,
  source.getNode(), "devm_ioremap 调用"