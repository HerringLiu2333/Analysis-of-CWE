/**
 * @name CVE-2025-38307
 * @description Detects missing validation of array length returned by parse_int_array() before access.
 *              The first element of the returned array stores its length. If it is 0,
 *              any manipulation beyond the element at index 0, such as accessing array[1],
 *              can lead to a null-ptr-dereference or out-of-bounds read, causing a denial of service.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/missing-array-length-check
 * @tags security
 *       correctness
 *       external/cwe/cwe-129
 *       external/cwe/cwe-476
 * @patch-commit 93e246b6769bdacb09cfff4ea0f00fe5ab4f0d7a
 * @source-file sound/soc/intel/avs/debugfs.c
 * @affected-function trace_control_write
 * @kernel-config CONFIG_SND_SOC_INTEL_AVS
 * @vulnerability-type improper-input-validation
 * @patch-diff |
 *     @@ -373,7 +373,10 @@ static ssize_t trace_control_write(struct file *file, const char __user *from, s
 *      		return ret;
 *      
 *      	num_elems = *array;
 *     -	resource_mask = array[1];
 *     +	if (!num_elems) {
 *     +		ret = -EINVAL;
 *     +		goto free_array;
 *     +	}
 *      
 *      	/*
 *      	 * Disable if just resource mask is provided - no log priority flags.
 *     @@ -381,6 +384,7 @@ static ssize_t trace_control_write(struct file *file, const char __user *from, s
 *      	 * Enable input format:   mask, prio1, .., prioN
 *      	 * Where 'N' equals number of bits set in the 'mask'.
 *      	 *&#47;
 *     +	resource_mask = array[1];
 *      	if (num_elems == 1) {
 *      		ret = disable_logs(adev, resource_mask);
 *      	} else {
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38307
 * @remediation 
 * @patch-description |
 *     ASoC: Intel: avs: Verify content returned by parse_int_array()
 *     The first element of the returned array stores its length. If it is 0,
 *     any manipulation beyond the element at index 0 ends with null-ptr-deref.
 */

import cpp
import semmle.code.cpp.dataflow.TaintTracking
import semmle.code.cpp.dataflow.DataFlow

// 定义array[1]的访问
class ResourceMaskAccess extends ArrayExpr {
  ResourceMaskAccess() {
    // 确保是访问array[1]
    exists(Literal i | 
      i = this.getArrayOffset() and
      i.getValue().toInt() = 1
    )
  }
}

// 定义num_elems的零值检查
class NumElemsCheck extends IfStmt {
  Variable numElems;
  
  NumElemsCheck() {
    // 匹配 if(!num_elems) 模式
    exists(NotExpr ne |
      ne = this.getCondition() and
      numElems = ne.getOperand().(VariableAccess).getTarget() and
      numElems.getName() = "num_elems"
    )
  }
}

from ResourceMaskAccess access, Function f
where
  // 在trace_control_write函数中
  f = access.getEnclosingFunction() and
  f.getName() = "trace_control_write" and
  f.getFile().getBaseName() = "debugfs.c" and
  
  // array[1]的访问没有前置的num_elems检查
  not exists(NumElemsCheck check |
    check.getEnclosingFunction() = f and
    check.getLocation().getStartLine() < access.getLocation().getStartLine()
  )

select access, 
  "在访问array[1]前未检查num_elems是否为0，可能导致越界访问。应添加 if(!num_elems) 检查"