/**
 * @name CVE-2025-38488
 * @description Detects a use-after-free vulnerability in the `crypt_message` function.
 *              The function incorrectly assumes that all crypto operations are synchronous. When an asynchronous
 *              hardware crypto accelerator is utilized, the function may free a request buffer before the
 *              asynchronous operation completes. This premature deallocation leads to a use-after-free condition
 *              when the hardware driver subsequently attempts to access the freed memory.
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/use-after-free
 * @tags security
 *       correctness
 *       concurrency
 *       memory-management
 *       external/cwe/cwe-416
 *       external/cwe/cwe-362
 * @patch-commit b220bed63330c0e1733dc06ea8e75d5b9962b6b6
 * @source-file fs/smb/client/smb2ops.c
 * @affected-function crypt_message
 * @kernel-config CONFIG_CIFS
 * @vulnerability-type use-after-free
 * @patch-diff |
 *      @@ -4316,6 +4316,7 @@ crypt_message(struct TCP_Server_Info *server, int num_rqst,
 *       	u8 key[SMB3_ENC_DEC_KEY_SIZE];
 *       	struct aead_request *req;
 *       	u8 *iv;
 *      +	DECLARE_CRYPTO_WAIT(wait);
 *       	unsigned int crypt_len = le32_to_cpu(tr_hdr->OriginalMessageSize);
 *       	void *creq;
 *       	size_t sensitive_size;
 *      @@ -4366,7 +4367,11 @@ crypt_message(struct TCP_Server_Info *server, int num_rqst,
 *       	aead_request_set_crypt(req, sg, sg, crypt_len, iv);
 *       	aead_request_set_ad(req, assoc_data_len);
 *      
 *      -	rc = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
 *      +	aead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 *      +				  crypto_req_done, &wait);
 *      +
 *      +	rc = crypto_wait_req(enc ? crypto_aead_encrypt(req)
 *      +				: crypto_aead_decrypt(req), &wait);
 *      
 *       	if (!rc && enc)
 *       		memcpy(&tr_hdr->Signature, sign, SMB2_SIGNATURE_SIZE);
 * @references https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-38488
 * @remediation
 */

import cpp
import semmle.code.cpp.dataflow.DataFlow
import semmle.code.cpp.controlflow.Guards

/**
 * 表示加密相关的函数调用
 */
class CryptoFunction extends FunctionCall {
  CryptoFunction() {
    this.getTarget().getName().matches("crypto_aead_%") or
    this.getTarget().getName().matches("crypto_aead_encrypt") or
    this.getTarget().getName().matches("crypto_aead_decrypt")
  }
}

/**
 * 表示内存释放函数调用
 */
class MemoryFreeCall extends FunctionCall {
  MemoryFreeCall() {
    this.getTarget().getName() in ["kvfree_sensitive", "kfree", "kvfree", "free"]
  }
}

/**
 * 表示等待异步操作完成的函数调用
 */
class CryptoWaitCall extends FunctionCall {
  CryptoWaitCall() {
    this.getTarget().getName().matches("crypto_wait_req") or
    this.getTarget().getName().matches("aead_request_set_callback")
  }
}

/**
 * 检查是否存在EINPROGRESS返回值检查
 */
predicate hasEinprogressCheck(Function f, CryptoFunction cryptoCall) {
  exists(IfStmt ifStmt, ComparisonOperation comp, UnaryMinusExpr minus, Literal literal |
    ifStmt.getEnclosingFunction() = f and
    ifStmt.getCondition() = comp and
    comp.getAnOperand() = minus and
    minus.getOperand() = literal and
    literal.getValue() = "EINPROGRESS" and
    cryptoCall.getEnclosingFunction() = f
  )
}

/**
 * 检查函数中是否存在异步等待机制
 */
predicate hasAsyncWaitMechanism(Function f, CryptoFunction cryptoCall) {
  exists(CryptoWaitCall waitCall |
    waitCall.getEnclosingFunction() = f and
    cryptoCall.getEnclosingFunction() = f
  )
}

/**
 * 检查变量是否在加密操作和内存释放之间有数据流关系
 */
predicate cryptoRequestMemoryFlow(Variable v, CryptoFunction cryptoCall, MemoryFreeCall freeCall) {
  exists(Expr cryptoArg, Expr freeArg |
    cryptoArg = cryptoCall.getAnArgument() and
    freeArg = freeCall.getAnArgument() and
    (
      // 直接使用同一个变量
      cryptoArg.(VariableAccess).getTarget() = v and
      freeArg.(VariableAccess).getTarget() = v
      or
      // 通过字段访问使用同一个结构体
      exists(FieldAccess fa1, FieldAccess fa2 |
        cryptoArg = fa1 and freeArg = fa2 and
        fa1.getQualifier().(VariableAccess).getTarget() = v and
        fa2.getQualifier().(VariableAccess).getTarget() = v
      )
      or
      // 使用相关的内存区域
      exists(Variable baseVar |
        cryptoArg.(VariableAccess).getTarget() = baseVar and
        freeArg.(VariableAccess).getTarget() = v and
        baseVar.getType() instanceof PointerType and
        v.getType() instanceof PointerType
      )
    )
  )
}

/**
 * 检查加密调用和内存释放之间的控制流顺序
 */
predicate cryptoCallBeforeFree(CryptoFunction cryptoCall, MemoryFreeCall freeCall) {
  exists(ControlFlowNode cryptoNode, ControlFlowNode freeNode |
    cryptoNode.getASuccessor*() = freeNode and
    cryptoCall = cryptoNode and
    freeCall = freeNode
  )
}

from 
  Function f, 
  CryptoFunction cryptoCall, 
  MemoryFreeCall freeCall, 
  Variable memVar
where
  // 加密调用和内存释放在同一个函数中
  cryptoCall.getEnclosingFunction() = f and
  freeCall.getEnclosingFunction() = f and
  
  // 存在内存使用的数据流关系
  cryptoRequestMemoryFlow(memVar, cryptoCall, freeCall) and
  
  // 加密调用在内存释放之前
  cryptoCallBeforeFree(cryptoCall, freeCall) and
  
  // 没有检查EINPROGRESS返回值
  not hasEinprogressCheck(f, cryptoCall) and
  
  // 没有异步等待机制
  not hasAsyncWaitMechanism(f, cryptoCall) and
  
  // 排除明显的同步加密场景（函数名包含sync等关键字）
  not f.getName().matches("%sync%") and
  not f.getName().matches("%blocking%")

select 
  cryptoCall, 
  "潜在的Use-After-Free漏洞：异步加密操作 $@ 后立即释放内存 $@，" +
  "当硬件加速器返回-EINPROGRESS时可能导致悬空指针访问。" +
  "建议使用crypto_wait_req()等待操作完成或检查返回值。",
  cryptoCall, cryptoCall.getTarget().getName(),
  freeCall, "在此处释放内存"