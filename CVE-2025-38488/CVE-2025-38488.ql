/**
 * @name 异步加密操作中的Use-After-Free漏洞检测
 * @description 检测在异步加密操作后立即释放内存缓冲区而未等待操作完成的情况，
 *              这可能导致硬件加密驱动访问已释放的内存造成Use-After-Free漏洞
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/async-crypto-use-after-free
 * @tags security
 *       correctness
 *       memory-management
 *       crypto
 */

import cpp
import semmle.code.cpp.dataflow.DataFlow
import semmle.code.cpp.controlflow.Guards

/**
 * 表示加密相关的函数调用
 */
class CryptoFunction extends FunctionCall {
  CryptoFunction() {
    this.getTarget().getName().matches("crypto_aead_%") or
    this.getTarget().getName().matches("crypto_aead_encrypt") or
    this.getTarget().getName().matches("crypto_aead_decrypt")
  }
}

/**
 * 表示内存释放函数调用
 */
class MemoryFreeCall extends FunctionCall {
  MemoryFreeCall() {
    this.getTarget().getName() in ["kvfree_sensitive", "kfree", "kvfree", "free"]
  }
}

/**
 * 表示等待异步操作完成的函数调用
 */
class CryptoWaitCall extends FunctionCall {
  CryptoWaitCall() {
    this.getTarget().getName().matches("crypto_wait_req") or
    this.getTarget().getName().matches("aead_request_set_callback")
  }
}

/**
 * 检查是否存在EINPROGRESS返回值检查
 */
predicate hasEinprogressCheck(Function f, CryptoFunction cryptoCall) {
  exists(IfStmt ifStmt, ComparisonOperation comp, UnaryMinusExpr minus, Literal literal |
    ifStmt.getEnclosingFunction() = f and
    ifStmt.getCondition() = comp and
    comp.getAnOperand() = minus and
    minus.getOperand() = literal and
    literal.getValue() = "EINPROGRESS" and
    cryptoCall.getEnclosingFunction() = f
  )
}

/**
 * 检查函数中是否存在异步等待机制
 */
predicate hasAsyncWaitMechanism(Function f, CryptoFunction cryptoCall) {
  exists(CryptoWaitCall waitCall |
    waitCall.getEnclosingFunction() = f and
    cryptoCall.getEnclosingFunction() = f
  )
}

/**
 * 检查变量是否在加密操作和内存释放之间有数据流关系
 */
predicate cryptoRequestMemoryFlow(Variable v, CryptoFunction cryptoCall, MemoryFreeCall freeCall) {
  exists(Expr cryptoArg, Expr freeArg |
    cryptoArg = cryptoCall.getAnArgument() and
    freeArg = freeCall.getAnArgument() and
    (
      // 直接使用同一个变量
      cryptoArg.(VariableAccess).getTarget() = v and
      freeArg.(VariableAccess).getTarget() = v
      or
      // 通过字段访问使用同一个结构体
      exists(FieldAccess fa1, FieldAccess fa2 |
        cryptoArg = fa1 and freeArg = fa2 and
        fa1.getQualifier().(VariableAccess).getTarget() = v and
        fa2.getQualifier().(VariableAccess).getTarget() = v
      )
      or
      // 使用相关的内存区域
      exists(Variable baseVar |
        cryptoArg.(VariableAccess).getTarget() = baseVar and
        freeArg.(VariableAccess).getTarget() = v and
        baseVar.getType() instanceof PointerType and
        v.getType() instanceof PointerType
      )
    )
  )
}

/**
 * 检查加密调用和内存释放之间的控制流顺序
 */
predicate cryptoCallBeforeFree(CryptoFunction cryptoCall, MemoryFreeCall freeCall) {
  exists(ControlFlowNode cryptoNode, ControlFlowNode freeNode |
    cryptoNode.getASuccessor*() = freeNode and
    cryptoCall = cryptoNode and
    freeCall = freeNode
  )
}

from 
  Function f, 
  CryptoFunction cryptoCall, 
  MemoryFreeCall freeCall, 
  Variable memVar
where
  // 加密调用和内存释放在同一个函数中
  cryptoCall.getEnclosingFunction() = f and
  freeCall.getEnclosingFunction() = f and
  
  // 存在内存使用的数据流关系
  cryptoRequestMemoryFlow(memVar, cryptoCall, freeCall) and
  
  // 加密调用在内存释放之前
  cryptoCallBeforeFree(cryptoCall, freeCall) and
  
  // 没有检查EINPROGRESS返回值
  not hasEinprogressCheck(f, cryptoCall) and
  
  // 没有异步等待机制
  not hasAsyncWaitMechanism(f, cryptoCall) and
  
  // 排除明显的同步加密场景（函数名包含sync等关键字）
  not f.getName().matches("%sync%") and
  not f.getName().matches("%blocking%")

select 
  cryptoCall, 
  "潜在的Use-After-Free漏洞：异步加密操作 $@ 后立即释放内存 $@，" +
  "当硬件加速器返回-EINPROGRESS时可能导致悬空指针访问。" +
  "建议使用crypto_wait_req()等待操作完成或检查返回值。",
  cryptoCall, cryptoCall.getTarget().getName(),
  freeCall, "在此处释放内存"