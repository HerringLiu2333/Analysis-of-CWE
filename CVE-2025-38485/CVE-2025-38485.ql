/**
 * @name 缺少synchronize_irq导致的中断处理竞态条件漏洞
 * @description 检测在禁用IIO设备缓冲区时缺少synchronize_irq调用，可能导致中断处理和设备状态变更之间的竞态条件
 * @kind problem
 * @problem.severity error
 * @precision high
 * @id cpp/missing-synchronize-irq-race-condition
 * @tags security
 *       external/cwe/cwe-362
 *       external/cwe/cwe-416
 */

import cpp

/**
 * 表示IIO设备缓冲区预禁用函数的谓词
 * 通常命名为 *_buffer_predisable 或类似的函数
 */
predicate isBufferPredisableFunction(Function f) {
  f.getName().matches("%buffer_predisable%") or
  f.getName().matches("%buffer_disable%") or
  f.getName().matches("%fifo_disable%")
}

/**
 * 表示中断同步函数调用的谓词
 * 主要检查synchronize_irq函数调用
 */
predicate isSynchronizeIrqCall(FunctionCall fc) {
  fc.getTarget().getName() = "synchronize_irq"
}

/**
 * 表示设备FIFO或缓冲区模式设置函数调用的谓词
 * 这些函数通常会改变设备状态，需要确保中断同步
 */
predicate isFifoModeSetCall(FunctionCall fc) {
  fc.getTarget().getName().matches("%fifo_set_mode%") or
  fc.getTarget().getName().matches("%buffer_mode%") or
  fc.getTarget().getName().matches("%enable_buffer%") or
  fc.getTarget().getName().matches("%disable_buffer%")
}

/**
 * 表示可能访问共享资源的中断处理函数的谓词
 * 通常命名为 *_interrupt 或 *_irq_handler
 */
predicate isInterruptHandler(Function f) {
  f.getName().matches("%interrupt%") or
  f.getName().matches("%irq_handler%") or
  f.getName().matches("%isr%")
}

/**
 * 表示FIFO刷新或数据处理函数的谓词
 * 这些函数可能会在中断上下文中被调用，访问共享资源
 */
predicate isFifoFlushFunction(Function f) {
  f.getName().matches("%fifo_flush%") or
  f.getName().matches("%data_ready%") or
  f.getName().matches("%read_fifo%")
}

/**
 * 检查函数中是否存在对active_scan_mask或类似共享资源的访问
 */
predicate accessesSharedScanMask(Function f) {
  exists(FieldAccess fa |
    fa.getEnclosingFunction() = f and
    (fa.getTarget().getName().matches("%scan_mask%") or
     fa.getTarget().getName().matches("%active_scan%"))
  )
}

/**
 * 检查函数是否可能在中断上下文中运行并访问共享资源
 */
predicate isVulnerableInterruptPath(Function f) {
  (isInterruptHandler(f) or isFifoFlushFunction(f)) and
  accessesSharedScanMask(f)
}

/**
 * 检查缓冲区禁用函数中的控制流
 */
predicate hasControlFlowToFifoMode(Function f, FunctionCall fifoCall) {
  isBufferPredisableFunction(f) and
  isFifoModeSetCall(fifoCall) and
  fifoCall.getEnclosingFunction() = f
}

/**
 * 检查在FIFO模式设置之前是否有synchronize_irq调用
 */
predicate hasSynchronizeIrqBefore(Function f, FunctionCall fifoCall) {
  exists(FunctionCall syncCall |
    isSynchronizeIrqCall(syncCall) and
    syncCall.getEnclosingFunction() = f and
    // 检查同步调用在FIFO调用之前
    syncCall.getLocation().getStartLine() < fifoCall.getLocation().getStartLine()
  )
}

from Function predisableFunc, FunctionCall fifoModeCall
where
  // 找到缓冲区预禁用函数
  isBufferPredisableFunction(predisableFunc) and
  
  // 函数中有FIFO模式设置调用
  hasControlFlowToFifoMode(predisableFunc, fifoModeCall) and
  
  // 但在FIFO模式设置之前没有synchronize_irq调用
  not hasSynchronizeIrqBefore(predisableFunc, fifoModeCall) and
  
  // 确保存在可能受影响的中断处理路径
  exists(Function vulnerableFunc |
    isVulnerableInterruptPath(vulnerableFunc) and
    // 中断处理函数和缓冲区禁用函数在同一个文件中（表示相关性）
    vulnerableFunc.getFile() = predisableFunc.getFile()
  )

select predisableFunc, 
       "缓冲区禁用函数 '" + predisableFunc.getName() + "' 在设置FIFO模式前缺少synchronize_irq调用，" +
       "可能导致与中断处理函数之间的竞态条件，造成Use-After-Free漏洞。" +
       "应在 $@ 调用前添加synchronize_irq(data->irq)进行同步。",
       fifoModeCall, fifoModeCall.getTarget().getName()